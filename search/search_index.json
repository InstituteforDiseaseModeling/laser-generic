{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LASER documentation","text":"<p>LASER (Light Agent Spatial modeling for ERadication) is a high-performance, agent-based simulation framework for modeling the spread of infectious diseases. It supports spatial structure, age demographics, and modular disease logic using Python-based components.</p> <p>The LASER framework is designed to be flexible and is composed of modular components that can be used to create custom epidemiological models. For those who want to explore disease dynamics without the need to code from scratch, the framework includes epidemiological components that are designed model diseases with non-vector transmission dynamics. These modules can be used to create anything from simple compartmental models to more complex agent-based models with spatial dynamics. The framework is open-source, so for those who want to contribute to code, contributions are welcome!</p>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>LASER is distributed as a Python package. The recommended install path for most users is through the high-level <code>laser-generic</code> package, which includes the core engine and all epidemiological modeling tools.</p>"},{"location":"#recommended-for-most-users","title":"\u2705 Recommended for most users","text":"<p>To install LASER, run:</p> <pre><code>uv pip install laser-generic\n</code></pre> <p>This installs:</p> <ul> <li><code>laser-generic</code>: modeling framework and components (e.g., SIR, SEIR, demography, mobility)</li> <li><code>laser-core</code>: the basic data structures used by <code>laser-generic</code></li> </ul> <p>Once installed, you can start using LASER (importing components and composing a model) with:</p> <pre><code>from laser.generic.model import Model\nfrom laser.generic.models.components import Susceptible\netc.\n</code></pre>"},{"location":"#for-engine-developers-only","title":"\ud83d\udee0\ufe0f For engine developers only","text":"<p>If you are developing or modifying the simulation internals, you can install the low-level engine directly:</p> <pre><code>uv pip install laser-core\n</code></pre> <p>This is not required for modelers using the LASER framework via <code>laser-generic</code>.</p>"},{"location":"#verify-the-install","title":"\ud83e\uddea Verify the install","text":"<p>Check your install with:</p> <pre><code>python -c \"import laser.generic; print('LASER is ready.')\"\n</code></pre>"},{"location":"#why-uv","title":"\ud83d\udce6 Why <code>uv</code>?","text":"<p><code>uv</code> is a modern Python package manager that is:</p> <ul> <li>Much faster than pip</li> <li>Fully compatible with <code>pip install</code></li> <li>Drop-in replacement for Python environments</li> </ul> <p>To install <code>uv</code>:</p> <pre><code>pip install uv\n</code></pre>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li> <p> Get started</p> <p>Create and run simulations.</p> <p> Get started modeling</p> </li> <li> <p> Reference</p> <p>Full details on all classes and functions.</p> <p> API reference</p> </li> <li> <p> Tutorials</p> <p>An interactive tour of key features.</p> <p> Tutorials</p> </li> <li> <p> What's new</p> <p>See what's in the latest releases.</p> <p> What's new</p> </li> </ul>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Christopher Lorton - https://www.idmod.org</li> <li>Jonathan Bloedow - https://www.idmod.org</li> <li>Katherine Rosenfeld - https://www.idmod.org</li> <li>Kevin McCarthy - https://www.idmod.org</li> </ul>"},{"location":"#glossary","title":"Glossary","text":""},{"location":"contribute/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contribute/#bug-reports","title":"Bug reports","text":"<p>When reporting a bug please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contribute/#documentation-improvements","title":"Documentation improvements","text":"<p>laser-generic could always use more documentation, whether as part of the official laser-generic docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contribute/#feature-requests-and-feedback","title":"Feature requests and feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/InstituteforDiseaseModeling/laser-generic/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that code contributions are welcome :)</li> </ul>"},{"location":"contribute/#development","title":"Development","text":"<p>To set up <code>laser-generic</code> for local development:</p> <ol> <li>Fork <code>laser-generic</code> (look for the \"Fork\" button).</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone git@github.com:YOURGITHUBNAME/laser-generic.git\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes run all the checks and docs builder with one command:</li> </ol> <pre><code>tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contribute/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>If you need some code review or feedback while you're developing the code just make the pull request.</p> <p>For merging, you should:</p> <ol> <li>Include passing tests (run <code>tox</code>).</li> <li>Update documentation when there's new API, functionality etc.</li> <li>Add a note to <code>CHANGELOG.rst</code> about the changes.</li> <li>Add yourself to <code>AUTHORS.rst</code>.</li> </ol>"},{"location":"contribute/#tips","title":"Tips","text":"<p>To run a subset of tests:</p> <pre><code>tox -e envname -- pytest -k test_myfeature\n</code></pre> <p>To run all the test environments in parallel:</p> <pre><code>tox -p auto\n</code></pre>"},{"location":"contribute/#glossary","title":"Glossary","text":""},{"location":"whatsnew/","title":"Changelog","text":""},{"location":"whatsnew/#000-2024-11-19","title":"0.0.0 (2024-11-19)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"whatsnew/#glossary","title":"Glossary","text":""},{"location":"customization/gen-files/","title":"Gen files","text":"In\u00a0[1]: Copied! <pre># docs/gen-files.py\nfrom __future__ import annotations\n</pre> # docs/gen-files.py from __future__ import annotations In\u00a0[2]: Copied! <pre>import importlib\nimport logging\nimport pkgutil\nfrom pathlib import Path\nfrom pathlib import PurePosixPath\n</pre> import importlib import logging import pkgutil from pathlib import Path from pathlib import PurePosixPath In\u00a0[3]: Copied! <pre>import mkdocs_gen_files as gen\n</pre> import mkdocs_gen_files as gen In\u00a0[4]: Copied! <pre>logger = logging.getLogger(__name__)\n</pre> logger = logging.getLogger(__name__) In\u00a0[5]: Copied! <pre>SRC = Path(\"src\")\nNS = \"laser\"\nNS_ROOT = SRC / NS\nCORE_ROOT = \"laser.core\"  # importable package\n</pre> SRC = Path(\"src\") NS = \"laser\" NS_ROOT = SRC / NS CORE_ROOT = \"laser.core\"  # importable package In\u00a0[6]: Copied! <pre>def ref_md(dotted: str) -&gt; str:\n    \"\"\"reference/&lt;dotted&gt;/index.md with POSIX separators.\"\"\"\n    return str(PurePosixPath(\"reference\") / \"/\".join(dotted.split(\".\")) / \"index.md\")\n</pre> def ref_md(dotted: str) -&gt; str:     \"\"\"reference//index.md with POSIX separators.\"\"\"     return str(PurePosixPath(\"reference\") / \"/\".join(dotted.split(\".\")) / \"index.md\") In\u00a0[7]: Copied! <pre>def emit_page(dotted: str, body: str | None = None) -&gt; None:\n    with gen.open(ref_md(dotted), \"w\") as f:\n        if body is None:\n            f.write(f\"# {dotted}\\n\\n\")\n            f.write(f\"::: {dotted}\\n\")\n            f.write(\"    options:\\n\")\n            f.write(\"      show_root_heading: true\\n\")\n            f.write(\"      members_order: alphabetical\\n\")\n            f.write(\"      show_source: false\\n\")\n        else:\n            f.write(body)\n</pre> def emit_page(dotted: str, body: str | None = None) -&gt; None:     with gen.open(ref_md(dotted), \"w\") as f:         if body is None:             f.write(f\"# {dotted}\\n\\n\")             f.write(f\"::: {dotted}\\n\")             f.write(\"    options:\\n\")             f.write(\"      show_root_heading: true\\n\")             f.write(\"      members_order: alphabetical\\n\")             f.write(\"      show_source: false\\n\")         else:             f.write(body) In\u00a0[8]: Copied! <pre># ---------- collect from disk: every module + all ancestor packages ----------\npackages: set[str] = set()\nmodules: set[str] = set()\n</pre> # ---------- collect from disk: every module + all ancestor packages ---------- packages: set[str] = set() modules: set[str] = set() In\u00a0[9]: Copied! <pre># Ensure the root 'laser' landing exists so we can nest under it if desired\npackages.add(NS)\n</pre> # Ensure the root 'laser' landing exists so we can nest under it if desired packages.add(NS) In\u00a0[10]: Copied! <pre>for py in NS_ROOT.rglob(\"*.py\"):\n    if py.name == \"__init__.py\":\n        # still create the package page for its directory\n        pkg = py.parent.relative_to(SRC).as_posix().replace(\"/\", \".\")\n        packages.add(pkg)\n        continue\n\n    # module page for each file\n    rel_mod = py.relative_to(SRC).with_suffix(\"\")\n    dotted_mod = rel_mod.as_posix().replace(\"/\", \".\")\n    modules.add(dotted_mod)\n\n    # ancestor packages up to 'laser'\n    p = py.parent\n    while True:\n        rel_pkg = p.relative_to(SRC).as_posix().replace(\"/\", \".\")\n        packages.add(rel_pkg)\n        if rel_pkg == NS:\n            break\n        p = p.parent\n</pre> for py in NS_ROOT.rglob(\"*.py\"):     if py.name == \"__init__.py\":         # still create the package page for its directory         pkg = py.parent.relative_to(SRC).as_posix().replace(\"/\", \".\")         packages.add(pkg)         continue      # module page for each file     rel_mod = py.relative_to(SRC).with_suffix(\"\")     dotted_mod = rel_mod.as_posix().replace(\"/\", \".\")     modules.add(dotted_mod)      # ancestor packages up to 'laser'     p = py.parent     while True:         rel_pkg = p.relative_to(SRC).as_posix().replace(\"/\", \".\")         packages.add(rel_pkg)         if rel_pkg == NS:             break         p = p.parent In\u00a0[11]: Copied! <pre># ---------- collect from installed laser.core ----------\ncore_items: set[str] = set()\ntry:\n    core_pkg = importlib.import_module(CORE_ROOT)\n    core_items.add(CORE_ROOT)\n    for _, name, _ in pkgutil.walk_packages(core_pkg.__path__, prefix=CORE_ROOT + \".\"):\n        core_items.add(name)\nexcept Exception as e:\n    # not importable in this environment; fine\n    logger.debug(\"Optional import failed: %s\", e)\n</pre> # ---------- collect from installed laser.core ---------- core_items: set[str] = set() try:     core_pkg = importlib.import_module(CORE_ROOT)     core_items.add(CORE_ROOT)     for _, name, _ in pkgutil.walk_packages(core_pkg.__path__, prefix=CORE_ROOT + \".\"):         core_items.add(name) except Exception as e:     # not importable in this environment; fine     logger.debug(\"Optional import failed: %s\", e) In\u00a0[12]: Copied! <pre># ---------- emit all pages ----------\nemitted: set[str] = set()\n</pre> # ---------- emit all pages ---------- emitted: set[str] = set() In\u00a0[13]: Copied! <pre>def emit_once(dotted: str, body: str | None = None) -&gt; None:\n    if dotted in emitted:\n        return\n    emit_page(dotted, body)\n    emitted.add(dotted)\n</pre> def emit_once(dotted: str, body: str | None = None) -&gt; None:     if dotted in emitted:         return     emit_page(dotted, body)     emitted.add(dotted) In\u00a0[14]: Copied! <pre># small landing for 'laser'\nemit_once(NS, f\"# {NS}\\n\\nRoot namespace for LASER packages.\\n\")\n</pre> # small landing for 'laser' emit_once(NS, f\"# {NS}\\n\\nRoot namespace for LASER packages.\\n\") In\u00a0[15]: Copied! <pre>for name in sorted(packages, key=lambda s: (s.count(\".\"), s)):\n    emit_once(name)\n</pre> for name in sorted(packages, key=lambda s: (s.count(\".\"), s)):     emit_once(name) In\u00a0[16]: Copied! <pre>for name in sorted(modules, key=lambda s: (s.count(\".\"), s)):\n    emit_once(name)\n</pre> for name in sorted(modules, key=lambda s: (s.count(\".\"), s)):     emit_once(name) In\u00a0[17]: Copied! <pre>for name in sorted(core_items, key=lambda s: (s.count(\".\"), s)):\n    emit_once(name)\n</pre> for name in sorted(core_items, key=lambda s: (s.count(\".\"), s)):     emit_once(name) <p>---------- SUMMARY.md (two siblings, with correct hierarchical ordering) ----------</p> In\u00a0[18]: Copied! <pre>def _build_tree(root: str, names: set[str]) -&gt; dict:\n    \"\"\"\n    Build a nested dict representing the subtree under `root`.\n    Ensures all intermediate parents are present.\n    Example tree keys are the *segment* names (e.g., 'generic', 'models', 'SEIR').\n    \"\"\"\n    root_parts = root.split(\".\")\n    tree: dict = {}\n\n    def insert(parts: list[str]) -&gt; None:\n        node = tree\n        for seg in parts:\n            node = node.setdefault(seg, {})\n\n    # Consider only entries under the root (including root itself, though we'll render root separately)\n    for full in (n for n in names if n == root or n.startswith(root + \".\")):\n        parts = full.split(\".\")\n        # Add every prefix between root and the leaf\n        for i in range(len(root_parts) + 1, len(parts) + 1):\n            insert(parts[len(root_parts) : i])  # relative parts under root\n\n    return tree\n</pre> def _build_tree(root: str, names: set[str]) -&gt; dict:     \"\"\"     Build a nested dict representing the subtree under `root`.     Ensures all intermediate parents are present.     Example tree keys are the *segment* names (e.g., 'generic', 'models', 'SEIR').     \"\"\"     root_parts = root.split(\".\")     tree: dict = {}      def insert(parts: list[str]) -&gt; None:         node = tree         for seg in parts:             node = node.setdefault(seg, {})      # Consider only entries under the root (including root itself, though we'll render root separately)     for full in (n for n in names if n == root or n.startswith(root + \".\")):         parts = full.split(\".\")         # Add every prefix between root and the leaf         for i in range(len(root_parts) + 1, len(parts) + 1):             insert(parts[len(root_parts) : i])  # relative parts under root      return tree In\u00a0[19]: Copied! <pre>def _render_tree(root: str, tree: dict) -&gt; list[str]:\n    \"\"\"\n    Render the nested dict as literate-nav bullets under `root`.\n    Outputs links relative to 'reference/' using '.../index.md'.\n    \"\"\"\n    lines: list[str] = []\n\n    def walk(rel_parts: list[str], node: dict):\n        # rel_parts is the path under the root (e.g., ['generic', 'models'])\n        dotted = \".\".join([root, *rel_parts])\n        depth = len(rel_parts)  # depth under the root\n        indent = \"  \" * depth  # bullet indent under the root line we'll add earlier\n        path = \"/\".join([root.replace(\".\", \"/\"), *rel_parts]) + \"/index.md\"\n        lines.append(f\"{indent}- [{dotted}]({path})\\n\")\n        for seg in sorted(node.keys()):\n            walk([*rel_parts, seg], node[seg])\n\n    # walk each top-level child under the root\n    for seg in sorted(tree.keys()):\n        walk([seg], tree[seg])\n\n    return lines\n</pre> def _render_tree(root: str, tree: dict) -&gt; list[str]:     \"\"\"     Render the nested dict as literate-nav bullets under `root`.     Outputs links relative to 'reference/' using '.../index.md'.     \"\"\"     lines: list[str] = []      def walk(rel_parts: list[str], node: dict):         # rel_parts is the path under the root (e.g., ['generic', 'models'])         dotted = \".\".join([root, *rel_parts])         depth = len(rel_parts)  # depth under the root         indent = \"  \" * depth  # bullet indent under the root line we'll add earlier         path = \"/\".join([root.replace(\".\", \"/\"), *rel_parts]) + \"/index.md\"         lines.append(f\"{indent}- [{dotted}]({path})\\n\")         for seg in sorted(node.keys()):             walk([*rel_parts, seg], node[seg])      # walk each top-level child under the root     for seg in sorted(tree.keys()):         walk([seg], tree[seg])      return lines In\u00a0[20]: Copied! <pre>def _write_block(root: str, pool: set[str]) -&gt; list[str]:\n    \"\"\"\n    Write the top-level root entry and a properly ordered subtree beneath it.\n    \"\"\"\n    # Top-level root entry (sibling under API reference)\n    out: list[str] = [f\"- [{root}]({root.replace('.', '/')}/index.md)\\n\"]\n    subtree = _build_tree(root, pool)\n    out.extend(_render_tree(root, subtree))\n    return out\n</pre> def _write_block(root: str, pool: set[str]) -&gt; list[str]:     \"\"\"     Write the top-level root entry and a properly ordered subtree beneath it.     \"\"\"     # Top-level root entry (sibling under API reference)     out: list[str] = [f\"- [{root}]({root.replace('.', '/')}/index.md)\\n\"]     subtree = _build_tree(root, pool)     out.extend(_render_tree(root, subtree))     return out In\u00a0[21]: Copied! <pre># Build SUMMARY with two sibling blocks\nsummary_lines: list[str] = [\"# API reference\\n\"]\nsummary_lines += _write_block(\"laser.core\", emitted)  # emitted contains both disk + core\nsummary_lines += _write_block(\"laser.generic\", emitted)\n</pre> # Build SUMMARY with two sibling blocks summary_lines: list[str] = [\"# API reference\\n\"] summary_lines += _write_block(\"laser.core\", emitted)  # emitted contains both disk + core summary_lines += _write_block(\"laser.generic\", emitted) In\u00a0[22]: Copied! <pre>with gen.open(\"reference/SUMMARY.md\", \"w\") as f:\n    f.write(\"\".join(summary_lines))\n</pre> with gen.open(\"reference/SUMMARY.md\", \"w\") as f:     f.write(\"\".join(summary_lines))"},{"location":"get-started/","title":"Get started","text":"<p>LASER is intended for modeling diseases with straightforward and predictable transmission dynamics, such as influenza or measles.</p>"},{"location":"get-started/#installation","title":"Installation","text":"<p>See the Home page for installation instructions.</p>"},{"location":"get-started/#usage","title":"Usage","text":"<p>To use the project:</p> <pre><code>import laser.generic\nlaser.generic.compute(...)\n</code></pre>"},{"location":"get-started/#build-a-model","title":"Build a model","text":"<p>LASER is designed to be modular and flexible to accommodate a variety of modeling needs. The example below will demonstrate the basic set up of a LASER model, using a simple, 25-patch SEIR-like model with vital dynamics (births).</p> <ol> <li> <p>Define the scenario.</p> <p>You must define a <code>scenario</code> DataFrame with one row per patch, each including a <code>population</code>, and optionally <code>latitude</code> and <code>longitude</code> for plotting or spatial coupling.</p> <p>This example defines a 5\u00d75 grid of patches with larger center and smaller outer nodes.</p> <pre><code>import pandas as pd\n\ndef make_city_scenario(n=5, spacing=1.0):\n    coords = [(i*spacing, j*spacing) for i in range(-(n//2), n//2+1)\n                                    for j in range(-(n//2), n//2+1)]\n    pops = []\n    for (x, y) in coords:\n        dist = abs(x) + abs(y)\n        if dist == 0:\n            pops.append(5000)    # city center\n        elif dist == 1:\n            pops.append(2000)    # suburbs\n        else:\n            pops.append(500)     # rural\n    return pd.DataFrame({\n        \"population\": pops,\n        \"latitude\": [y for (x, y) in coords],\n        \"longitude\": [x for (x, y) in coords],\n    })\n\nscenario = make_city_scenario()\n</code></pre> </li> <li> <p>Define the simulation parameters.</p> <p>LASER uses a <code>PropertySet</code> (like a dict) to define model-wide parameters. Start with defaults and override as needed.</p> <pre><code>from laser.generic.utils import get_default_parameters\n\nparams = get_default_parameters() | {\n    \"seed\": 42,\n    \"beta\": 0.3,         # transmission rate\n    \"inf_mean\": 5.0,     # mean infectious period\n    \"inf_sigma\": 1.0,    # stddev infectious period\n}\n\n# Optional importation settings\n# params |= {\n#     \"importation_period\": 10,\n#     \"importation_count\": 5,\n#     \"importation_start\": 0,\n#     \"importation_end\": 50,\n# }\n</code></pre> </li> <li> <p>Create the model.</p> <p>This initializes patch-level arrays and allocates the population frame.</p> <pre><code>from laser.generic.model import Model\n\nmodel = Model(scenario, params)\n</code></pre> </li> <li> <p>Attach components.</p> <p>Components are step functions called every tick. Attach those you want in order.</p> <pre><code>from laser.generic.transmission import Transmission\nfrom laser.generic.susceptibility import Susceptibility\nfrom laser.generic.exposure import Exposure\nfrom laser.generic.infection import Infection\nfrom laser.generic.importation import Infect_Random_Agents\nfrom laser.generic.births import Births\n\nmodel.components = [\n    Births,                # assigns dob\n    Susceptibility,        # creates .susceptibility property\n    Transmission,          # simulates infection pressure\n    Exposure,              # tracks latent infections\n    Infection,             # resolves infectious \u2192 recovered\n    Infect_Random_Agents,  # seeds infections over time\n]\n\n# Optional: ensure safe integer arithmetic\nimport numpy as np\nmodel.patches.populations = model.patches.populations.astype(np.int64)\n</code></pre> </li> <li> <p>Run the simulation.</p> <p>Once components are attached, run the simulation.</p> <pre><code>model.run()\n</code></pre> </li> <li> <p>Export patch-level time series.</p> <p>Use this helper to export all <code>(tick, patch, variable)</code> values into a long-format CSV or HDF file.</p> <pre><code>def export_patch_timeseries(model, filename=\"report.csv\", format=\"csv\"):\n    import pandas as pd\n    import numpy as np\n\n    npatches = len(model.patches)\n    vars = {}\n    for name in dir(model.patches):\n        arr = getattr(model.patches, name, None)\n        if isinstance(arr, np.ndarray) and arr.ndim == 2 and arr.shape[1] == npatches:\n            vars[name] = arr\n\n    records = []\n    maxtime = max(arr.shape[0] for arr in vars.values())\n    for t in range(maxtime):\n        for p in range(npatches):\n            row = {\"tick\": t, \"patch\": p}\n            for v, arr in vars.items():\n                if t &lt; arr.shape[0]:\n                    row[v] = arr[t, p]\n            records.append(row)\n\n    df = pd.DataFrame(records)\n\n    if format == \"csv\":\n        df.to_csv(filename, index=False)\n    elif format == \"h5\":\n        df.to_hdf(filename, key=\"laser\", mode=\"w\")\n    else:\n        raise ValueError(f\"Unsupported format: {format}\")\n\n    print(f\"Exported patch-level time series to {filename}\")\n    return df\n\n# Export to disk\ndf = export_patch_timeseries(model, \"patch_report.csv\", format=\"csv\")\n</code></pre> </li> <li> <p>Inspect or visualize output.</p> <p>LASER provides built-in visualizations: scenario maps, birth distributions, and timing pie charts.</p> <pre><code>model.visualize(pdf=False)\n\nprint(\"Simulation complete.\")\nprint(\"Patch populations over time (first 10 ticks):\")\nprint(model.patches.populations[:10, :])\nprint(\"Cases test over time (first 100 ticks):\")\nprint(model.patches.cases_test[:100, :])\n</code></pre> </li> </ol>"},{"location":"get-started/#using-ai","title":"Using AI","text":"<p>For internal IDM users, you can use a pre-built AI interface, JENNER-GPT to create your simulations.</p>"},{"location":"get-started/#tutorials","title":"Tutorials","text":"<p>The Tutorials section begins with example code to demonstrate setting up simple SIR models and gradually adding complexity. For an interactive experience, begin with the first Jupyter notebook tutorial SI model with no demographics for a very simple implementation of the LASER model</p>"},{"location":"get-started/#glossary","title":"Glossary","text":""},{"location":"get-started/calibration/","title":"Calibrate LASER models","text":"<p>LASER can be calibrated using Optuna. Calibration is a process of tuning model parameters to fit real-world data, to ensure that model output provides accurate insights. Calibration can also be used as a method to help debug your model, as an inability to recreate known phenomena can help pinpoint issues in model code. For more information on calibration, check out IDM's ModelingHub.</p>"},{"location":"get-started/calibration/#simple-local-calibration","title":"Simple local calibration","text":"<ol> <li> <p>Expose parameters in your model. Ensure your LASER model can load and apply parameters you wish to calibrate. These are typically passed through a <code>params</code> dictionary or a <code>PropertySet</code> and might include:</p> <ul> <li>Basic reproduction number (R0)</li> <li>Duration of infection</li> <li>Seeding prevalence</li> </ul> </li> <li> <p>Write post-processing code. Modify your model to save key outputs (e.g., number of infected individuals over time) to a CSV file. For example, use:</p> <p><code>save_results_to_csv(sim.results)</code></p> <p>This CSV will be used later by the objective function.</p> </li> <li> <p>Create the objective function. Write a Python script, usually named <code>objective.py</code>, containing a function like this:</p> <pre><code>def objective(trial):\n    # Load trial parameters\n    R0 = trial.suggest_float(\"R0\", 1.0, 3.5)\n\n    # Run model (via subprocess, or function call)\n    run_model(R0)\n\n    # Load model output and reference data\n    model_df = pd.read_csv(\"output.csv\")\n    ref_df = pd.read_csv(\"reference.csv\")\n\n    # Compare and return score\n    error = np.mean((model_df[\"I\"] - ref_df[\"I\"])**2)\n    return error\n</code></pre> <p>Tip: You can write unit tests for your objective function by mocking model outputs.</p> </li> <li> <p>Test the objective function standalone. Before integrating with Optuna, run your objective function directly to ensure it works:</p> <pre><code>from objective import objective\nfrom optuna.trial import FixedTrial\n\nscore = objective(FixedTrial({\"R0\": 2.5}))\nprint(f\"Test score: {score}\")\n</code></pre> <p>Expected result: A numeric score. If it crashes, check CSV paths and data types.</p> </li> <li> <p>Run simple calibration (SQLite, no Docker). Use the calib/worker.py helper to run a local test study with a small number of trials.</p> <p>Linux/macOS (Bash or similar):</p> <pre><code>export STORAGE_URL=sqlite:///example.db &amp;&amp; python3 calib/worker.py --num-trials=10\n</code></pre> <p>Windows (PowerShell):</p> <pre><code>$env:STORAGE_URL=\"sqlite:///example.db\"; python calib/worker.py --num-trials=10\n</code></pre> <p>This is helpful for debugging. Consider running a scaled-down version of your model to save time.</p> </li> </ol>"},{"location":"get-started/calibration/#local-dockerized-calibration","title":"Local Dockerized calibration","text":"<ol> <li> <p>Dockerize your model and objective. Use the provided <code>Dockerfile</code> to build a container that includes both your model and objective function. Do this from the main directory.</p> <p><code>docker build . -f calib/Dockerfile -t idm-docker-staging.packages.idmod.org/laser/laser-polio:latest</code></p> </li> <li> <p>Create Docker network. You\u2019ll need a shared network so your workers and database container can communicate:</p> <p><code>docker network create optuna-network</code></p> </li> <li> <p>Launch MySQL database container:</p> <pre><code>docker run -d --name optuna-mysql --network optuna-network -p 3306:3306 \\\n  -e MYSQL_ALLOW_EMPTY_PASSWORD=yes \\\n  -e MYSQL_DATABASE=optuna_db mysql:latest\n</code></pre> </li> <li> <p>Launch calibration worker:</p> <pre><code>docker run --rm --name calib_worker --network optuna-network \\\n  -e STORAGE_URL=\"mysql://root@optuna-mysql:3306/optuna_db\" \\\n  idm-docker-staging.packages.idmod.org/laser/laser-polio:latest \\\n  --study-name test_polio_calib --num-trials 1\n</code></pre> <p>If that works, you can change the study name or number of trials.</p> <p>Troubleshooting: If this fails, try running the worker interactively and debug inside:</p> <p><code>docker run -it --network optuna-network --entrypoint /bin/bash idm-docker-staging.packages.idmod.org/laser/laser-polio:latest</code></p> </li> <li> <p>Monitor calibration progress:</p> <p>Use Optuna CLI. You should be able to pip install optuna.</p> <pre><code>optuna trials \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://root:@localhost:3306/optuna_db\"\n\noptuna best-trial \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://root:@localhost:3306/optuna_db\"\n</code></pre> </li> </ol>"},{"location":"get-started/calibration/#cloud-calibration","title":"Cloud calibration","text":"<ol> <li> <p>Push Docker image to registry. If you\u2019ve built a new docker image, you\u2019ll want to push it so it\u2019s available to AKS:</p> <p><code>docker push idm-docker-staging.packages.idmod.org/laser/laser-polio:latest</code></p> </li> <li> <p>Cloud deployment. This step assumes you have secured access to an Azure Kubernetes Service (AKS) cluster. You may need to obtain or generate a new kube config file. Detailed instructions for that are not included here. This step assumes the cluster corresponding to your config is up and accessible.</p> <p><code>cd calib/cloud</code></p> <p>Edit <code>cloud_calib_config.py</code> to set the <code>storage_url</code> to:</p> <p><code>\"mysql+pymysql://optuna:superSecretPassword@localhost:3306/optunaDatabase\"</code></p> <p>Set the study name and number of trials per your preference. Detailed documentation of the other parameters is not included here.</p> <p>Launch multiple workers:</p> <p><code>python3 run_calib_workers.py</code></p> </li> <li> <p>View final results:</p> <p>Forward port to local machine. Note that is the first instruction to rely on installing <code>kubectl</code>. Open a bash shell if necessary.</p> <p><code>kubectl port-forward mysql-0 3306:3306 &amp;</code></p> <p>Use Optuna CLI to check results:</p> <pre><code>optuna trials \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://optuna:superSecretPassword@localhost:3306/optunaDatabase\"\n\noptuna best-trial \\\n  --study-name=test_polio_calib \\\n  --storage \"mysql+pymysql://optuna:superSecretPassword@localhost:3306/optunaDatabase\"\n</code></pre> <p>Generate a report on disk about the study (can be run during study or at end).</p> <p><code>python3 report_calib_aks.py</code></p> <p>Launch Optuna dashboard:</p> <p><code>python -c \"import optuna_dashboard; optuna_dashboard.run_server('mysql+pymysql</code></p> </li> </ol>"},{"location":"get-started/calibration/#glossary","title":"Glossary","text":""},{"location":"get-started/initialization/","title":"Load data and initialize populations","text":""},{"location":"get-started/initialization/#load-data","title":"Load data","text":""},{"location":"get-started/initialization/#initialize-populations","title":"Initialize populations","text":""},{"location":"get-started/initialization/#squash-save-and-load","title":"Squash, save, and load","text":"<p>As the number agents in your LASER population model grows (e.g., 1e8), it can become computationally expensive and unnecessary to repeatedly run the same initialization routine every sim. In many cases \u2014 particularly during model calibration \u2014 it is far more efficient to initialize the population once, save it, and then reload the initialized state for subsequent runs.</p> <p>This approach is especially useful when working with EULAs \u2013 Epidemiologically Uninteresting Light Agents. For example, it can be a very powerful optimization to compress all the agents who are already (permanently) recovered or immune in a measles or polio model into a number/bucket. In such models, the majority of the initial population may be in the \u201cRecovered\u201d state, potentially comprising 90% or more of all agents. If you are simulating 100 million agents, storing all of them can result in punitive memory usage.</p> <p>To address this, LASER supports a squashing process. Squashing involves defragmenting the data frame such that all epidemiologically active or \u201cinteresting\u201d agents (e.g., Susceptible or Infectious) are moved to the beginning of the array or table, and less relevant agents (e.g., Recovered) are moved to the end. Though please note that you should assume that squashed agent data is overwritten.</p> <p>Some notes about squashing:</p> <ul> <li>The population count is adjusted so that all for loops and step functions iterate only over the active population.</li> <li>This not only reduces memory usage but also improves performance by avoiding unnecessary computation over inactive agents.</li> </ul> <p>Some notes about using saved populations:</p> <ul> <li>You will want to be confident that the saved population is sufficiently randomized and representative of your overall population.</li> <li>If you are calibrating parameters used to create the initial population in the first place, you\u2019ll need to recreate those parts of the population after loading, diminishing the benefit of the save/load approach.</li> <li> <p>When saving a snapshot, note that only the active (unsquashed) portion of the population is saved. Upon reloading:</p> <ul> <li>Only this subset is allocated in memory.</li> <li>This prevents the performance penalty of managing large volumes of unused agent data.</li> </ul> </li> </ul> <p>Note</p> <p>Before squashing, you should count and record the number of recovered (or otherwise squashed) agents. This count should be stored in a summary variable \u2014- typically the R column of the results data frame. This ensures your model retains a complete epidemiological record even though the agents themselves are no longer instantiated.</p> <p>Procedure:</p> <ol> <li> <p>Add squashing:</p> <ul> <li>Add a <code>squash_recovered()</code> function. This should call <code>LaserFrame.squash(\u2026)</code> with a boolean mask that includes non-recovered agents (disease_state != 2). You may choose a different criterion, such as age-based squashing.</li> <li>Count your \u201csquashed away\u201d agents first. You must compute and store all statistics related to agents being squashed before the <code>squash()</code> call. After squashing, only the left-hand portion of the arrays (up to .count) remains valid.</li> <li>Seed infections after squashing. If your model seeds new infections (disease_state == 1), this must happen after squashing. Otherwise, infected agents may be inadvertently removed.</li> <li>Store the squashed-away totals by node. Before squashing, compute and record node-wise totals (e.g., recovered counts) in <code>results.R[0, :]</code> so this pre-squash information persists.</li> <li>(Optionally) simulate EULA effects once and save. If modeling aging or death among squashed agents, simulate this up front and store the full <code>[time, node]`` matrix (e.g.,</code>results.R[:, :]`). This avoids recomputation at runtime.</li> </ul> </li> <li> <p>Save function: implement a <code>save(path)</code> method:</p> <ul> <li>Use <code>LaserFrame.save_snapshot(path, results_r=..., pars=...)</code></li> <li>Include:<ul> <li>The squashed population (active agents only)</li> <li>The <code>results.R</code> matrix containing both pre-squash and live simulation values</li> <li>The full parameter set in a <code>PropertySet</code></li> </ul> </li> </ul> </li> <li> <p>Load function: implement a <code>load(path)</code> class method:</p> <ul> <li>Call <code>LaserFrame.load_snapshot(path)</code> to retrieve:<ul> <li>Population frame</li> <li>Results matrix</li> <li>Parameters</li> </ul> </li> <li>Set <code>.capacity = .count</code> if not doing births, else set capacity based on projected population growth from count.</li> <li>Reconstruct all components using <code>init_from_file()</code></li> </ul> <p>Warning</p> <p>When modeling vital dynamics, especially births, there is an additional step needed to ensure consistency after loading:</p> <p>Property initialization for unborn individuals must be repeated if your model pre-assigns properties up to <code>.capacity</code>. For example, if timers or demographic attributes (like <code>date_of_birth</code>) are pre-initialized at <code>t=0</code>, you must ensure this initialization is re-applied after loading, because only the <code>.count</code> population is reloaded, not the future <code>.capacity</code>.</p> <p>Failing to do so may result in improperly initialized agents being birthed after the snapshot load, which can lead to subtle or catastrophic model errors.</p> </li> <li> <p>Preserve EULA'd results:</p> <p>Use \"+=\" to track new recoveries alongside pre-squash R values. In <code>run()</code>, use additive updates so that pre-saved recovered agents are preserved:</p> <pre><code>self.results.R[t, nid] += ((self.population.node_id == nid) &amp;\n                       (self.population.disease_state == 2)).sum()\n</code></pre> <p>This ensures your output accounts for both squashed-away immunity and recoveries during the live simulation.</p> </li> </ol> Code example: Add squashing and snapshot support to SIR models <pre><code>import numpy as np\nimport click\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\nfrom laser.core import LaserFrame, PropertySet\n\nclass Transmission:\n    \"\"\"\n    A simple transmission component that spreads infection within each node.\n    \"\"\"\n    def __init__(self, population, pars):\n        self.population = population\n        self.pars = pars\n\n    def step(self):\n    \"\"\"\n    For each node in the population, calculate the number of new infections as a function of:\n    - the number of infected individuals,\n    - the number of susceptibles,\n    - adjustments for migration and seasonality,\n    - and individual-level heterogeneity.\n\n    Then, select new infections at random from among the susceptible individuals in each node,\n    and initiate infection in those individuals.\n    \"\"\"\n    pass  # Implementation omitted for documentation purposes\n\n    @classmethod\n    def init_from_file(cls, population, pars):\n        return cls(population, pars)\n\nclass Progression:\n    \"\"\"\n    A simple progression component that recovers infected individuals probabilistically.\n    \"\"\"\n    def __init__(self, population, pars):\n        self.population = population\n        self.pars = pars\n\n    def step(self):\n    \"\"\"\n    At each time step, update the disease state of infected individuals based on the model's\n    progression logic. This may be driven by probabilities, timers, or other intrahost dynamics.\n    \"\"\"\n    pass  # Implementation omitted for documentation\n\n    @classmethod\n    def init_from_file(cls, population, pars):\n        return cls(population, pars)\n\nclass RecoveredSquashModel:\n    \"\"\"\n    A simple multi-node SIR model demonstrating use of LASER's squash and snapshot mechanisms.\n    \"\"\"\n    def __init__(self, num_agents=100000, num_nodes=20, timesteps=365):\n        self.num_agents = num_agents\n        self.num_nodes = num_nodes\n        self.timesteps = timesteps\n        self.population = LaserFrame(capacity=num_agents, initial_count=num_agents)\n        self.population.add_scalar_property(\"node_id\", dtype=np.int32)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int8)  # 0=S, 1=I, 2=R\n\n        self.results = LaserFrame(capacity=self.num_nodes)\n        self.results.add_vector_property(\"S\", length=timesteps, dtype=np.int32)\n        self.results.add_vector_property(\"I\", length=timesteps, dtype=np.int32)\n        self.results.add_vector_property(\"R\", length=timesteps, dtype=np.int32)\n\n        self.pars = PropertySet({\n            \"r0\": 2.5,\n            \"migration_k\": 0.1,\n            \"seasonal_factor\": 0.8,\n            \"transmission_prob\": 0.2,\n            \"recovery_days\": 14\n        })\n\n        self.components = [\n            Transmission(self.population, self.pars),\n            Progression(self.population, self.pars)\n            # could add other components like vaccination\n        ]\n\n    def initialize(self):\n        np.random.seed(42)\n        self.population.node_id[:] = np.random.randint(0, self.num_nodes, size=self.num_agents)\n        recovered = np.random.rand(self.num_agents) &lt; 0.6\n        self.population.disease_state[:] = np.where(recovered, 2, 0)\n\n    def seed_infections(self):\n        susceptible = self.population.disease_state == 0\n        num_seed = max(1, int(0.001 * self.population.count))\n        seed_indices = np.random.choice(np.where(susceptible)[0], size=num_seed, replace=False)\n        self.population.disease_state[seed_indices] = 1\n\n    def squash_recovered(self):\n        \"\"\"\n        Removes all agents who are recovered (state 2).\n        This reduces memory footprint and speeds up simulation.\n        \"\"\"\n        keep = self.population.disease_state[:self.population.count] != 2\n        self.population.squash(keep)\n\n    def populate_results(self):\n        \"\"\"\n        Populate initial R values before squashing to reflect the pre-squash immunity landscape.\n        \"\"\"\n        for nid in range(self.num_nodes):\n            initial_r = ((self.population.disease_state == 2) &amp; (self.population.node_id == nid)).sum()\n            decay = np.linspace(initial_r, initial_r * 0.9, self.timesteps, dtype=int)\n            self.results.R[:, nid] = decay\n        print(\"Initial R counts per node:\", self.results.R[0, :])\n        print(\"Total initial R (summed):\", self.results.R[0, :].sum())\n\n    def run(self):\n        for t in range(self.timesteps):\n            for component in self.components:\n                component.step()\n            for nid in range(self.num_nodes):\n                self.results.S[t, nid] = ((self.population.node_id == nid) &amp; (self.population.disease_state == 0)).sum()\n                self.results.I[t, nid] = ((self.population.node_id == nid) &amp; (self.population.disease_state == 1)).sum()\n                self.results.R[t, nid] += ((self.population.node_id == nid) &amp; (self.population.disease_state == 2)).sum()\n\n    def save(self, path):\n        \"\"\"\n        Save the current model state to an HDF5 file, including population frame,\n        pre-squash results, and simulation parameters.\n        \"\"\"\n        self.population.save_snapshot(path, results_r=self.results.R, pars=self.pars)\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"\n        Reload a model from an HDF5 snapshot. Note: reloaded population will have\n        only post-squash agents (e.g., susceptibles and infected).\n        \"\"\"\n        pop, results_r, pars = LaserFrame.load_snapshot(path)\n        model = cls(num_agents=pop.capacity, num_nodes=results_r.shape[1], timesteps=results_r.shape[0])\n        model.population = pop\n        model.results.R[:, :] = results_r\n        model.pars = PropertySet(pars)\n        model.pars[\"transmission_prob\"] /= 10  # example modification after reload\n        model.components = [\n            Transmission.init_from_file(model.population, model.pars),\n            Progression.init_from_file(model.population, model.pars)\n        ]\n        return model\n\n    def plot(self):\n        \"\"\"\n        Plot the time series of total S, I, and R across all nodes.\n        \"\"\"\n        # details omitted\n\n@click.command()\n@click.option(\"--init-pop-file\", type=click.Path(), default=None, help=\"Path to snapshot to resume from.\")\n@click.option(\"--output\", type=click.Path(), default=\"model_output.h5\")\ndef main(init_pop_file, output):\n    if init_pop_file:\n        model = RecoveredSquashModel.load(init_pop_file)\n        model.run()\n        model.plot()\n    else:\n        model = RecoveredSquashModel()\n        model.initialize()\n        model.seed_infections()\n        model.populate_results()\n        model.squash_recovered()\n        model.save(output)\n        print(f\"Initial population saved to {output}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"get-started/initialization/#glossary","title":"Glossary","text":""},{"location":"get-started/optimization/","title":"Optimize LASER models","text":"<p>As an agent-based model, research using LASER will require thousands of simulation replicates. While the model is designed to perform well with large agent populations, there is still a need to utilize high compute power and to optimize model performance.</p> <p>When creating LASER models, knowing how to identify and fix performance bottlenecks can save compute time and speed results.</p>"},{"location":"get-started/optimization/#identify-bottlenecks","title":"Identify bottlenecks","text":"<p>Typically, we do not recommend running the code through a profiler, at least not initially. Instead, we take advantage of LASER\u2019s highly modular structure and AI-driven optimization.</p> <p>The first step is to add simple timing code that tracks the total time spent in each component over a realistic simulation. Then, plot a pie chart at the end to visualize where the most time is spent. A simple way to track execution time is using the <code>time package</code>.</p> Code example: Identify bottlenecks <pre><code>def run(self):\n    self.component_times = {component.__class__.__name__: 0 for component in self.components}\n    self.component_times[\"reporting\"] = 0\n    for tick in tqdm(range(self.pars.timesteps)):\n        for component in self.components:\n            start_time = time.time()  # Start timing for the component\n            component.step()\n            end_time = time.time()  # End timing for the component\n\n            # Accumulate the time taken for this component\n            elapsed_time = end_time - start_time\n            component_name = component.__class__.__name__\n</code></pre> <p>This often reveals the top one to three performance bottlenecks. Focus first on the biggest offender\u2014it provides the most opportunity for speedup. Often, the largest bottleneck is not what you might instinctively expect. Avoid optimizing a component only to find out it contributes just a small percentage of the total runtime. A modest improvement in the runtime of an \u201cexpensive\u201d component is often more effective than spending a lot of time on highly optimizing a component which only accounts for a small fraction of runtime. Also, make sure that your reporting code is being measured and reported, ideally in its own \u2018bucket\u2019. This may be easier or harder depending on how you are doing reporting. Since reporting usually involves counting over the entire population, it usually shows up as a hotspot sooner or later. Fortunately, it\u2019s usually fairly easy to speed up. Or even eliminate.</p>"},{"location":"get-started/optimization/#leverage-ai","title":"Leverage AI","text":"<p>Once you have identified the slowest component, the easiest way to improve performance is by using ChatGPT. Try prompting with:</p> <p><code>\"This code is much too slow. (My arrays are all about 1e6 or 1e7 in size.)\"</code></p> <p>If your code consists mainly of for-loops without much NumPy, you can add:</p> <p><code>\"Is there anything we can vectorize better with NumPy?\"</code></p> <p>This approach can often transform a naive implementation into a highly optimized one.</p>"},{"location":"get-started/optimization/#implement-unit-tests","title":"Implement unit tests","text":"<p>Instead of testing performance within the full simulation, consider building unit tests. This ensures correctness while optimizing for speed.</p> <ul> <li>Use AI to generate unit tests that validate output against a known correct (but slower) version.</li> <li>Include performance benchmarks in the tests.</li> <li>Ensure large array sizes (e.g., 1 million+ elements) to get meaningful speed comparisons.</li> </ul>"},{"location":"get-started/optimization/#optimize-with-numpy-and-numba","title":"Optimize with NumPy and Numba","text":"<p>After achieving good performance with NumPy, consider trying Numba for further improvements.</p> <p>Even if you\u2019re new to Numba, ChatGPT can generate optimized solutions easily. Keep in mind:</p> <ul> <li>Numba moves back to explicit for-loops (unlike NumPy, which uses vectorization syntax).</li> <li>GPT\u2019s first solution may use <code>range</code> instead of <code>prange</code>. Prompt it with:     <code>\"Can we parallelize this with prange?\"</code></li> <li>If your code involves common counters, atomic operations may become a bottleneck. Ask GPT about:     <code>\"Can we use thread-local storage to avoid atomic operations?\"</code></li> <li>Numba may be slower than NumPy for small arrays (e.g., thousands or tens of thousands of elements). Test with at least 1 million elements.</li> </ul>"},{"location":"get-started/optimization/#c-and-openmp","title":"C and OpenMP","text":"<p>If the best Numba solution still isn\u2019t fast enough, consider compiled C.</p> <ul> <li>Use ctypes to call C functions from Python.</li> <li>Mention \u201cuse OpenMP\u201d in AI prompts if parallelization is possible.</li> <li>Ask: <code>\"Can you generate an OpenMP solution with the best pragmas?\"</code></li> <li>The more CPU cores available, the greater the potential speedup. That said, it\u2019s usually a case of diminishing returns as one goes from 8 cores to 16 and to 32. Our research shows that often you\u2019re better off running 4 sims across 8 cores each than running 1 sim on all 32 cores available. Also be aware that with both Numba and OpenMP you can constrain the number of cores used to less than the number available by setting the appropriate environment variable. (Numba environment variable = NUMBA_NUM_THREADS; OpenMP environment variable = OMP_NUM_THREADS)</li> </ul>"},{"location":"get-started/optimization/#additional-advice","title":"Additional advice","text":"<ul> <li> <p>Don\u2019t duplicate. Sometimes reporting will duplicate transmission code and need to be combined.</p> </li> <li> <p>Never append. There may be cases where you are collecting information as it happens without knowing ahead of time how many rows/entries/elements you\u2019ll need. This is easy in Python using list appending, for example, but that\u2019s a performance killer. Really try to find a way to figure out ahead of time how many entries there will be, and then allocate memory for that, and insert into the existing row.</p> </li> <li> <p>Some components have long timescales, like mortality. By default you are probably going to end up doing most component steps every timestep. You can probably get away with doing mortality updates, for example, far less often. You can experiment with weekly, fortnightly or monthly updates, depending on the timescale of the component you\u2019re optimizing. Just be sure to move everything forward by a week if you\u2019re only doing the update every week. And expect \u201cblocky\u201d plots. Note that there are fancier solutions like \u2018strided sharding\u2019 (details omitted).</p> </li> <li> <p>When prompting AI, use questions rather than directives. For example:</p> <p><code>\"Do you think it might be better to...?\"</code></p> <p>This prevents oversteering the AI into sub-optimal solutions.</p> </li> </ul>"},{"location":"get-started/optimization/#glossary","title":"Glossary","text":""},{"location":"includes/glossary/","title":"Glossary","text":""},{"location":"includes/glossary/#glossary_1","title":"Glossary","text":""},{"location":"reference/SUMMARY/","title":"API reference","text":"<ul> <li>laser.core</li> <li>laser.core.main</li> <li>laser.core.cli</li> <li>laser.core.demographics<ul> <li>laser.core.demographics.kmestimator</li> <li>laser.core.demographics.pyramid</li> <li>laser.core.demographics.spatialpops</li> </ul> </li> <li>laser.core.distributions</li> <li>laser.core.extension</li> <li>laser.core.laserframe</li> <li>laser.core.migration</li> <li>laser.core.propertyset</li> <li>laser.core.random</li> <li>laser.core.sortedqueue</li> <li>laser.core.utils</li> <li>laser.generic</li> <li>laser.generic.main</li> <li>laser.generic.births</li> <li>laser.generic.cli</li> <li>laser.generic.core</li> <li>laser.generic.exposure</li> <li>laser.generic.immunization</li> <li>laser.generic.importation</li> <li>laser.generic.infection</li> <li>laser.generic.model</li> <li>laser.generic.models<ul> <li>laser.generic.models.SEIR</li> <li>laser.generic.models.SEIRS</li> <li>laser.generic.models.SI</li> <li>laser.generic.models.SIR</li> <li>laser.generic.models.SIRS</li> <li>laser.generic.models.SIS</li> <li>laser.generic.models.components</li> <li>laser.generic.models.model</li> <li>laser.generic.models.shared</li> </ul> </li> <li>laser.generic.newutils</li> <li>laser.generic.susceptibility</li> <li>laser.generic.transmission</li> <li>laser.generic.utils</li> </ul>"},{"location":"reference/SUMMARY/#glossary","title":"Glossary","text":""},{"location":"reference/laser/","title":"laser","text":"<p>Root namespace for LASER packages.</p>"},{"location":"reference/laser/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/","title":"laser.core","text":""},{"location":"reference/laser/core/#laser.core","title":"<code>laser.core</code>","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame","title":"<code>laser.core.LaserFrame(capacity, initial_count=-1, **kwargs)</code>","text":"<p>The LaserFrame class, similar to a db table or a Pandas DataFrame, holds dynamically allocated data for agents (generally 1-D or scalar) or for nodes|patches (e.g., 1-D for scalar value per patch or 2-D for time-varying per patch).</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame--glossary","title":"Glossary","text":"<p>Initialize a LaserFrame object.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum capacity of the frame.             Must be a positive integer.</p> required <code>initial_count</code> <code>int</code> <p>The initial number of active elements in the frame.                  Must be a positive integer &lt;= capacity.</p> <code>-1</code> <code>**kwargs</code> <p>Additional keyword arguments to set as attributes of the object.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If capacity or initial_count is not a positive integer,         or if initial_count is greater than capacity.</p> <p>Returns:</p> Type Description <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.capacity","title":"<code>laser.core.LaserFrame.capacity</code>  <code>property</code>","text":"<p>Returns the capacity of the laser frame (total possible entries for dynamic properties).</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.capacity--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The capacity of the laser frame.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.count","title":"<code>laser.core.LaserFrame.count</code>  <code>property</code>","text":"<p>Returns the current count (equivalent to len()).</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.count--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current count value.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.count--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add","title":"<code>laser.core.LaserFrame.add(count)</code>","text":"<p>Adds the specified count to the current count of the LaserFrame.</p> <p>This method increments the internal count by the given count, ensuring that the total does not exceed the frame's capacity. If the addition would exceed the capacity, an assertion error is raised. This method is typically used to add new births during the simulation.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number to add to the current count.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: A tuple containing the [start index, end index) after the addition.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the resulting count exceeds the frame's capacity.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property","title":"<code>laser.core.LaserFrame.add_array_property(name, shape, dtype=np.uint32, default=0)</code>","text":"<p>Adds an array property to the object.</p> <p>This method initializes a new property with the given name as a multi-dimensional NumPy array.</p> <p>The array will have the given shape (note that there is no implied dimension of size self._capacity), datatype (default is np.uint32), and default value (default is 0).</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>shape</code> <code>tuple</code> <p>The shape of the array.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_scalar_property","title":"<code>laser.core.LaserFrame.add_scalar_property(name, dtype=np.uint32, default=0)</code>","text":"<p>Add a scalar property to the class.</p> <p>This method initializes a new scalar property for the class instance. The property is stored as a 1-D NumPy array (scalar / entry) with a specified data type and default value.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the scalar property to be added.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data type for the property. Default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value for the property. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property","title":"<code>laser.core.LaserFrame.add_vector_property(name, length, dtype=np.uint32, default=0)</code>","text":"<p>Adds a vector property to the object.</p> <p>This method initializes a new property with the given name as a 2-D NumPy array (vector per entry).</p> <p>The array will have a shape of (length, self._capacity) and will be filled with the specified default value. The data type of the array elements is determined by the <code>dtype</code> parameter.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>length</code> <code>int</code> <p>The length of the vector.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.describe","title":"<code>laser.core.LaserFrame.describe(target=None)</code>","text":"<p>Return a formatted string description of the laserframe object, including its attributes and their values.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.describe--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>target</code> <p>Optional string for the report header (generally the name of the LaserFrame variable, e.g., \"People\". Unlike functions, we can't get the name of a variable automatically).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string describing the laserframe object, including its capacity, count, and  details of its scalar, vector, and other properties.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.describe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.describe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot","title":"<code>laser.core.LaserFrame.load_snapshot(path, n_ppl, cbr, nt)</code>  <code>classmethod</code>","text":"<p>Load a LaserFrame and optional extras from an HDF5 snapshot file.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the HDF5 snapshot file.</p> required <code>n_ppl</code> <code>float or array - like</code> <p>Original total population (or per-node array) used to estimate births.</p> required <code>cbr</code> <code>float or array - like</code> <p>Crude birth rate (per 1000/year).</p> required <code>nt</code> <code>int</code> <p>Simulation duration (number of ticks).</p> required <p>Returns:</p> Type Description <p>frame (LaserFrame)</p> <p>results_r (np.ndarray or None)</p> <p>pars (dict or None)</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.save_snapshot","title":"<code>laser.core.LaserFrame.save_snapshot(path, results_r=None, pars=None)</code>","text":"<p>Save this LaserFrame and optional extras to an HDF5 snapshot file.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.save_snapshot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <p>Destination file path</p> required <code>results_r</code> <p>Optional 2D numpy array of recovered counts</p> <code>None</code> <code>pars</code> <p>Optional PropertySet or dict of parameters</p> <code>None</code>"},{"location":"reference/laser/core/#laser.core.LaserFrame.save_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.save_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.save_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.sort","title":"<code>laser.core.LaserFrame.sort(indices, verbose=False)</code>","text":"<p>Sorts the elements of the object's numpy arrays based on the provided indices.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.sort--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>An array of indices used to sort the numpy arrays. Must be of integer type and have the same length as the frame count (<code>self._count</code>).</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the sorting progress for each numpy array attribute. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not an integer array or if its length does not match the frame count of active elements.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.sort--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.sort--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.sort--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.squash","title":"<code>laser.core.LaserFrame.squash(indices, verbose=False)</code>","text":"<p>Reduces the active count of the internal numpy arrays keeping only elements True in the provided boolean indices.</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.squash--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>A boolean array indicating which elements to keep. Must have the same length as the current frame active element count.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints detailed information about the squashing process. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not a boolean array or if its length does not match the current frame active element count.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/#laser.core.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet","title":"<code>laser.core.PropertySet(*bags)</code>","text":"<p>A class that can be used to store properties in a dictionary-like object with <code>.property</code> access to properties.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet--examples","title":"Examples","text":"<p>Basic Initialization:     &gt;&gt;&gt; from laser.core import PropertySet     &gt;&gt;&gt; ps = PropertySet()     &gt;&gt;&gt; ps['infection_status'] = 'infected'     &gt;&gt;&gt; ps['age'] = 35     &gt;&gt;&gt; print(ps.infection_status)  # Outputs: 'infected'     &gt;&gt;&gt; print(ps['age'])            # Outputs: 35     <pre><code>Combining two PropertySets:\n</code></pre>     &gt;&gt;&gt; ps1 = PropertySet({'immunity': 'high', 'region': 'north'})     &gt;&gt;&gt; ps2 = PropertySet({'infectivity': 0.7})     &gt;&gt;&gt; combined_ps = ps1 + ps2     &gt;&gt;&gt; print(combined_ps.to_dict())     {'immunity': 'high', 'region': 'north', 'infectivity': 0.7}     <pre><code>Creating a PropertySet from a dictionary:\n</code></pre>     &gt;&gt;&gt; ps = PropertySet({'mything': 0.4, 'that_other_thing': 42})     &gt;&gt;&gt; print(ps.mything)            # Outputs: 0.4     &gt;&gt;&gt; print(ps.that_other_thing)   # Outputs: 42     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42}     <pre><code>Save and load:\n</code></pre>     &gt;&gt;&gt; ps.save('properties.json')     &gt;&gt;&gt; loaded_ps = PropertySet.load('properties.json')     &gt;&gt;&gt; print(loaded_ps.to_dict())  # Outputs the saved properties     <pre><code>Property access and length:\n</code></pre>     &gt;&gt;&gt; ps['status'] = 'susceptible'     &gt;&gt;&gt; ps['exposure_timer'] = 5     &gt;&gt;&gt; print(ps['status'])          # Outputs: 'susceptible'     &gt;&gt;&gt; print(len(ps))               # Outputs: 4     <pre><code>In-Place addition (added keys must *not* exist in the destination PropertySet):\n</code></pre>     &gt;&gt;&gt; ps += {'new_timer': 10, 'susceptibility': 0.75}     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 5, 'new_timer': 10, 'susceptibility': 0.75}     <pre><code>In-place update (keys *must* already exist in the destination PropertySet):\n</code></pre>     &gt;&gt;&gt; ps &lt;&lt;= {'exposure_timer': 10, 'infectivity': 0.8}     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 10, 'infectivity': 0.8}     <pre><code>In-place addition or update (no restriction on incoming keys):\n</code></pre>     &gt;&gt;&gt; ps |= {'new_timer': 10, 'exposure_timer': 8}     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 8, 'new_timer': 10}     ```</p>"},{"location":"reference/laser/core/#laser.core.PropertySet--glossary","title":"Glossary","text":"<p>Initialize a PropertySet to manage properties in a dictionary-like structure.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>*bags </code> <p>iterable, optional A sequence of key-value pairs (e.g., lists, tuples, dictionaries) to initialize the PropertySet. Keys must be strings, and values can be any type.</p> required"},{"location":"reference/laser/core/#laser.core.PropertySet--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__add__","title":"<code>laser.core.PropertySet.__add__(other)</code>","text":"<p>Add another PropertySet to this PropertySet.</p> <p>This method allows the use of the <code>+</code> operator to combine two PropertySet instances.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__add__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to add.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <p>A new PropertySet instance that combines the properties of both instances.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__add__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__add__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__contains__","title":"<code>laser.core.PropertySet.__contains__(key)</code>","text":"<p>Check if a key is in the property set.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__contains__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check for existence in the property set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the key exists in the property set, False otherwise.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__contains__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__contains__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__eq__","title":"<code>laser.core.PropertySet.__eq__(other)</code>","text":"<p>Check if two PropertySet instances are equal.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__eq__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the two instances are equal, False otherwise.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__eq__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__eq__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__getitem__","title":"<code>laser.core.PropertySet.__getitem__(key)</code>","text":"<p>Retrieve the attribute of the object with the given key (e.g., <code>ps[key]</code>).</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__getitem__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The value of the attribute with the specified key.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute with the specified key does not exist.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__getitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__getitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__getitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__iadd__","title":"<code>laser.core.PropertySet.__iadd__(other)</code>","text":"<p>Implements the in-place addition (<code>+=</code>) operator for the class.</p> <p>This method allows the instance to be updated with attributes from another instance of the same class or from a dictionary. If <code>other</code> is an instance of the same class, its attributes are copied to the current instance. If <code>other</code> is a dictionary, its key-value pairs are added as attributes to the current instance.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__iadd__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary to add to the current instance.</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The updated instance with the new attributes.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys already present in the PropertySet.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__ilshift__","title":"<code>laser.core.PropertySet.__ilshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;=</code> operator on PropertySet to override existing values with new values.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__ilshift__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The updated instance with the overrides from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__ior__","title":"<code>laser.core.PropertySet.__ior__(other)</code>","text":"<p>Implements the <code>|=</code> operator on PropertySet to override existing values with new values.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__ior__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The updated instance with all the values of self with new or overriding values from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__ior__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__ior__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__ior__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__len__","title":"<code>laser.core.PropertySet.__len__()</code>","text":"<p>Return the number of attributes in the instance.</p> <p>This method returns the number of attributes stored in the instance's dict attribute, which represents the instance's namespace.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__len__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <p>The number of attributes in the instance.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__len__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__lshift__","title":"<code>laser.core.PropertySet.__lshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;</code> operator on PropertySet to override existing values with new values.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__lshift__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Type Description <p>A new PropertySet with all the values of the first PropertySet with overrides from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__or__","title":"<code>laser.core.PropertySet.__or__(other)</code>","text":"<p>Implements the <code>|</code> operator on PropertySet to add new or override existing values with new values.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__or__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Type Description <p>A new PropertySet with all the values of the first PropertySet with new or overriding values from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__or__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__or__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__or__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__repr__","title":"<code>laser.core.PropertySet.__repr__()</code>","text":"<p>Return a string representation of the PropertySet instance.</p> <p>The string representation includes the class name and the dictionary of the instance's attributes.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__repr__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PropertySet instance.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__repr__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__setitem__","title":"<code>laser.core.PropertySet.__setitem__(key, value)</code>","text":"<p>Set the value of an attribute. This method allows setting an attribute of the instance using the dictionary-like syntax (e.g., <code>ps[key] = value</code>).</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__setitem__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to set.</p> required <code>value</code> <code>any</code> <p>The value to set for the attribute.</p> required <p>Returns:</p> Type Description <p>None</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__setitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__setitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__setitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.__str__","title":"<code>laser.core.PropertySet.__str__()</code>","text":"<p>Returns a string representation of the object's dictionary.</p> <p>This method is used to provide a human-readable string representation of the object, which includes all the attributes stored in the object's <code>__dict__</code>.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__str__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the object's dictionary.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.__str__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.load","title":"<code>laser.core.PropertySet.load(filename)</code>  <code>staticmethod</code>","text":"<p>Load a PropertySet from a specified file.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.load--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet is saved.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <p>The PropertySet instance loaded from the file.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.load--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.load--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.save","title":"<code>laser.core.PropertySet.save(filename)</code>","text":"<p>Save the PropertySet to a specified file.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.save--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet will be saved.</p> required <p>Returns:</p> Type Description <p>None</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.save--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.save--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.PropertySet.to_dict","title":"<code>laser.core.PropertySet.to_dict()</code>","text":"<p>Convert the PropertySet to a dictionary.</p>"},{"location":"reference/laser/core/#laser.core.PropertySet.to_dict--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue","title":"<code>laser.core.SortedQueue(capacity, values)</code>","text":"<p>A sorted (priority) queue implemented using NumPy arrays and sped-up with Numba.</p> <p>Using the algorithm from the Python heapq module.</p> <p>init with an existing array of sorting values</p> <p>push with an index into sorting values</p> <p>pop returns the index of the lowest sorting value and its value</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue--glossary","title":"Glossary","text":"<p>Initializes a new instance of the class with a specified capacity and reference to existing, sortable values.</p> <p>This implementation is specific to LASER and the expectation of tracking 10s or 100s of millions of agents.</p> <p>We expect the sortable (or priority) values to already be in a NumPy array, usually a property of a LaserFrame object.</p> <p>The <code>push()</code> and <code>pop()</code> will take indices into this array and will sort on values[i]. This avoids making copies of the sort values.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum number of elements the queue can hold.</p> required <code>values</code> <code>ndarray</code> <p>A reference to an array of values to be accessed by the queue.</p> required"},{"location":"reference/laser/core/#laser.core.SortedQueue--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.__len__","title":"<code>laser.core.SortedQueue.__len__()</code>","text":"<p>Return the number of elements in the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.__len__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.__len__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.__pop","title":"<code>laser.core.SortedQueue.__pop()</code>","text":"<p>Removes the smallest value element from the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.__pop--glossary","title":"Glossary","text":"<p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Side effects</p> <ul> <li>Decreases the size of the sorted queue by one.</li> <li>Reorganizes the internal structure of the sorted queue to maintain the heap property.</li> </ul>"},{"location":"reference/laser/core/#laser.core.SortedQueue.__pop--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.__pop--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.__pop--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.peeki","title":"<code>laser.core.SortedQueue.peeki()</code>","text":"<p>Returns the index of the smallest value element in the sorted queue without removing it.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peeki--glossary","title":"Glossary","text":"<p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peeki--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.peeki--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.peekiv","title":"<code>laser.core.SortedQueue.peekiv()</code>","text":"<p>Returns the index and value of the smallest value element in the sorted queue without removing it.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peekiv--glossary","title":"Glossary","text":"<p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peekiv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.peekiv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.peekv","title":"<code>laser.core.SortedQueue.peekv()</code>","text":"<p>Return the smallest value from the sorted queue without removing it.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peekv--glossary","title":"Glossary","text":"<p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value with the smallest value in the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.peekv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.peekv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.popi","title":"<code>laser.core.SortedQueue.popi()</code>","text":"<p>Removes and returns the index of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index of the smallest value element using <code>peeki()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popi--glossary","title":"Glossary","text":"<p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element in the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popi--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.popiv","title":"<code>laser.core.SortedQueue.popiv()</code>","text":"<p>Removes and returns the index and value of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index and value of the smallest value element using <code>peekiv()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index and value.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popiv--glossary","title":"Glossary","text":"<p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popiv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.popv","title":"<code>laser.core.SortedQueue.popv()</code>","text":"<p>Removes and returns the value at the front of the sorted queue.</p> <p>This method first retrieves the value at the front of the queue without removing it by calling <code>peekv()</code>, and then removes the front element from the queue by calling <code>pop()</code>. The retrieved value is then returned.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popv--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value at the front of the sorted queue.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.popv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.push","title":"<code>laser.core.SortedQueue.push(index)</code>","text":"<p>Insert an element into the sorted queue.</p> <p>This method adds an element at the back of the sorted queue and then ensures the heap property is maintained by sifting the element forward to its correct position.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.push--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the element to be added to the sorted queue.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is full.</p>"},{"location":"reference/laser/core/#laser.core.SortedQueue.push--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#laser.core.SortedQueue.push--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/__main__/","title":"laser.core.main","text":""},{"location":"reference/laser/core/__main__/#laser.core.__main__","title":"<code>laser.core.__main__</code>","text":"<p>Entrypoint module, in case you use <code>python -midmlaser</code>.</p> <p>Why does this file exist, and why main? For more info, read:</p> <ul> <li>https://www.python.org/dev/peps/pep-0338/</li> <li>https://docs.python.org/2/using/cmdline.html#cmdoption-m</li> <li>https://docs.python.org/3/using/cmdline.html#cmdoption-m</li> </ul>"},{"location":"reference/laser/core/__main__/#laser.core.__main__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/__main__/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/cli/","title":"laser.core.cli","text":""},{"location":"reference/laser/core/cli/#laser.core.cli","title":"<code>laser.core.cli</code>","text":"<p>Module that contains the command line app.</p> <p>Why does this file exist, and why not put this in main?</p> <p>You might be tempted to import things from main later, but that will cause   problems: the code will get executed twice:</p> <ul> <li>When you run <code>python -midmlaser</code> python will execute     <code>__main__.py</code> as a script. That means there will not be any     <code>idmlaser.__main__</code> in <code>sys.modules</code>.</li> <li>When you import main it will get executed again (as a module) because     there\"s no <code>idmlaser.__main__</code> in <code>sys.modules</code>.</li> </ul> <p>Also see (1) from https://click.palletsprojects.com/en/stable/setuptools/</p>"},{"location":"reference/laser/core/cli/#laser.core.cli--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/cli/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/","title":"laser.core.demographics","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics","title":"<code>laser.core.demographics</code>","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution","title":"<code>laser.core.demographics.AliasedDistribution(counts)</code>","text":"<p>A class to generate samples from a distribution using the Vose alias method.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution.sample","title":"<code>laser.core.demographics.AliasedDistribution.sample(count=1, dtype=np.int32)</code>","text":"<p>Generate samples from the distribution.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution.sample--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of samples to generate. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>int</code> <p>int or numpy.ndarray: A single integer if count is 1, otherwise an array of integers representing the generated samples.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.AliasedDistribution.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator","title":"<code>laser.core.demographics.KaplanMeierEstimator(source)</code>","text":"<p>Initializes the KMEstimator with the given source data.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>source </code> <p>Union[np.ndarray, list, Path, str]</p> <p>The source data for the KMEstimator. It can be:</p> <ul> <li>A numpy array of unsigned 32-bit integers.</li> <li>A list of integers.</li> <li>A Path object pointing to a file containing the data.</li> <li>A string representing the file path.</li> </ul> required <p>Notes</p> <ul> <li>If the source is a file path, the file should contain comma-separated values with the data in the second column.</li> <li>The source data is converted to a numpy array of unsigned 32-bit integers.</li> </ul>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.cumulative_deaths","title":"<code>laser.core.demographics.KaplanMeierEstimator.cumulative_deaths</code>  <code>property</code>","text":"<p>Returns the original source data.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.cumulative_deaths--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death","title":"<code>laser.core.demographics.KaplanMeierEstimator.predict_age_at_death(ages_days, max_year=None)</code>","text":"<p>Calculate the predicted age at death (in days) based on the given ages in days.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>ages_days</code> <code>ndarray</code> <p>The ages of the individuals in days.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>age_at_death</code> <code>ndarray</code> <p>The predicted days of death.</p> <p>Example</p> <pre><code>predict_age_at_death(np.array([40*365, 50*365, 60*365]), max_year=80) # returns something like array([22732, 26297, 29862])\n</code></pre>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death","title":"<code>laser.core.demographics.KaplanMeierEstimator.predict_year_of_death(ages_years, max_year=None)</code>","text":"<p>Calculate the predicted year of death based on the given ages in years.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>ages_years</code> <code>ndarray</code> <p>The ages of the individuals in years.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>year_of_death</code> <code>ndarray</code> <p>The predicted years of death.</p> <p>Example</p> <pre><code>predict_year_of_death(np.array([40, 50, 60]), max_year=80) # returns something like array([62, 72, 82])\n</code></pre>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.sample","title":"<code>laser.core.demographics.KaplanMeierEstimator.sample(current, max_index=None)</code>","text":"<p>Similar to <code>predict_year_of_death</code>, but operates on indices rather than years. This method predicts the expiration (death) index for each individual, given their current index.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>current</code> <code>ndarray</code> <p>The current indices of the individuals.</p> required <code>max_index</code> <code>int</code> <p>The maximum index to consider for calculating the predicted expiration. Default is None, which uses the maximum index from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>predictions</code> <code>ndarray</code> <p>The predicted expiration indices for each individual.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.load_pyramid_csv","title":"<code>laser.core.demographics.load_pyramid_csv(file, verbose=False)</code>","text":"<p>Load a CSV file with population pyramid data and return it as a NumPy array.</p> <p>The CSV file is expected to have the following schema:</p> <ul> <li>The first line is a header: \"Age,M,F\"</li> <li>Subsequent lines contain age ranges and population counts for males and females:</li> </ul> <p><pre><code>\"low-high,#males,#females\"\n...\n\"max+,#males,#females\"\n</code></pre> Where low, high, males, females, and max are integer values &gt;= 0.</p> <p>The function processes the CSV file to create a NumPy array with the following columns:</p> <ul> <li>Start age of the range</li> <li>End age of the range</li> <li>Number of males</li> <li>Number of females</li> </ul>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.load_pyramid_csv--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the file reading status. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A NumPy array with the processed population pyramid data.</p>"},{"location":"reference/laser/core/demographics/#laser.core.demographics.load_pyramid_csv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.load_pyramid_csv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#laser.core.demographics.load_pyramid_csv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/","title":"laser.core.demographics.kmestimator","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator","title":"<code>laser.core.demographics.kmestimator</code>","text":"<p>This module provides the KaplanMeierEstimator class for predicting the year and age at death based on given ages and cumulative death data.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator--glossary","title":"Glossary","text":"<p>Classes:</p> Name Description <code>- KaplanMeierEstimator</code> <p>A class to perform Kaplan-Meier estimation for predicting the year and age at death.</p> <p>Functions:</p> Name Description <code>- _pyod</code> <p>np.ndarray, cumulative_deaths: np.ndarray, max_year: np.uint32 = 100): Calculate the predicted year of death based on the given ages in years.</p> <code>- _pdod</code> <p>np.ndarray, year_of_death: np.ndarray, day_of_death: np.ndarray): Calculate the predicted day of death based on the given ages in days and predicted years of death.</p> <p>Usage example</p> <pre><code>estimator = KaplanMeierEstimator(cumulative_deaths=np.array([...]))\nyear_of_death = estimator.predict_year_of_death(np.array([40, 50, 60]), max_year=80)\nage_at_death = estimator.predict_age_at_death(np.array([40*365, 50*365, 60*365]), max_year=80)\n</code></pre>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator(source)</code>","text":"<p>Initializes the KMEstimator with the given source data.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>source </code> <p>Union[np.ndarray, list, Path, str]</p> <p>The source data for the KMEstimator. It can be:</p> <ul> <li>A numpy array of unsigned 32-bit integers.</li> <li>A list of integers.</li> <li>A Path object pointing to a file containing the data.</li> <li>A string representing the file path.</li> </ul> required <p>Notes</p> <ul> <li>If the source is a file path, the file should contain comma-separated values with the data in the second column.</li> <li>The source data is converted to a numpy array of unsigned 32-bit integers.</li> </ul>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.cumulative_deaths","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.cumulative_deaths</code>  <code>property</code>","text":"<p>Returns the original source data.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.cumulative_deaths--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death(ages_days, max_year=None)</code>","text":"<p>Calculate the predicted age at death (in days) based on the given ages in days.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>ages_days</code> <code>ndarray</code> <p>The ages of the individuals in days.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>age_at_death</code> <code>ndarray</code> <p>The predicted days of death.</p> <p>Example</p> <pre><code>predict_age_at_death(np.array([40*365, 50*365, 60*365]), max_year=80) # returns something like array([22732, 26297, 29862])\n</code></pre>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_age_at_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death(ages_years, max_year=None)</code>","text":"<p>Calculate the predicted year of death based on the given ages in years.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>ages_years</code> <code>ndarray</code> <p>The ages of the individuals in years.</p> required <code>max_year</code> <code>int</code> <p>The maximum year to consider for calculating the predicted year of death. Default is None, which uses the maximum year from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>year_of_death</code> <code>ndarray</code> <p>The predicted years of death.</p> <p>Example</p> <pre><code>predict_year_of_death(np.array([40, 50, 60]), max_year=80) # returns something like array([62, 72, 82])\n</code></pre>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.predict_year_of_death--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.sample","title":"<code>laser.core.demographics.kmestimator.KaplanMeierEstimator.sample(current, max_index=None)</code>","text":"<p>Similar to <code>predict_year_of_death</code>, but operates on indices rather than years. This method predicts the expiration (death) index for each individual, given their current index.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>current</code> <code>ndarray</code> <p>The current indices of the individuals.</p> required <code>max_index</code> <code>int</code> <p>The maximum index to consider for calculating the predicted expiration. Default is None, which uses the maximum index from the source data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>predictions</code> <code>ndarray</code> <p>The predicted expiration indices for each individual.</p>"},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#laser.core.demographics.kmestimator.KaplanMeierEstimator.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/kmestimator/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/","title":"laser.core.demographics.pyramid","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid","title":"<code>laser.core.demographics.pyramid</code>","text":"<p>A class for generating samples from a distribution using the Vose alias method.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution","title":"<code>laser.core.demographics.pyramid.AliasedDistribution(counts)</code>","text":"<p>A class to generate samples from a distribution using the Vose alias method.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution.sample","title":"<code>laser.core.demographics.pyramid.AliasedDistribution.sample(count=1, dtype=np.int32)</code>","text":"<p>Generate samples from the distribution.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution.sample--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of samples to generate. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>int</code> <p>int or numpy.ndarray: A single integer if count is 1, otherwise an array of integers representing the generated samples.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.AliasedDistribution.sample--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.load_pyramid_csv","title":"<code>laser.core.demographics.pyramid.load_pyramid_csv(file, verbose=False)</code>","text":"<p>Load a CSV file with population pyramid data and return it as a NumPy array.</p> <p>The CSV file is expected to have the following schema:</p> <ul> <li>The first line is a header: \"Age,M,F\"</li> <li>Subsequent lines contain age ranges and population counts for males and females:</li> </ul> <p><pre><code>\"low-high,#males,#females\"\n...\n\"max+,#males,#females\"\n</code></pre> Where low, high, males, females, and max are integer values &gt;= 0.</p> <p>The function processes the CSV file to create a NumPy array with the following columns:</p> <ul> <li>Start age of the range</li> <li>End age of the range</li> <li>Number of males</li> <li>Number of females</li> </ul>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.load_pyramid_csv--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The path to the CSV file.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the file reading status. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A NumPy array with the processed population pyramid data.</p>"},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.load_pyramid_csv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.load_pyramid_csv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/#laser.core.demographics.pyramid.load_pyramid_csv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/pyramid/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/","title":"laser.core.demographics.spatialpops","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops","title":"<code>laser.core.demographics.spatialpops</code>","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed","title":"<code>laser.core.demographics.spatialpops.distribute_population_skewed(tot_pop, num_nodes, frac_rural=0.3)</code>","text":"<p>Calculate the population distribution across a number of nodes based on a total population, the number of nodes, and the fraction of the population assigned to rural nodes.</p> <p>The function generates a list of node populations distributed according to a simple exponential random distribution, with adjustments to ensure the sum matches the total population and the specified fraction of rural population is respected.</p>"},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tot_pop</code> <code>int</code> <p>The total population to be distributed across the nodes.</p> required <code>num_nodes</code> <code>int</code> <p>The total number of nodes among which the population will be distributed.</p> required <code>frac_rural</code> <code>float</code> <p>The fraction of the total population to be assigned to rural nodes (value between 0 and 1). Defaults to 0.3. The 0 node is the single urban node and has (1-frac_rural) of the population.</p> <code>0.3</code> <p>Returns:</p> Type Description <p>list of int A list of integers representing the population at each node. The sum of the list equals <code>tot_pop</code>.</p> <p>Notes</p> <ul> <li>The population distribution is weighted using an exponential random distribution to create heterogeneity among node populations.</li> <li>Adjustments are made to ensure the total fraction assigned to rural nodes adheres to <code>frac_rural</code>.</li> </ul>"},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--examples","title":"Examples","text":"<p>from laser.core.demographics.spatialpops import distribute_population_skewed np.random.seed(42)  # For reproducibility tot_pop = 1000 num_nodes = 5 frac_rural = 0.3 distribute_population_skewed(tot_pop, num_nodes, frac_rural) [700, 154, 64, 54, 28]</p> <p>tot_pop = 500 num_nodes = 3 frac_rural = 0.4 distribute_population_skewed(tot_pop, num_nodes, frac_rural) [300, 136, 64] ```</p>"},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_skewed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered","title":"<code>laser.core.demographics.spatialpops.distribute_population_tapered(tot_pop, num_nodes)</code>","text":"<p>Distribute a total population heterogeneously across a given number of nodes.</p> <p>The distribution follows a logarithmic-like decay pattern where the first node (Node 0) receives the largest share of the population, approximately half the total population. Subsequent nodes receive progressively smaller populations, ensuring that even the smallest node has a non-negligible share.</p> <p>The function ensures the sum of the distributed populations matches the <code>tot_pop</code> exactly by adjusting the largest node if rounding introduces discrepancies.</p>"},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tot_pop</code> <code>int</code> <p>The total population to distribute. Must be a positive integer.</p> required <code>num_nodes</code> <code>int</code> <p>The number of nodes to distribute the population across. Must be a positive integer.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: A 1D array of integers where each element represents the population assigned to a specific node. The length of the array is equal to <code>num_nodes</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>tot_pop</code> or <code>num_nodes</code> is not greater than 0.</p> <p>Notes</p> <ul> <li>The logarithmic-like distribution ensures that Node 0 has the highest population, and subsequent nodes receive progressively smaller proportions.</li> <li>The function guarantees that the sum of the returned array equals <code>tot_pop</code>.</li> </ul> <p>Examples:</p> <p>Distribute a total population of 1000 across 5 nodes:     <pre><code>&gt;&gt;&gt; from laser.core.demographics.spatialpops import distribute_population_tapered\n&gt;&gt;&gt; distribute_population_tapered(1000, 5)\narray([500, 250, 125, 75, 50])\n</code></pre> Distribute a total population of 1200 across 3 nodes:     <pre><code>&gt;&gt;&gt; distribute_population_tapered(1200, 3)\narray([600, 400, 200])\n</code></pre> Handling a small total population with more nodes:     <pre><code>&gt;&gt;&gt; distribute_population_tapered(10, 4)\narray([5, 3, 2, 0])\n</code></pre> Ensuring the distribution adds up to the total population:     <pre><code>&gt;&gt;&gt; pop = distribute_population_tapered(1000, 5)\n&gt;&gt;&gt; pop.sum()\n1000\n</code></pre></p>"},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#laser.core.demographics.spatialpops.distribute_population_tapered--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/demographics/spatialpops/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/","title":"laser.core.distributions","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions","title":"<code>laser.core.distributions</code>","text":"<p>Various probability distributions implemented using NumPy and Numba.</p> <p>LASER based models generally move from pure NumPy to Numba-accelerated version of the core dynamics, e.g., transmission.</p> <p>It would be a hassle to re-implement these functions for each desired distribution, so we provide these Numba-wrapped distributions here which can be passed in to other Numba compiled functions.</p> <p>For example, a simple SIR model may want to parameterize the infectious period using a distribution. By passing in a Numba-wrapped distribution function, we can pick and parameterize a distribution based on configuration and sample from that distribution within the Numba-compiled SIR model without needing to re-implement the distribution logic within the SIR model itself.</p> <p>A simple example of usage::</p> <pre><code>import laser.core.distributions as dist\n\n# Create a Numba-wrapped beta distribution\nbeta_dist = dist.beta(2.0, 5.0)\n\n# Assign the distribution to the model's infectious period distribution\n# so the transmission component can sample from it during simulation\nmodel.infectious_period_dist = beta_dist\n</code></pre> <p>Note that the distribution functions take two parameters, <code>tick</code> and <code>node</code>, which are currently unused but match the desired signature for disease model components that may need to sample from distributions based on the current simulation tick or node index. I.e., distributions with spatial or temporal variation could be implemented in the future.</p> <p>Here are examples of Numba-wrapped distribution functions that could vary based on tick and tick + node::</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions--temporal-variation-only","title":"temporal variation only","text":"<p>cosine = np.cos(np.linspace(0, np.pi * 2, 365))</p> <p>@nb.njit(nogil=True, cache=True) def seasonal_distribution(tick: int, node: int) -&gt; np.float32:     # ignore node for this seasonal distribution     day_of_year = tick % 365     base_value = 42.0 + 3.14159 * cosine[day_of_year]     # parameterize normal() with seasonal factor     return np.float32(np.random.normal(base_value, 2.0))</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions--additional-spatial-variation","title":"additional spatial variation","text":"<p>ramp = np.linspace(0, 2, 42)</p> <p>@nb.njit(nogil=True, cache=True) def ramped_distribution(tick: int, node: int) -&gt; np.float32:     day_of_year = tick % 365     # use seasonal factor     base_value = 42.0 + 3.14159 * cosine[day_of_year]     # apply spatial ramp based on node index     base_value *= ramp[node]     # parameterize normal() with seasonal + spatial factor     return np.float32(np.random.normal(base_value, 1.0))</p> <p>Normally, these distributions - built in or custom - will be used once per agent as above. However, the <code>sample_ints()</code> and <code>sample_floats()</code> functions can be used to efficiently sample large arrays using multiple CPU cores in parallel.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.beta","title":"<code>laser.core.distributions.beta(a, b)</code>  <code>cached</code>","text":"<p>Beta distribution. \\(\\(f(x; a, b) = \\\\frac {x^{a-1} (1-x)^{b-1}} {B(a, b)}\\)\\) where B(a, b) is the beta function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.beta--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.binomial","title":"<code>laser.core.distributions.binomial(n, p)</code>  <code>cached</code>","text":"<p>Binomial distribution. \\(\\(f(k,n,p) = Pr(X = k) = \\\\binom {n} {k} p^k (1-p)^{n-k}\\)\\) where n is the number of trials and p is the probability of success [0, 1].</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.binomial--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.constant_float","title":"<code>laser.core.distributions.constant_float(value)</code>  <code>cached</code>","text":"<p>Constant distribution. Always returns the same floating point value.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.constant_float--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.constant_int","title":"<code>laser.core.distributions.constant_int(value)</code>  <code>cached</code>","text":"<p>Constant distribution. Always returns the same integer value.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.constant_int--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.exponential","title":"<code>laser.core.distributions.exponential(scale)</code>  <code>cached</code>","text":"<p>Exponential distribution. \\(\\(f(x; \\\\frac {1} {\\\\beta}) = \\\\frac {1} {\\\\beta} e^{-\\\\frac {x} {\\\\beta}}\\)\\) where \u03b2 is the scale parameter (\u03b2 = 1 / \u03bb).</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.exponential--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.gamma","title":"<code>laser.core.distributions.gamma(shape, scale)</code>  <code>cached</code>","text":"<p>Gamma distribution. \\(\\(p(x) = x^{k-1} \\\\frac {e^{- x / \\\\theta}}{\\\\theta^k \\\\Gamma(k)}\\)\\) where k is the shape, \u03b8 is the scale, and \u0393(k) is the gamma function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.gamma--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.logistic","title":"<code>laser.core.distributions.logistic(loc, scale)</code>  <code>cached</code>","text":"<p>Logistic distribution. \\(\\(P(x) = \\\\frac {e^{-(x - \\\\mu) / s}} {s (1 + e^{-(x - \\\\mu) / s})^2}\\)\\) where \u03bc is the location parameter and s is the scale parameter.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.logistic--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.lognormal","title":"<code>laser.core.distributions.lognormal(mean, sigma)</code>  <code>cached</code>","text":"<p>Log-normal distribution. \\(\\(p(x) = \\\\frac {1} {\\\\sigma x \\\\sqrt {2 \\\\pi}} e^{- \\\\frac {(\\ln x - \\\\mu)^2} {2 \\\\sigma^2}}\\)\\) where \u03bc is the mean and \u03c3 is the standard deviation of the underlying normal distribution.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.lognormal--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.negative_binomial","title":"<code>laser.core.distributions.negative_binomial(n, p)</code>  <code>cached</code>","text":"<p>Negative binomial distribution. \\(\\(P(N; n, p) = \\\\frac {\\\\Gamma (N + n)} {N! \\\\Gamma (n)} p^n (1 - p)^N\\)\\) where n is the number of successes, p is the probability of success on each trial, N + n is the number of trials, and \u0393() is the gamma function. When n is an integer, \\(\\(\\\\frac {\\\\Gamma (N + n)} {N! \\\\Gamma (n)} = \\\\binom {N + n - 1} {n - 1}\\)\\) which is the more common form of this term.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.negative_binomial--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.normal","title":"<code>laser.core.distributions.normal(loc, scale)</code>  <code>cached</code>","text":"<p>Normal (Gaussian) distribution. \\(\\(p(x) = \\\\frac {1} {\\\\sqrt {2 \\\\pi \\\\sigma^2}} e^{- \\\\frac {(x - \\\\mu)^2} {2 \\\\sigma^2}}\\)\\) where \u03bc is the mean and \u03c3 is the standard deviation.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.normal--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.poisson","title":"<code>laser.core.distributions.poisson(lam)</code>  <code>cached</code>","text":"<p>Poisson distribution. \\(\\(f( k ; \\\\lambda ) = \\\\frac {\\\\lambda^k e^{- \\\\lambda}} {k!}\\)\\) where \u03bb is the expected number of events in the given interval.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.poisson--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_floats","title":"<code>laser.core.distributions.sample_floats(fn, dest, tick=0, node=0)</code>","text":"<p>Fill an array with floating point values sampled from a Numba-wrapped distribution function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_floats--parameters","title":"Parameters","text":"<p>fn : function     Numba-wrapped distribution function returning float32 values. dest : np.ndarray     Pre-allocated destination float32 array to store samples. tick : int, optional     Current simulation tick (default is 0). Passed through to the distribution function. node : int, optional     Current node index (default is 0). Passed through to the distribution function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_floats--returns","title":"Returns","text":"<p>np.ndarray     The destination array filled with sampled values.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_floats--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_ints","title":"<code>laser.core.distributions.sample_ints(fn, dest, tick=0, node=0)</code>","text":"<p>Fill an array with integer values sampled from a Numba-wrapped distribution function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_ints--parameters","title":"Parameters","text":"<p>fn : function     Numba-wrapped distribution function returning int32 values. dest : np.ndarray     Pre-allocated destination int32 array to store samples. tick : int, optional     Current simulation tick (default is 0). Passed through to the distribution function. node : int, optional     Current node index (default is 0). Passed through to the distribution function.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_ints--returns","title":"Returns","text":"<p>np.ndarray     The destination array filled with sampled values.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.sample_ints--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.uniform","title":"<code>laser.core.distributions.uniform(low, high)</code>  <code>cached</code>","text":"<p>Uniform distribution. \\(\\(p(x) = \\\\frac {1} {b - a}\\)\\) where a is the lower bound and b is the upper bound, [a, b).</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.uniform--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#laser.core.distributions.weibull","title":"<code>laser.core.distributions.weibull(a, lam)</code>  <code>cached</code>","text":"<p>Weibull distribution. \\(\\(X = \\\\lambda (- \\\\ln ( U ))^{1 / a}\\)\\) where a is the shape parameter and \u03bb is the scale parameter.</p>"},{"location":"reference/laser/core/distributions/#laser.core.distributions.weibull--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/distributions/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/extension/","title":"laser.core.extension","text":""},{"location":"reference/laser/core/extension/#laser.core.extension","title":"<code>laser.core.extension</code>","text":""},{"location":"reference/laser/core/extension/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/","title":"laser.core.laserframe","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe","title":"<code>laser.core.laserframe</code>","text":"<p>laserframe.py</p> <p>This module defines the LaserFrame class, which is used to manage dynamically allocated data for agents or nodes/patches. The LaserFrame class is similar to a database table or a Pandas DataFrame and supports scalar and vector properties.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":"<p>Classes:</p> Name Description <code>LaserFrame</code> <p>A class to manage dynamically allocated data for agents or nodes/patches.</p> <p>Usage Example</p> <pre><code>laser_frame = LaserFrame(capacity=100)\nlaser_frame.add_scalar_property('age', dtype=np.int32, default=0)\nlaser_frame.add_vector_property('position', length=3, dtype=np.float32, default=0.0)\nstart, end = laser_frame.add(10)\nlaser_frame.sort(np.arange(10)[::-1])\nlaser_frame.squash(np.array([True, False, True, False, True, False, True, False, True, False]))\n</code></pre> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>The current count of active elements.</p> <code>capacity</code> <code>int</code> <p>The maximum capacity of the frame.</p> <p>Note</p> <p>Since count can be less than capacity, properties return slices of the underlying arrays up to count by default so users do not have to include the slice themselves. I.e., if <code>lf</code> is a LaserFrame, then <code>lf.age</code> returns <code>lf._age[0:lf.count]</code> automatically. The full underlying array is always available as <code>lf._age</code> (or whatever the property name is). The slice returned is valid for all NumPy operations, including assignment, as well as for use with Numba compiled functions.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame","title":"<code>laser.core.laserframe.LaserFrame(capacity, initial_count=-1, **kwargs)</code>","text":"<p>The LaserFrame class, similar to a db table or a Pandas DataFrame, holds dynamically allocated data for agents (generally 1-D or scalar) or for nodes|patches (e.g., 1-D for scalar value per patch or 2-D for time-varying per patch).</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame--glossary","title":"Glossary","text":"<p>Initialize a LaserFrame object.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum capacity of the frame.             Must be a positive integer.</p> required <code>initial_count</code> <code>int</code> <p>The initial number of active elements in the frame.                  Must be a positive integer &lt;= capacity.</p> <code>-1</code> <code>**kwargs</code> <p>Additional keyword arguments to set as attributes of the object.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If capacity or initial_count is not a positive integer,         or if initial_count is greater than capacity.</p> <p>Returns:</p> Type Description <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.capacity","title":"<code>laser.core.laserframe.LaserFrame.capacity</code>  <code>property</code>","text":"<p>Returns the capacity of the laser frame (total possible entries for dynamic properties).</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.capacity--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The capacity of the laser frame.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.count","title":"<code>laser.core.laserframe.LaserFrame.count</code>  <code>property</code>","text":"<p>Returns the current count (equivalent to len()).</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.count--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current count value.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.count--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add","title":"<code>laser.core.laserframe.LaserFrame.add(count)</code>","text":"<p>Adds the specified count to the current count of the LaserFrame.</p> <p>This method increments the internal count by the given count, ensuring that the total does not exceed the frame's capacity. If the addition would exceed the capacity, an assertion error is raised. This method is typically used to add new births during the simulation.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number to add to the current count.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: A tuple containing the [start index, end index) after the addition.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the resulting count exceeds the frame's capacity.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property","title":"<code>laser.core.laserframe.LaserFrame.add_array_property(name, shape, dtype=np.uint32, default=0)</code>","text":"<p>Adds an array property to the object.</p> <p>This method initializes a new property with the given name as a multi-dimensional NumPy array.</p> <p>The array will have the given shape (note that there is no implied dimension of size self._capacity), datatype (default is np.uint32), and default value (default is 0).</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>shape</code> <code>tuple</code> <p>The shape of the array.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_array_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_scalar_property","title":"<code>laser.core.laserframe.LaserFrame.add_scalar_property(name, dtype=np.uint32, default=0)</code>","text":"<p>Add a scalar property to the class.</p> <p>This method initializes a new scalar property for the class instance. The property is stored as a 1-D NumPy array (scalar / entry) with a specified data type and default value.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the scalar property to be added.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data type for the property. Default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value for the property. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_scalar_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property","title":"<code>laser.core.laserframe.LaserFrame.add_vector_property(name, length, dtype=np.uint32, default=0)</code>","text":"<p>Adds a vector property to the object.</p> <p>This method initializes a new property with the given name as a 2-D NumPy array (vector per entry).</p> <p>The array will have a shape of (length, self._capacity) and will be filled with the specified default value. The data type of the array elements is determined by the <code>dtype</code> parameter.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property to be added.</p> required <code>length</code> <code>int</code> <p>The length of the vector.</p> required <code>dtype</code> <code>data - type</code> <p>The desired data-type for the array, default is np.uint32.</p> <code>uint32</code> <code>default</code> <code>scalar</code> <p>The default value to fill the array with, default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.add_vector_property--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.describe","title":"<code>laser.core.laserframe.LaserFrame.describe(target=None)</code>","text":"<p>Return a formatted string description of the laserframe object, including its attributes and their values.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.describe--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>target</code> <p>Optional string for the report header (generally the name of the LaserFrame variable, e.g., \"People\". Unlike functions, we can't get the name of a variable automatically).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string describing the laserframe object, including its capacity, count, and  details of its scalar, vector, and other properties.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.describe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.describe--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot","title":"<code>laser.core.laserframe.LaserFrame.load_snapshot(path, n_ppl, cbr, nt)</code>  <code>classmethod</code>","text":"<p>Load a LaserFrame and optional extras from an HDF5 snapshot file.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the HDF5 snapshot file.</p> required <code>n_ppl</code> <code>float or array - like</code> <p>Original total population (or per-node array) used to estimate births.</p> required <code>cbr</code> <code>float or array - like</code> <p>Crude birth rate (per 1000/year).</p> required <code>nt</code> <code>int</code> <p>Simulation duration (number of ticks).</p> required <p>Returns:</p> Type Description <p>frame (LaserFrame)</p> <p>results_r (np.ndarray or None)</p> <p>pars (dict or None)</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.load_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.save_snapshot","title":"<code>laser.core.laserframe.LaserFrame.save_snapshot(path, results_r=None, pars=None)</code>","text":"<p>Save this LaserFrame and optional extras to an HDF5 snapshot file.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.save_snapshot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <p>Destination file path</p> required <code>results_r</code> <p>Optional 2D numpy array of recovered counts</p> <code>None</code> <code>pars</code> <p>Optional PropertySet or dict of parameters</p> <code>None</code>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.save_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.save_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.save_snapshot--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.sort","title":"<code>laser.core.laserframe.LaserFrame.sort(indices, verbose=False)</code>","text":"<p>Sorts the elements of the object's numpy arrays based on the provided indices.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.sort--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>An array of indices used to sort the numpy arrays. Must be of integer type and have the same length as the frame count (<code>self._count</code>).</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the sorting progress for each numpy array attribute. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not an integer array or if its length does not match the frame count of active elements.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.sort--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.sort--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.sort--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.squash","title":"<code>laser.core.laserframe.LaserFrame.squash(indices, verbose=False)</code>","text":"<p>Reduces the active count of the internal numpy arrays keeping only elements True in the provided boolean indices.</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.squash--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>A boolean array indicating which elements to keep. Must have the same length as the current frame active element count.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints detailed information about the squashing process. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>indices</code> is not a boolean array or if its length does not match the current frame active element count.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#laser.core.laserframe.LaserFrame.squash--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/laserframe/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/","title":"laser.core.migration","text":""},{"location":"reference/laser/core/migration/#laser.core.migration","title":"<code>laser.core.migration</code>","text":"<p>This module provides various functions to calculate migration networks based on different models, including the gravity model, competing destinations model, Stouffer's model, and the radiation model.</p> <p>Additionally, it includes a utility function to calculate the great-circle distance between two points on the Earth's surface using the Haversine formula.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration--glossary","title":"Glossary","text":"<p>Functions:</p> Name Description <code>gravity</code> <p>np.ndarray, distances: np.ndarray, k: float, a: float, b: float, c: float, max_frac: Union[float, None]=None, kwargs) -&gt; np.ndarray:</p> <code>row_normalizer</code> <p>np.ndarray, max_rowsum: float) -&gt; np.ndarray: Normalize the rows of a given network matrix such that no row sum exceeds a specified maximum value.</p> <code>competing_destinations</code> <p>np.ndarray, distances: np.ndarray, b: float, c: float, delta: float, params) -&gt; np.ndarray:</p> <code>stouffer</code> <p>np.ndarray, distances: np.ndarray, k: float, a: float, b: float, include_home: bool, params) -&gt; np.ndarray: Compute a migration network using a modified Stouffer's model.</p> <code>radiation</code> <p>np.ndarray, distances: np.ndarray, k: float, include_home: bool, params) -&gt; np.ndarray:</p> <code>distance</code> <p>float, lon1: float, lat2: float, lon2: float) -&gt; float: Calculate the great-circle distance between two points on the Earth's surface using the Haversine formula.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations","title":"<code>laser.core.migration.competing_destinations(pops, distances, k, a, b, c, delta, **params)</code>","text":"<p>Calculate the competing destinations model for a given set of populations and distances. (Fotheringham AS. Spatial flows and spatial patterns. Environment and planning A. 1984;16(4):529-543)</p> <p>This function computes a network matrix based on the gravity model and then adjusts it using the competing destinations model. The adjustment is done by considering the interference from other destinations.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":"<p>Mathematical formula</p> <p>Element-by-element:     $$     network_{i,j} = k \\times p_i^a \\times p_j^b / distance_{i,j}^c \\times \\sum_k {(p_k^b / distance_{j,k}^c \\text {\\small for k not in [i,j]})^{delta} }     $$</p> <p>As-implemented numpy math:</p> <ul> <li>Compute all terms up to the sum_k using the gravity model</li> <li>Construct the matrix inside the sum: <code>p**b * distances**(1-c)</code></li> <li>Sum on the second axis (k), and subtract off the diagonal (j=k terms):     <code>row_sums = np.sum(competition_matrix, axis=1) - np.diag(competition_matrix)</code></li> <li>Now element-by-element, subtract k=i terms off the sum, exponentiate, and multiply the original network term:     <code>network[i][j] = network[i][j] * (row_sums[i] - competition_matrix[i][j]) ** delta</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>pops</code> <code>ndarray</code> <p>Array of populations.</p> required <code>distances</code> <code>ndarray</code> <p>Array of distances between locations.</p> required <code>k</code> <code>float</code> <p>Scaling constant.</p> required <code>a</code> <code>float</code> <p>Exponent for the population of the origin.</p> required <code>b</code> <code>float</code> <p>Exponent parameter for populations in the gravity model.</p> required <code>c</code> <code>float</code> <p>Exponent parameter for distances in the gravity model.</p> required <code>delta</code> <code>float</code> <p>Exponent parameter for the competing destinations adjustment.</p> required <code>\\*\\*params</code> <p>Additional parameters to be passed to the gravity model.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: Adjusted network matrix based on the competing destinations model.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.competing_destinations--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.distance","title":"<code>laser.core.migration.distance(lat1, lon1, lat2=None, lon2=None)</code>","text":"<p>Calculate the great-circle distance between two points on the Earth's surface. This function uses the Haversine formula to compute the distance between two points specified by their latitude and longitude in decimal degrees.</p> <ul> <li>If lat2 and lon2 are not provided, they default to lat1 and lon1, respectively. This supports the default case of calculating the NxN matrix of distances between all pairs of points in (lat1, lon1).</li> <li>If all arguments are scalars, will return a single scalar distance, (lat1, lon1) to (lat2, lon2).</li> <li>If lat2, lon2 are vectors, will return a vector of distances, (lat1, lon1) to each lat/lon in lat2, lon2.</li> <li>If lat1, lon1 and lat2, lon2 are vectors, will return a matrix with shape (N, M) of distances where N is the length of lat1/lon1 and M is the length of lat2/lon2.</li> </ul>"},{"location":"reference/laser/core/migration/#laser.core.migration.distance--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>lat1</code> <code>float</code> <p>Latitude of the first point(s) in decimal degrees [-90, 90].</p> required <code>lon1</code> <code>float</code> <p>Longitude of the first point(s) in decimal degrees [-180, 180].</p> required <code>lat2</code> <code>float</code> <p>Latitude of the second point(s) in decimal degrees [-90, 90].</p> <code>None</code> <code>lon2</code> <code>float</code> <p>Longitude of the second point(s) in decimal degrees [-180, 180].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <p>The distance between the two points in kilometers.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.distance--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.distance--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.distance--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.distance--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.distance--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity","title":"<code>laser.core.migration.gravity(pops, distances, k, a, b, c, **kwargs)</code>","text":"<p>Calculate a gravity model network.</p> <p>This function computes a gravity model network based on the provided populations and distances. The gravity model estimates migration or interaction flows between populations using a mathematical formula that incorporates scaling, population sizes, and distances.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":"<p>Mathematical formula</p> \\[ network_{i,j} = k \\cdot \\frac{p_i^a \\cdot p_j^b}{distance_{i,j}^c} \\] <p>As implemented in NumPy: <pre><code>network = k * (pops[:, np.newaxis] ** a) * (pops ** b) * (distances ** (-1 * c))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>pops</code> <code>ndarray</code> <p>1D array of population sizes for each node.</p> required <code>distances</code> <code>ndarray</code> <p>2D array of distances between nodes. Must be symmetric, with self-distances (diagonal) handled.</p> required <code>k</code> <code>float</code> <p>Scaling constant to adjust the overall magnitude of interaction flows.</p> required <code>a</code> <code>float</code> <p>Exponent for the population size of the origin node.</p> required <code>b</code> <code>float</code> <p>Exponent for the population size of the destination node.</p> required <code>c</code> <code>float</code> <p>Exponent for the distance between nodes, controlling how distance impacts flows.</p> required <code>\\*\\*kwargs</code> <p>Additional keyword arguments (not used in the current implementation).</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: A 2D matrix representing the interaction network, where each element <code>network[i, j]</code> corresponds to the flow from node <code>i</code> to node <code>j</code>.</p> <p>Example usage</p> <pre><code>import numpy as np\nfrom gravity_model import gravity\n\n# Define populations and distances\npopulations = np.array([1000, 500, 200])\ndistances = np.array([\n    [0, 2, 3],\n    [2, 0, 1],\n    [3, 1, 0]\n])\n\n# Parameters for the gravity model\nk = 0.5\na = 1.0\nb = 1.0\nc = 2.0\n\n# Compute the gravity model network\nmigration_network = gravity(populations, distances, k, a, b, c)\n\nprint(\"Migration Network:\")\nprint(migration_network)\n</code></pre> <p>Notes</p> <ul> <li>The diagonal of the <code>distances</code> array is set to <code>1</code> internally to avoid division by zero.</li> <li>The diagonal of the output <code>network</code> matrix is set to <code>0</code> to represent no self-loops.</li> <li>Ensure the <code>distances</code> matrix is symmetric and non-negative.</li> </ul>"},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.gravity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation","title":"<code>laser.core.migration.radiation(pops, distances, k, include_home, **params)</code>","text":"<p>Calculate the migration network using the radiation model.</p> <p>(Simini F, Gonza \u0301lez MC, Maritan A, Baraba \u0301si AL. A universal model for mobility and migration patterns. Nature. 2012;484(7392):96-100.)</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":"<p>Mathematical formula</p> <p>Element-by-element:     $$     network_{i,j} = k \\times p_i^a \\times (p_j / \\sum_k {p_k} )^b,     $$     where the sum proceeds over all \\(k\\) such that \\(distances_{i,k} \\leq distances_{i,j}\\)     the parameter <code>include_home</code> determines whether \\(p_i\\) is included or excluded from the sum.</p> <p>As-implemented numpy math:</p> <ul> <li>Sort each row of the distance matrix (we'll use \\' below to indicate distance-sorted vectors)</li> <li> <p>Loop over \"source nodes\" i</p> <ul> <li>Cumulative sum the sorted populations, ensuring appropriate handling when there are multiple destinations equidistant from the source</li> <li>Subtract the source node population if <code>include_home</code> is <code>False</code></li> <li>Construct the row of the network matrix as     $$     k \\times p_i \\times p_{j'} / (p_i + \\sum_{k'} {p_{k'}}) / (p_i + p_{j'} + \\sum_{k'} {p_{k'}})     $$</li> </ul> </li> <li> <p>Unsort the rows of the network</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>pops</code> <code>ndarray</code> <p>Array of population sizes for each node.</p> required <code>distances</code> <code>ndarray</code> <p>2D array of distances between nodes.</p> required <code>k</code> <code>float</code> <p>Scaling factor for the migration rates.</p> required <code>include_home</code> <code>bool</code> <p>Whether to include the home population in the calculations.</p> required <code>\\*\\*params</code> <p>Additional parameters (currently not used).</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: 2D array representing the migration network.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.radiation--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.row_normalizer","title":"<code>laser.core.migration.row_normalizer(network, max_rowsum)</code>","text":"<p>Normalizes the rows of a given network matrix such that no row sum exceeds a specified maximum value.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.row_normalizer--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>network</code> <code>ndarray</code> <p>A 2D array representing the network matrix.</p> required <code>max_rowsum</code> <code>float</code> <p>The maximum allowable sum for any row in the network matrix.</p> required <p>Returns:</p> Type Description <p>numpy.ndarray: The normalized network matrix where no row sum exceeds the specified maximum value.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.row_normalizer--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.row_normalizer--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.row_normalizer--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.stouffer","title":"<code>laser.core.migration.stouffer(pops, distances, k, a, b, include_home, **params)</code>","text":"<p>Computes a migration network using a modified Stouffer's model.</p> <p>(Stouffer SA. Intervening opportunities: a theory relating mobility and distance. American sociological review. 1940;5(6):845-867)</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.stouffer--glossary","title":"Glossary","text":"<p>Mathematical formula</p> <p>Element-by-element:     $$     network_{i,j} = k \\times p_i \\times p_j / ( (p_i + \\sum_k {p_k}) (p_i + p_j + \\sum_k {p_k}) )     $$     the parameter <code>include_home</code> determines whether \\(p_i\\) is included or excluded from the sum</p> <p>As-implemented numpy math:</p> <ul> <li>Sort each row of the distance matrix (we'll use \\' below to indicate distance-sorted vectors)</li> <li> <p>Loop over \"source nodes\" i:</p> <ul> <li>Cumulative sum the sorted populations, ensuring appropriate handling when there are multiple destinations equidistant from the source</li> <li>Subtract the source node population if <code>include_home</code> is <code>False</code></li> <li>Construct the row of the network matrix as \\(k \\times p_i^a \\times (p_{j'} / \\sum_{k'} {p_{k'}})^b\\)</li> </ul> </li> <li> <p>Unsort the rows of the network</p> </li> </ul> <p>Parameters:</p> <pre><code>pops (numpy.ndarray): An array of population sizes.\ndistances (numpy.ndarray): A 2D array where distances[i][j] is the distance from location i to location j.\nk (float): A scaling factor for the migration rates.\na (float): Exponent applied to the population size of the origin.\nb (float): Exponent applied to the ratio of destination population to the sum of all populations at equal or lesser distances.\ninclude_home (bool): If True, includes the home population in the cumulative sum; otherwise, excludes it.\n\\*\\*params: Additional parameters (not used in the current implementation).\n</code></pre>"},{"location":"reference/laser/core/migration/#laser.core.migration.stouffer--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.stouffer--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#laser.core.migration.stouffer--glossary","title":"Glossary","text":"<p>Returns:</p> Type Description <p>numpy.ndarray: A 2D array representing the migration network, where network[i][j] is the migration rate from location i to location j.</p>"},{"location":"reference/laser/core/migration/#laser.core.migration.stouffer--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/migration/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/","title":"laser.core.propertyset","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset","title":"<code>laser.core.propertyset</code>","text":"<p>Implements a PropertySet class that can be used to store properties in a dictionary-like object.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet","title":"<code>laser.core.propertyset.PropertySet(*bags)</code>","text":"<p>A class that can be used to store properties in a dictionary-like object with <code>.property</code> access to properties.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet--examples","title":"Examples","text":"<p>Basic Initialization:     &gt;&gt;&gt; from laser.core import PropertySet     &gt;&gt;&gt; ps = PropertySet()     &gt;&gt;&gt; ps['infection_status'] = 'infected'     &gt;&gt;&gt; ps['age'] = 35     &gt;&gt;&gt; print(ps.infection_status)  # Outputs: 'infected'     &gt;&gt;&gt; print(ps['age'])            # Outputs: 35     <pre><code>Combining two PropertySets:\n</code></pre>     &gt;&gt;&gt; ps1 = PropertySet({'immunity': 'high', 'region': 'north'})     &gt;&gt;&gt; ps2 = PropertySet({'infectivity': 0.7})     &gt;&gt;&gt; combined_ps = ps1 + ps2     &gt;&gt;&gt; print(combined_ps.to_dict())     {'immunity': 'high', 'region': 'north', 'infectivity': 0.7}     <pre><code>Creating a PropertySet from a dictionary:\n</code></pre>     &gt;&gt;&gt; ps = PropertySet({'mything': 0.4, 'that_other_thing': 42})     &gt;&gt;&gt; print(ps.mything)            # Outputs: 0.4     &gt;&gt;&gt; print(ps.that_other_thing)   # Outputs: 42     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42}     <pre><code>Save and load:\n</code></pre>     &gt;&gt;&gt; ps.save('properties.json')     &gt;&gt;&gt; loaded_ps = PropertySet.load('properties.json')     &gt;&gt;&gt; print(loaded_ps.to_dict())  # Outputs the saved properties     <pre><code>Property access and length:\n</code></pre>     &gt;&gt;&gt; ps['status'] = 'susceptible'     &gt;&gt;&gt; ps['exposure_timer'] = 5     &gt;&gt;&gt; print(ps['status'])          # Outputs: 'susceptible'     &gt;&gt;&gt; print(len(ps))               # Outputs: 4     <pre><code>In-Place addition (added keys must *not* exist in the destination PropertySet):\n</code></pre>     &gt;&gt;&gt; ps += {'new_timer': 10, 'susceptibility': 0.75}     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 5, 'new_timer': 10, 'susceptibility': 0.75}     <pre><code>In-place update (keys *must* already exist in the destination PropertySet):\n</code></pre>     &gt;&gt;&gt; ps &lt;&lt;= {'exposure_timer': 10, 'infectivity': 0.8}     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 10, 'infectivity': 0.8}     <pre><code>In-place addition or update (no restriction on incoming keys):\n</code></pre>     &gt;&gt;&gt; ps |= {'new_timer': 10, 'exposure_timer': 8}     &gt;&gt;&gt; print(ps.to_dict())     {'mything': 0.4, 'that_other_thing': 42, 'status': 'susceptible', 'exposure_timer': 8, 'new_timer': 10}     ```</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet--glossary","title":"Glossary","text":"<p>Initialize a PropertySet to manage properties in a dictionary-like structure.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>*bags </code> <p>iterable, optional A sequence of key-value pairs (e.g., lists, tuples, dictionaries) to initialize the PropertySet. Keys must be strings, and values can be any type.</p> required"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__add__","title":"<code>laser.core.propertyset.PropertySet.__add__(other)</code>","text":"<p>Add another PropertySet to this PropertySet.</p> <p>This method allows the use of the <code>+</code> operator to combine two PropertySet instances.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__add__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to add.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <p>A new PropertySet instance that combines the properties of both instances.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__add__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__add__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__contains__","title":"<code>laser.core.propertyset.PropertySet.__contains__(key)</code>","text":"<p>Check if a key is in the property set.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__contains__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check for existence in the property set.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the key exists in the property set, False otherwise.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__contains__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__contains__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__eq__","title":"<code>laser.core.propertyset.PropertySet.__eq__(other)</code>","text":"<p>Check if two PropertySet instances are equal.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__eq__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>PropertySet</code> <p>The other PropertySet instance to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the two instances are equal, False otherwise.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__eq__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__eq__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__getitem__","title":"<code>laser.core.propertyset.PropertySet.__getitem__(key)</code>","text":"<p>Retrieve the attribute of the object with the given key (e.g., <code>ps[key]</code>).</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__getitem__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The value of the attribute with the specified key.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute with the specified key does not exist.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__getitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__getitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__getitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__iadd__","title":"<code>laser.core.propertyset.PropertySet.__iadd__(other)</code>","text":"<p>Implements the in-place addition (<code>+=</code>) operator for the class.</p> <p>This method allows the instance to be updated with attributes from another instance of the same class or from a dictionary. If <code>other</code> is an instance of the same class, its attributes are copied to the current instance. If <code>other</code> is a dictionary, its key-value pairs are added as attributes to the current instance.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__iadd__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary to add to the current instance.</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The updated instance with the new attributes.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys already present in the PropertySet.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__iadd__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ilshift__","title":"<code>laser.core.propertyset.PropertySet.__ilshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;=</code> operator on PropertySet to override existing values with new values.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ilshift__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The updated instance with the overrides from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ilshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ior__","title":"<code>laser.core.propertyset.PropertySet.__ior__(other)</code>","text":"<p>Implements the <code>|=</code> operator on PropertySet to override existing values with new values.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ior__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Name Type Description <code>self</code> <p>The updated instance with all the values of self with new or overriding values from other.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ior__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ior__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__ior__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__len__","title":"<code>laser.core.propertyset.PropertySet.__len__()</code>","text":"<p>Return the number of attributes in the instance.</p> <p>This method returns the number of attributes stored in the instance's dict attribute, which represents the instance's namespace.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__len__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <p>The number of attributes in the instance.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__len__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__lshift__","title":"<code>laser.core.propertyset.PropertySet.__lshift__(other)</code>","text":"<p>Implements the <code>&lt;&lt;</code> operator on PropertySet to override existing values with new values.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__lshift__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Type Description <p>A new PropertySet with all the values of the first PropertySet with overrides from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p> <code>ValueError</code> <p>If <code>other</code> contains keys not present in the PropertySet.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__lshift__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__or__","title":"<code>laser.core.propertyset.PropertySet.__or__(other)</code>","text":"<p>Implements the <code>|</code> operator on PropertySet to add new or override existing values with new values.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__or__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[type(self), dict]</code> <p>The object or dictionary with overriding values.</p> required <p>Returns:</p> Type Description <p>A new PropertySet with all the values of the first PropertySet with new or overriding values from the second PropertySet.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>other</code> is neither an instance of the same class nor a dictionary.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__or__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__or__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__or__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__repr__","title":"<code>laser.core.propertyset.PropertySet.__repr__()</code>","text":"<p>Return a string representation of the PropertySet instance.</p> <p>The string representation includes the class name and the dictionary of the instance's attributes.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__repr__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PropertySet instance.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__repr__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__setitem__","title":"<code>laser.core.propertyset.PropertySet.__setitem__(key, value)</code>","text":"<p>Set the value of an attribute. This method allows setting an attribute of the instance using the dictionary-like syntax (e.g., <code>ps[key] = value</code>).</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__setitem__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the attribute to set.</p> required <code>value</code> <code>any</code> <p>The value to set for the attribute.</p> required <p>Returns:</p> Type Description <p>None</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__setitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__setitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__setitem__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__str__","title":"<code>laser.core.propertyset.PropertySet.__str__()</code>","text":"<p>Returns a string representation of the object's dictionary.</p> <p>This method is used to provide a human-readable string representation of the object, which includes all the attributes stored in the object's <code>__dict__</code>.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__str__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the object's dictionary.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.__str__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.load","title":"<code>laser.core.propertyset.PropertySet.load(filename)</code>  <code>staticmethod</code>","text":"<p>Load a PropertySet from a specified file.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.load--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet is saved.</p> required <p>Returns:</p> Name Type Description <code>PropertySet</code> <p>The PropertySet instance loaded from the file.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.load--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.load--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.save","title":"<code>laser.core.propertyset.PropertySet.save(filename)</code>","text":"<p>Save the PropertySet to a specified file.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.save--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the file where the PropertySet will be saved.</p> required <p>Returns:</p> Type Description <p>None</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.save--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.save--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.to_dict","title":"<code>laser.core.propertyset.PropertySet.to_dict()</code>","text":"<p>Convert the PropertySet to a dictionary.</p>"},{"location":"reference/laser/core/propertyset/#laser.core.propertyset.PropertySet.to_dict--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/propertyset/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/random/","title":"laser.core.random","text":""},{"location":"reference/laser/core/random/#laser.core.random","title":"<code>laser.core.random</code>","text":"<p>Functions for seeding and accessing the laser-core random number generator.</p> <p>Using the seed() function here and the pseudo-random number generator (PRNG) returned from the prng() function in simulation code will guarantee that the same random number stream is generated and used during simulation runs using the same seed value (assuming no changes to code which add or remove PRNG calls or change the number of random draws requested). This is important for reproducibility and debugging purposes.</p>"},{"location":"reference/laser/core/random/#laser.core.random--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/random/#laser.core.random.get_seed","title":"<code>laser.core.random.get_seed()</code>","text":"<p>Return the seed used to initialize the pseudo-random number generator.</p>"},{"location":"reference/laser/core/random/#laser.core.random.get_seed--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>uint32</code> <code>uint32</code> <p>The seed value used to initialize the random number generators.</p>"},{"location":"reference/laser/core/random/#laser.core.random.get_seed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/random/#laser.core.random.prng","title":"<code>laser.core.random.prng()</code>","text":"<p>Return the global (to LASER) pseudo-random number generator.</p>"},{"location":"reference/laser/core/random/#laser.core.random.prng--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/random/#laser.core.random.seed","title":"<code>laser.core.random.seed(seed)</code>","text":"<p>Initialize the pseudo-random number generator with a given seed.</p> <p>This function sets the global pseudo-random number generator (_prng) to a new instance of numpy's default random generator initialized with the provided seed. It also seeds Numba's per-thread random number generators with the same seed.</p>"},{"location":"reference/laser/core/random/#laser.core.random.seed--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The seed value to initialize the random number generators.</p> required <p>Returns:</p> Type Description <code>Generator</code> <p>numpy.random.Generator: The initialized pseudo-random number generator.</p>"},{"location":"reference/laser/core/random/#laser.core.random.seed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/random/#laser.core.random.seed--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/random/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/","title":"laser.core.sortedqueue","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue","title":"<code>laser.core.sortedqueue</code>","text":"<p>SortedQueue implementation using NumPy and Numba.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue","title":"<code>laser.core.sortedqueue.SortedQueue(capacity, values)</code>","text":"<p>A sorted (priority) queue implemented using NumPy arrays and sped-up with Numba.</p> <p>Using the algorithm from the Python heapq module.</p> <p>init with an existing array of sorting values</p> <p>push with an index into sorting values</p> <p>pop returns the index of the lowest sorting value and its value</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue--glossary","title":"Glossary","text":"<p>Initializes a new instance of the class with a specified capacity and reference to existing, sortable values.</p> <p>This implementation is specific to LASER and the expectation of tracking 10s or 100s of millions of agents.</p> <p>We expect the sortable (or priority) values to already be in a NumPy array, usually a property of a LaserFrame object.</p> <p>The <code>push()</code> and <code>pop()</code> will take indices into this array and will sort on values[i]. This avoids making copies of the sort values.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>capacity</code> <code>int</code> <p>The maximum number of elements the queue can hold.</p> required <code>values</code> <code>ndarray</code> <p>A reference to an array of values to be accessed by the queue.</p> required"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__len__","title":"<code>laser.core.sortedqueue.SortedQueue.__len__()</code>","text":"<p>Return the number of elements in the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__len__--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of elements in the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__len__--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__pop","title":"<code>laser.core.sortedqueue.SortedQueue.__pop()</code>","text":"<p>Removes the smallest value element from the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__pop--glossary","title":"Glossary","text":"<p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Side effects</p> <ul> <li>Decreases the size of the sorted queue by one.</li> <li>Reorganizes the internal structure of the sorted queue to maintain the heap property.</li> </ul>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__pop--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__pop--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.__pop--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peeki","title":"<code>laser.core.sortedqueue.SortedQueue.peeki()</code>","text":"<p>Returns the index of the smallest value element in the sorted queue without removing it.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peeki--glossary","title":"Glossary","text":"<p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peeki--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peeki--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekiv","title":"<code>laser.core.sortedqueue.SortedQueue.peekiv()</code>","text":"<p>Returns the index and value of the smallest value element in the sorted queue without removing it.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekiv--glossary","title":"Glossary","text":"<p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekiv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekiv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekv","title":"<code>laser.core.sortedqueue.SortedQueue.peekv()</code>","text":"<p>Return the smallest value from the sorted queue without removing it.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekv--glossary","title":"Glossary","text":"<p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is empty.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value with the smallest value in the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.peekv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popi","title":"<code>laser.core.sortedqueue.SortedQueue.popi()</code>","text":"<p>Removes and returns the index of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index of the smallest value element using <code>peeki()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popi--glossary","title":"Glossary","text":"<p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The index of the smallest value element in the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popi--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popiv","title":"<code>laser.core.sortedqueue.SortedQueue.popiv()</code>","text":"<p>Removes and returns the index and value of the smallest value element in the sorted queue.</p> <p>This method first retrieves the index and value of the smallest value element using <code>peekiv()</code>, then removes the element from the queue using <code>pop()</code>, and finally returns the index and value.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popiv--glossary","title":"Glossary","text":"<p>Returns:</p> Type Description <code>tuple[uint32, Any]</code> <p>tuple[np.uint32, Any]: A tuple containing the index and value of the smallest value element.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popiv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popv","title":"<code>laser.core.sortedqueue.SortedQueue.popv()</code>","text":"<p>Removes and returns the value at the front of the sorted queue.</p> <p>This method first retrieves the value at the front of the queue without removing it by calling <code>peekv()</code>, and then removes the front element from the queue by calling <code>pop()</code>. The retrieved value is then returned.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popv--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value at the front of the sorted queue.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.popv--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.push","title":"<code>laser.core.sortedqueue.SortedQueue.push(index)</code>","text":"<p>Insert an element into the sorted queue.</p> <p>This method adds an element at the back of the sorted queue and then ensures the heap property is maintained by sifting the element forward to its correct position.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.push--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the element to be added to the sorted queue.</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the sorted queue is full.</p>"},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.push--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#laser.core.sortedqueue.SortedQueue.push--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/sortedqueue/#glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/","title":"laser.core.utils","text":""},{"location":"reference/laser/core/utils/#laser.core.utils","title":"<code>laser.core.utils</code>","text":"<p>This module provides utility functions for the laser-measles project.</p>"},{"location":"reference/laser/core/utils/#laser.core.utils--glossary","title":"Glossary","text":"<p>Functions:</p> Name Description <code>calc_capacity</code> <p>np.uint32, nticks: np.uint32, cbr: np.float32, verbose: bool = False) -&gt; np.uint32: Calculate the population capacity after a given number of ticks based on a constant birth rate.</p> <code>grid</code> <p>Tuple[int, int], fill_value: float = 0.0) -&gt; np.ndarray: Create a 2D grid (numpy array) of the specified shape, filled with the given value.</p>"},{"location":"reference/laser/core/utils/#laser.core.utils--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity","title":"<code>laser.core.utils.calc_capacity(population, nticks, cbr, verbose=False)</code>","text":"<p>Calculate the population capacity after a given number of ticks based on a constant birth rate (CBR).</p>"},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>population</code> <code>uint32</code> <p>The initial population.</p> required <code>nticks</code> <code>uint32</code> <p>The number of ticks (time steps) to simulate.</p> required <code>cbr</code> <code>float32</code> <p>The constant birth rate per 1000 people per year.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints detailed population growth information. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: The estimated population capacity after the given number of ticks.</p>"},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.grid","title":"<code>laser.core.utils.grid(M=5, N=5, node_size_km=10, population_fn=None, origin_x=0, origin_y=0)</code>","text":"<p>Create an MxN grid of cells anchored at (lat, long) with populations and geometries.</p>"},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>M</code> <code>int</code> <p>Number of rows (north-south).</p> <code>5</code> <code>N</code> <code>int</code> <p>Number of columns (east-west).</p> <code>5</code> <code>node_size_km</code> <code>float</code> <p>Size of each cell in kilometers (default 10).</p> <code>10</code> <code>population_fn</code> <code>callable</code> <p>Function(row, col) returning population for a cell. Default is uniform random between 1,000 and 100,000.</p> <code>None</code> <code>origin_x</code> <code>float</code> <p>longitude of the origin in decimal degrees (bottom-left corner) -180 &lt;= origin_x &lt; 180.</p> <code>0</code> <code>origin_y</code> <code>float</code> <p>latitude of the origin in decimal degrees (bottom-left corner) -90 &lt;= origin_y &lt; 90.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <p>Columns are nodeid, population, geometry.</p>"},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#laser.core.utils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/core/utils/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/","title":"laser.generic","text":""},{"location":"reference/laser/generic/#laser.generic","title":"<code>laser.generic</code>","text":""},{"location":"reference/laser/generic/#laser.generic.Births","title":"<code>laser.generic.Births(model, verbose=False)</code>","text":"<p>A component to handle the birth events in a model. Requires a model with a <code>population</code> attribute that has a <code>dob</code> attribute. It calculates the number of births based on the model's parameters and updates the population accordingly. It also provides methods to plot birth statistics.</p>"},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":"<p>Attributes:</p> Name Type Description <code>model</code> <p>The model instance containing population and parameters.</p> <code>verbose</code> <code>bool</code> <p>Flag to enable verbose output. Default is False.</p> <code>initializers</code> <code>list</code> <p>List of initializers to be called on birth events.</p> <code>metrics</code> <code>DataFrame</code> <p>DataFrame to holding timing metrics for initializers.</p> <p>Initialize the Births component.</p>"},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model object which must have a <code>population</code> attribute.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the model does not have a <code>population</code> attribute.</p> <code>AssertionError</code> <p>If the model's population does not have a <code>dob</code> attribute.</p>"},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.initializers","title":"<code>laser.generic.Births.initializers</code>  <code>property</code>","text":"<p>Returns the initializers to call on new agent births.</p> <p>This method retrieves the initializers that are used to set up the initial state or configuration for agents at birth.</p>"},{"location":"reference/laser/generic/#laser.generic.Births.initializers--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of initializers - instances of objects with an <code>on_birth</code> method.</p>"},{"location":"reference/laser/generic/#laser.generic.Births.initializers--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.metrics","title":"<code>laser.generic.Births.metrics</code>  <code>property</code>","text":"<p>Returns the timing metrics for the births initializers.</p> <p>This method retrieves the timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/#laser.generic.Births.metrics--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A Pandas DataFrame of timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/#laser.generic.Births.metrics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.__call__","title":"<code>laser.generic.Births.__call__(model, tick)</code>","text":"<p>Adds new agents to each patch based on expected daily births calculated from CBR. Calls each of the registered initializers for the newborns.</p>"},{"location":"reference/laser/generic/#laser.generic.Births.__call__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model containing patches, population, and parameters.</p> required <code>tick</code> <code>int</code> <p>The current time step in the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>This method performs the following steps</p> <ol> <li>Calculates the day of the year (doy) and the current year based on the tick.</li> <li>On the first day of the year, it generates annual births for each patch using a Poisson distribution.</li> <li>Calculates the number of births for the current day.</li> <li>Adds the newborns to the population and sets their date of birth.</li> <li>Assigns node IDs to the newborns.</li> <li>Calls any additional initializers for the newborns and records the timing of these initializations.</li> <li>Updates the population counts for the next tick with the new births.</li> </ol>"},{"location":"reference/laser/generic/#laser.generic.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.plot","title":"<code>laser.generic.Births.plot(fig=None)</code>","text":"<p>Plots the births in the top 5 most populous patches and a pie chart of birth initializer times.</p>"},{"location":"reference/laser/generic/#laser.generic.Births.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure object. If None, a new figure will be created. Defaults to None.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>None</code> <code>Any</code> <p>This function yields twice to allow for intermediate plotting steps.</p>"},{"location":"reference/laser/generic/#laser.generic.Births.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop","title":"<code>laser.generic.Births_ConstantPop(model, verbose=False)</code>","text":"<p>Handles births in models with a constant population size (births == deaths).</p> <p>This component ensures that the total population remains constant over time by generating daily birth counts that exactly match the expected mortality under a given crude birth rate (CBR). Each birth results in the creation of a new agent with a default susceptible state and a birth timestamp.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":"<p>Key responsibilities</p> <ul> <li>Stochastic generation of new births per patch and time step.</li> <li>Initialization of new agents with appropriate state and properties.</li> <li>Invocation of registered birth-time initializers.</li> <li>Real-time updates to reporting channels (e.g. SEIR counts).</li> </ul> <p>The component assumes that deaths are handled implicitly by replacing expired agents with newly born agents.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":"<p>Expected parameters</p> <ul> <li><code>cbr</code>: Crude birth rate per 1000 people per year (float).</li> <li><code>nticks</code>: Number of time steps in the simulation (int).</li> </ul> <p>Initialize the Births_ConstantPop component.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A Model instance with attributes: - <code>params.cbr</code>: Annual crude birth rate. - <code>params.nticks</code>: Number of time steps. - <code>population</code>: An agent population object. - <code>patches</code>: A patch manager with population counts. - <code>prng</code>: A random number generator supporting <code>.poisson</code> and <code>.exponential</code>.</p> required <code>verbose</code> <code>bool</code> <p>Enable detailed logging if True.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the model lacks a <code>population</code> or <code>dob</code> attribute.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.initializers","title":"<code>laser.generic.Births_ConstantPop.initializers</code>  <code>property</code>","text":"<p>Returns the initializers to call on new agent births.</p> <p>This method retrieves the initializers that are used to set up the initial state or configuration for agents at birth.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.initializers--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of initializers - instances of objects with an <code>on_birth</code> method.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.initializers--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.metrics","title":"<code>laser.generic.Births_ConstantPop.metrics</code>  <code>property</code>","text":"<p>Returns the timing metrics for the births initializers.</p> <p>This method retrieves the timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.metrics--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A Pandas DataFrame of timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.metrics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.__call__","title":"<code>laser.generic.Births_ConstantPop.__call__(model, tick)</code>","text":"<p>Execute births for a given time step.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.__call__--glossary","title":"Glossary","text":"<p>For each patch</p> <ul> <li>Determine the number of new agents to birth using a Poisson draw.</li> <li>Assign each agent a birth date and susceptible state.</li> <li>Update SEIR reporting channels to reflect changes.</li> <li>Run all registered <code>on_birth</code> initializers.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick (int).</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.plot","title":"<code>laser.generic.Births_ConstantPop.plot(fig=None)</code>","text":"<p>Visualize birth activity and initializer performance.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.plot--glossary","title":"Glossary","text":"<p>Generates two plots</p> <ol> <li>Line plot: Population and birth counts for top 5 most populous patches.</li> <li>Pie chart: Cumulative time spent in each <code>on_birth</code> initializer.</li> </ol> <p>This method is a generator; call <code>next()</code> twice to display both plots.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to reuse. Defaults to new figure.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>None (plot visuals are side effects).</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate","title":"<code>laser.generic.Births_ConstantPop_VariableBirthRate(model, verbose=False)</code>","text":"<p>               Bases: <code>Births_ConstantPop</code></p> <p>Birth process with time-varying crude birth rate (CBR) while maintaining constant population.</p> <p>This component extends <code>Births_ConstantPop</code> by allowing the birth rate to vary over time, based on a schedule of crude birth rates (CBRs) defined in the model parameters.</p> <p>Unlike a traditional demographic model, this assumes a constant total population size by balancing births and deaths. The birth rate schedule determines the number of daily births (and therefore deaths) at each timestep.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":"<p>Attributes:</p> Name Type Description <code>model</code> <p>The simulation model, which must contain population and patch data.</p> <p>Initialize the Births_ConstantPop_VariableBirthRate component.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A <code>Model</code> object with <code>population</code>, <code>patches</code>, and <code>params</code> attributes. <code>params.cbr</code> must be a dictionary with:     - \"rates\": list or array of CBR values (per 1000 people per year).     - \"timesteps\": list or array of corresponding time ticks when rates change.</p> required <code>verbose</code> <code>bool</code> <p>If True, print verbose status updates. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the model lacks a <code>population</code> attribute.</p> <code>ValueError</code> <p>If <code>params.cbr</code> is missing or malformed.</p>"},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Exposure","title":"<code>laser.generic.Exposure(model, verbose=False)</code>","text":"<p>LASER component representing the exposed (latent) state of a population.</p> <p>Each agent has an <code>etimer</code> (exposed timer). When <code>etimer &gt; 0</code>, the agent is in the exposed state. On each tick, <code>etimer</code> is decremented. When it reaches zero, the agent transitions to the infectious state, and its <code>itimer</code> (infectious timer) is initialized.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure--glossary","title":"Glossary","text":"<p>Initialize the Exposure component.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure--parameters","title":"Parameters","text":"<p>model : object     LASER model containing:       * <code>population</code> with attributes <code>count</code> and method         <code>add_scalar_property(name, dtype, default)</code>       * <code>patches</code> with method         <code>add_vector_property(name, length, dtype)</code>       * <code>params.nticks</code> (int): number of simulation ticks verbose : bool, optional     If True, enable verbose output. Default is False.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure--side-effects","title":"Side Effects","text":"<ul> <li>Adds a scalar property <code>etimer</code> (dtype=uint16, default=0) to the population.</li> <li>Adds a vector property <code>exposed</code> (dtype=uint32) to the patches.</li> <li>Initializes all etimers to zero.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Exposure--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Exposure.__call__","title":"<code>laser.generic.Exposure.__call__(model, tick)</code>","text":"<p>Update exposed timers for the population at the given tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.__call__--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.__call__--notes","title":"Notes","text":"<ul> <li>Decrements <code>etimer</code> for all exposed agents.</li> <li>Agents whose <code>etimer</code> reaches 0 transition to infectious:</li> <li><code>itimer</code> is set to a draw from Normal(inf_mean, inf_sigma),     with minimum value 1.</li> <li><code>state</code> is set to 2 (infectious).</li> <li>Patch-level accounting:</li> <li><code>patches.exposed_test[t+1]</code> is decremented by the number of     transitions.</li> <li><code>patches.cases_test[t+1]</code> is incremented by the same number.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Exposure.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Exposure.census","title":"<code>laser.generic.Exposure.census(model, tick)</code>","text":"<p>Aggregate exposed counts into patches at the given tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.census--parameters","title":"Parameters","text":"<p>model : object     LASER model with <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.census--notes","title":"Notes","text":"<ul> <li>At tick 0, exposed counts are computed from the population and written   to <code>patches.exposed</code>.</li> <li>For a single patch, exposed agents are counted globally.</li> <li>For multiple patches, exposed agents are distributed according to their   <code>nodeid</code>.</li> <li>In all cases, values are copied into <code>patches.exposed_test</code> for   validation/debugging and carried forward to tick+1.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Exposure.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Exposure.on_birth","title":"<code>laser.generic.Exposure.on_birth(model, _tick, istart, iend)</code>","text":"<p>Reset exposure timers for newborn agents.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.on_birth--parameters","title":"Parameters","text":"<p>model : object     LASER model containing the population. _tick : int     Current simulation tick (unused). istart : int or ndarray of int64     Start index of newborns (if slice mode), or array of agent indices     (if random-access mode). iend : int or None     End index of newborns (exclusive). If None, <code>istart</code> is treated as     an array of indices.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.on_birth--notes","title":"Notes","text":"<ul> <li>Newborns are set to not exposed: <code>etimer = 0</code>.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Exposure.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Exposure.plot","title":"<code>laser.generic.Exposure.plot(fig=None)</code>","text":"<p>Plot the distribution of exposures by age.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     A Matplotlib Figure. If None, a new figure is created.</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.plot--yields","title":"Yields","text":"<p>None     This is a generator that currently yields once (<code>None</code>).</p>"},{"location":"reference/laser/generic/#laser.generic.Exposure.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign","title":"<code>laser.generic.ImmunizationCampaign(model, period, coverage, age_lower, age_upper, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that applies an immunization campaign over an age band.</p> <p>On eligible ticks, all agents with age in [age_lower, age_upper) are considered and immunized with probability <code>coverage</code>. Susceptibles become immune (<code>population.susceptibility[idx] = 0</code>). This aligns with the campaign-style immunization component described in the <code>laser-generic</code> docs.</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":"<p>Initialize an ImmunizationCampaign instance.</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between campaign events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age_lower</code> <code>int</code> <p>Inclusive lower bound of target age band (ticks).</p> required <code>age_upper</code> <code>int</code> <p>Exclusive upper bound of target age band (ticks). Must be &gt; age_lower.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run campaigns. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run campaigns. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between campaign events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age_lower</code> <code>int</code> <p>Inclusive lower age (ticks).</p> <code>age_upper</code> <code>int</code> <p>Exclusive upper age (ticks).</p> <code>start</code> <code>int</code> <p>First campaign tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last campaign tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are out of range (e.g., period &lt; 1, coverage not in [0, 1],         age bounds invalid).</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__","title":"<code>laser.generic.ImmunizationCampaign.__call__(model, tick)</code>","text":"<p>Apply the immunization campaign at the given tick, if eligible.</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":"<p>Triggers when</p> <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> <p>On each event</p> <ul> <li>Agents with age in [age_lower, age_upper) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.patches</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.plot","title":"<code>laser.generic.ImmunizationCampaign.plot(fig=None)</code>","text":"<p>Placeholder for campaign visualization.</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.ImmunizationCampaign.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents","title":"<code>laser.generic.Infect_Random_Agents(model, verbose=False)</code>","text":"<p>A LASER model component that introduces random infections into the population at regular intervals. This is typically used to simulate importation events or background infection pressure.</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":"<p>Initialize an Infect_Random_Agents instance.</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model object that contains the population, patches, and parameters. The following attributes must exist in <code>model.params</code>:   - importation_period (int): Number of ticks between each infection event.   - importation_count (int): Number of agents to infect per event.   - nticks (int): Total number of ticks in the simulation.   - importation_start (int, optional): First tick to introduce infections.     Defaults to 0 if not provided.   - importation_end (int, optional): Last tick to introduce infections.     Defaults to nticks if not provided.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model object used by the component.</p> <code>period</code> <code>int</code> <p>Number of ticks between infection events.</p> <code>count</code> <code>int</code> <p>Number of agents infected at each event.</p> <code>start</code> <code>int</code> <p>First tick to apply infections.</p> <code>end</code> <code>int</code> <p>Last tick to apply infections.</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__","title":"<code>laser.generic.Infect_Random_Agents.__call__(model, tick)</code>","text":"<p>Introduce random infections into the population at the given tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":"<p>Infections are seeded if</p> <ul> <li>The current tick is greater than or equal to <code>start</code>.</li> <li>The tick falls on a multiple of <code>period</code> (relative to <code>start</code>).</li> <li>The tick is less than <code>end</code>.</li> </ul> <p>This updates both the agent-level infections and, if present, the test arrays in <code>model.patches</code> for validation.</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model containing the population and patches.</p> required <code>tick</code> <code>int</code> <p>The current tick (time step) of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.plot","title":"<code>laser.generic.Infect_Random_Agents.plot(fig=None)</code>","text":"<p>Placeholder for visualization of infection events.</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to plot into. If None, no plot is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infect_Random_Agents.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infection","title":"<code>laser.generic.Infection(model, verbose=False)</code>","text":"<p>LASER component for managing infections in an SIR-style model.</p> <p>Each agent has an <code>itimer</code> (infectious timer). When <code>itimer &gt; 0</code>, the agent is infectious. On each tick, <code>itimer</code> is decremented. When it reaches zero, the agent transitions to the recovered state (<code>state=3</code>).</p>"},{"location":"reference/laser/generic/#laser.generic.Infection--glossary","title":"Glossary","text":"<p>Initialize the Infection component.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection--parameters","title":"Parameters","text":"<p>model : object     LASER model containing:       * <code>population</code> with attributes <code>count</code> and method         <code>add_scalar_property(name, dtype, default)</code>       * <code>patches</code> with method         <code>add_vector_property(name, length, dtype)</code>       * <code>params.nticks</code> (int): number of simulation ticks verbose : bool, optional     If True, enable verbose output. Default is False.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection--side-effects","title":"Side Effects","text":"<ul> <li>Adds a scalar property <code>itimer</code> (dtype=uint16, default=0) to the population.</li> <li>Adds a vector property <code>recovered</code> (dtype=uint32) to the patches.</li> <li>Initializes all infection timers to zero.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Infection--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infection.__call__","title":"<code>laser.generic.Infection.__call__(model, tick)</code>","text":"<p>Update infection timers and patch-level case/recovery counts.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.__call__--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.__call__--notes","title":"Notes","text":"<ul> <li>Decrements <code>itimer</code> for all infectious agents.</li> <li>Agents whose <code>itimer</code> reaches 0 transition to recovered (<code>state=3</code>).</li> <li>Patch-level accounting:</li> <li><code>patches.cases_test[t+1]</code> is decremented by number of transitions.</li> <li><code>patches.recovered_test[t+1]</code> is incremented by the same number.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Infection.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infection.census","title":"<code>laser.generic.Infection.census(model, tick)</code>","text":"<p>Aggregate recovered counts into patches at the given tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.census--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.census--notes","title":"Notes","text":"<ul> <li>At tick 0, recovered counts are computed from the population and written   to <code>patches.recovered</code>.</li> <li>Recovery condition:</li> <li>With etimers: susceptibility=0, etimer=0, itimer=0</li> <li>Without etimers: susceptibility=0, itimer=0</li> <li>For a single patch, recovered agents are counted globally.</li> <li>For multiple patches, counts are distributed by agent <code>nodeid</code>.</li> <li>In all cases, values are copied into <code>patches.recovered_test</code> and carried   forward to tick+1.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Infection.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infection.on_birth","title":"<code>laser.generic.Infection.on_birth(model, _tick, istart, iend)</code>","text":"<p>Reset infection timers for newborn agents.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.on_birth--parameters","title":"Parameters","text":"<p>model : object     LASER model containing the population. _tick : int     Current simulation tick (unused). istart : int or ndarray of int64     Start index of newborns (if slice mode), or array of agent indices     (if random-access mode). iend : int or None     End index of newborns (exclusive). If None, <code>istart</code> is treated as     an array of indices.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.on_birth--notes","title":"Notes","text":"<ul> <li>Newborns are initialized with <code>itimer=0</code> (not infectious).</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Infection.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Infection.plot","title":"<code>laser.generic.Infection.plot(fig=None)</code>","text":"<p>Plot the distribution of infections by age.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     A Matplotlib Figure. If None, a new figure is created.</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.plot--yields","title":"Yields","text":"<p>None     This is a generator that currently yields once (<code>None</code>).</p>"},{"location":"reference/laser/generic/#laser.generic.Infection.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model","title":"<code>laser.generic.Model(scenario, parameters, name='generic')</code>","text":"<p>A LASER simulation model for generic disease dynamics.</p> <p>The <code>Model</code> manages:   - Patch-level populations and their attributes.   - Agent-level population initialization.   - Integration of components (e.g., Births, Infection, Immunization).   - Execution of simulation ticks via <code>run()</code>.   - Recording of metrics and plotting/visualization utilities.</p> <p>Typical usage: <pre><code>scenario = pd.DataFrame({\"population\": [1000, 500], \"latitude\": [...], \"longitude\": [...]})\nparams = PropertySet({\"nticks\": 100, \"seed\": 123, \"verbose\": True})\nmodel = Model(scenario, params)\nmodel.components = [Births, Infection, ImmunizationCampaign]\nmodel.run()\nmodel.visualize(pdf=True)\n</code></pre></p>"},{"location":"reference/laser/generic/#laser.generic.Model--glossary","title":"Glossary","text":"<p>Initialize the model with a scenario and simulation parameters.</p>"},{"location":"reference/laser/generic/#laser.generic.Model--parameters","title":"Parameters","text":"<p>scenario : pd.DataFrame     Patch-level data. Must include at least:     - <code>population</code>: initial population per patch.     - <code>latitude</code>: latitude coordinate.     - <code>longitude</code>: longitude coordinate.     May also include optional columns like <code>geometry</code>. parameters : PropertySet     Simulation parameters. Must include:     - <code>nticks</code> (int): number of simulation ticks.     - <code>seed</code> (int, optional): RNG seed.     - <code>verbose</code> (bool, optional): enable verbose logging. name : str, optional     Name of the model. Default is \"generic\".</p>"},{"location":"reference/laser/generic/#laser.generic.Model--side-effects","title":"Side Effects","text":"<ul> <li>Seeds the random number generator.</li> <li>Initializes patches and population.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Model--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model.components","title":"<code>laser.generic.Model.components</code>  <code>property</code> <code>writable</code>","text":"<p>Retrieve the list of model components currently configured.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.components--returns","title":"Returns","text":"<p>list     List of component classes used in the model.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.components--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model.__call__","title":"<code>laser.generic.Model.__call__(model, tick)</code>","text":"<p>Advance patch populations one tick forward.</p> <p>Copies population counts from tick <code>t</code> to tick <code>t+1</code>. Components such as births or mortality may then update these values.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.__call__--parameters","title":"Parameters","text":"<p>model : Model     The current model instance. tick : int     Current tick index.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model.plot","title":"<code>laser.generic.Model.plot(fig=None)</code>","text":"<p>Yield three plots for model visualization:</p> <ol> <li>A scatter plot of scenario patches by location and population.</li> <li>A histogram of day-of-birth values for the initial population.    (requires that <code>population.dob</code> exists, e.g. via a Births component).</li> <li>A pie chart of cumulative update phase timings.</li> </ol>"},{"location":"reference/laser/generic/#laser.generic.Model.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     An existing matplotlib Figure. If None, a new figure is created.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.plot--yields","title":"Yields","text":"<p>None     Each <code>yield</code> produces one plot, so iterating this generator     produces three figures sequentially.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model.run","title":"<code>laser.generic.Model.run()</code>","text":"<p>Execute the model simulation.</p> <p>For each tick (0..nticks-1):   - Run all censuses (recording metrics).   - Run all phases (update components).   - Record execution times per census/phase.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.run--glossary","title":"Glossary","text":"<p>After completion</p> <ul> <li>Records <code>self.metrics</code>, <code>self.tstart</code>, and <code>self.tfinish</code>.</li> <li>Prints a timing summary if verbose mode is enabled.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Model.run--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model.run--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model.run--attributes-set","title":"Attributes Set","text":"<p>tstart : datetime     Start time of execution. tfinish : datetime     End time of execution. metrics : list     List of timing metrics (per tick, per phase).</p>"},{"location":"reference/laser/generic/#laser.generic.Model.run--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Model.visualize","title":"<code>laser.generic.Model.visualize(pdf=True)</code>","text":"<p>Generate visualizations for all components.</p>"},{"location":"reference/laser/generic/#laser.generic.Model.visualize--parameters","title":"Parameters","text":"<p>pdf : bool, optional     If True (default), save plots to a PDF file named     \" .pdf\".     If False, display plots interactively with <code>plt.show()</code>."},{"location":"reference/laser/generic/#laser.generic.Model.visualize--side-effects","title":"Side Effects","text":"<ul> <li>Saves a PDF file when <code>pdf=True</code>.</li> <li>Calls <code>plt.show()</code> when <code>pdf=False</code>.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Model.visualize--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization","title":"<code>laser.generic.RoutineImmunization(model, period, coverage, age, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that updates immunity via routine immunization (RI).</p> <p>At eligible ticks, agents whose age (in ticks) falls within an RI window centered at <code>age</code> with half-width <code>period // 2</code> are sampled with probability <code>coverage</code> and made immune (by setting <code>population.susceptibility[idx] = 0</code>).</p> <p>This component follows the general component style in <code>laser-generic</code> and can be added to <code>Model.components</code>. See package documentation for details on the component pattern.</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":"<p>Initialize a RoutineImmunization instance.</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between RI events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age</code> <code>int</code> <p>Target age (in ticks) around which to immunize.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run RI. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run RI. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between RI events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age</code> <code>int</code> <p>Target age in ticks.</p> <code>start</code> <code>int</code> <p>First RI tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last RI tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>period &lt; 1</code>, <code>coverage</code> not in [0, 1], or <code>age &lt; 0</code>.</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__","title":"<code>laser.generic.RoutineImmunization.__call__(model, tick)</code>","text":"<p>Apply routine immunization at the given tick, if eligible.</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":"<p>An event fires when</p> <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> <p>On each event</p> <ul> <li>Agents with age in [age - period//2, age + period//2) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.patches</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.plot","title":"<code>laser.generic.RoutineImmunization.plot(fig=None)</code>","text":"<p>Placeholder for RI visualization.</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.RoutineImmunization.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Susceptibility","title":"<code>laser.generic.Susceptibility(model, verbose=False)</code>","text":"<p>A LASER model component representing the susceptibility of a population.</p> <p>This component adds a scalar property <code>susceptibility</code> to the population and a vector property to the patches. It tracks which agents are susceptible at any given tick and provides helper functions for updating these values.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility--glossary","title":"Glossary","text":"<p>Initialize the susceptibility component of the model.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility--parameters","title":"Parameters","text":"<p>model : object     A LASER model instance. Must have <code>population</code>, <code>patches</code>, and <code>params</code>     with the following:       * population.add_scalar_property(name, dtype, default)       * patches.add_vector_property(name, nticks, dtype)       * params.nticks (int) - number of simulation ticks. verbose : bool, optional     If True, enables verbose output. Default is False.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility--notes","title":"Notes","text":"<ul> <li>This method adds a scalar property <code>susceptibility</code> to each agent in   the population, initialized to <code>1</code> (susceptible).</li> <li>It also adds a vector property <code>susceptibility</code> to each patch, which   tracks aggregated susceptible counts over time.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Susceptibility.__call__","title":"<code>laser.generic.Susceptibility.__call__(model, tick)</code>","text":"<p>Make the component callable. Required for LASER component interface.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.__call__--parameters","title":"Parameters","text":"<p>model : object     The LASER model containing population and patches. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.__call__--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.__call__--notes","title":"Notes","text":"<p>This component does not perform per-tick updates. The method exists only to satisfy the LASER component interface.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Susceptibility.census","title":"<code>laser.generic.Susceptibility.census(model, tick)</code>","text":"<p>Aggregate susceptible counts into patches at the given tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.census--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.census--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.census--notes","title":"Notes","text":"<ul> <li>At tick 0, this computes susceptible counts from the population   and writes them into <code>patches.susceptibility</code>.</li> <li>For a single patch, counts are summed globally.</li> <li>For multiple patches, counts are distributed by agent <code>nodeid</code>.</li> <li>In all cases, values are copied into <code>patches.susceptibility_test</code>   for validation/debugging.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Susceptibility.on_birth","title":"<code>laser.generic.Susceptibility.on_birth(model, _tick, istart, iend)</code>","text":"<p>Handle the birth event by setting susceptibility of newborns.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.on_birth--parameters","title":"Parameters","text":"<p>model : object     LASER model containing the population. _tick : int     Current simulation tick (unused). istart : int or ndarray of int64     Start index of newborns (if slice mode), or array of agent indices (if random-access mode). iend : int or None     End index of newborns (exclusive). If None, <code>istart</code> is treated as     an index array for random-access updates.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.on_birth--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.on_birth--notes","title":"Notes","text":"<ul> <li>Newborns are set to susceptible (1).</li> <li>Uses either slice-based or random-access update functions.</li> </ul>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Susceptibility.plot","title":"<code>laser.generic.Susceptibility.plot(fig=None)</code>","text":"<p>Placeholder for plotting susceptibility distribution by age.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     A Matplotlib Figure to draw into. If None, a new figure would be created     in a full implementation.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.plot--yields","title":"Yields","text":"<p>None     The generator currently yields once (<code>None</code>). This is a placeholder     and should be replaced with actual plotting logic in the future.</p>"},{"location":"reference/laser/generic/#laser.generic.Susceptibility.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission","title":"<code>laser.generic.Transmission(model, verbose=False)</code>","text":"<p>A LASER-generic component that models inter-agent disease transmission within and between patches.</p> <p>This component calculates the force of infection at each time step using: - Agent state (infectious status) - Node-level infectious prevalence - Network-based movement between patches - Time-varying transmission modifiers (e.g., seasonality or biweekly scaling)</p> <p>It supports multiple transmission dynamics depending on the structure of the population (e.g., SI, SEIR).</p>"},{"location":"reference/laser/generic/#laser.generic.Transmission--glossary","title":"Glossary","text":"<p>Initialize the Transmission component and register per-patch properties.</p> <p>Adds the following properties: - <code>cases</code>: Total cumulative infections per patch per time step - <code>forces</code>: Force of infection for each patch (float32) - <code>incidence</code>: New infections per patch per time step - <code>doi</code>: Date of infection for each individual (set on infection)</p>"},{"location":"reference/laser/generic/#laser.generic.Transmission--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A LASER Model instance, which must expose <code>.patches</code>, <code>.population</code>, and <code>.params</code>.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints debug info during initialization (currently unused).</p> <code>False</code>"},{"location":"reference/laser/generic/#laser.generic.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.__call__","title":"<code>laser.generic.Transmission.__call__(model, tick)</code>","text":"<p>Compute and apply transmission dynamics for the current tick.</p> <p>This function: - Computes node-level contagion (infectious density) - Modifies contagion using a network matrix if present - Applies time-varying scalars (seasonality, biweekly modifiers) to beta - Calculates force of infection per patch - Samples new infections using Numba-accelerated kernels depending on model structure</p>"},{"location":"reference/laser/generic/#laser.generic.Transmission.__call__--glossary","title":"Glossary","text":"<p>Notes</p> <p>The appropriate infection update kernel is selected based on the presence of <code>etimer</code> or <code>itimer</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The LASER model instance.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required"},{"location":"reference/laser/generic/#laser.generic.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.census","title":"<code>laser.generic.Transmission.census(model, tick)</code>","text":"<p>Snapshot infectious counts into <code>cases_test</code> at tick <code>t</code> and propagate to tick <code>t+1</code>.</p> <p>This method: - Initializes <code>cases_test[t]</code> using individual infection status - Copies <code>cases_test[t]</code> into <code>cases_test[t+1]</code> to maintain continuity</p>"},{"location":"reference/laser/generic/#laser.generic.Transmission.census--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The LASER model instance.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required"},{"location":"reference/laser/generic/#laser.generic.Transmission.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.on_birth","title":"<code>laser.generic.Transmission.on_birth(model, _tick, istart, iend)</code>","text":"<p>Initialize <code>doi</code> (date of infection) for newborns.</p> <p>This birth handler sets the date-of-infection field to zero for all new individuals.</p>"},{"location":"reference/laser/generic/#laser.generic.Transmission.on_birth--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The LASER model.</p> required <code>_tick</code> <code>int</code> <p>The current tick (unused).</p> required <code>istart</code> <code>int</code> <p>Start index of new agents.</p> required <code>iend</code> <code>int</code> <p>End index of new agents (exclusive). If None, assumes single agent at <code>istart</code>.</p> required"},{"location":"reference/laser/generic/#laser.generic.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.plot","title":"<code>laser.generic.Transmission.plot(fig=None)</code>","text":"<p>Generate a 2x2 subplot figure showing cases and incidence over time.</p> <p>For the two most populous patches, this creates: - Line plot of <code>cases</code> over time - Line plot of <code>incidence</code> over time</p>"},{"location":"reference/laser/generic/#laser.generic.Transmission.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>An existing figure object to draw on. If None, a new figure is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/#laser.generic.Transmission.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#laser.generic.Transmission.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/__main__/","title":"laser.generic.main","text":""},{"location":"reference/laser/generic/__main__/#laser.generic.__main__","title":"<code>laser.generic.__main__</code>","text":"<p>Entrypoint module, in case you use <code>python -mlaser.generic</code>.</p> <p>Why does this file exist, and why main? For more info, read:</p> <ul> <li>https://www.python.org/dev/peps/pep-0338/</li> <li>https://docs.python.org/2/using/cmdline.html#cmdoption-m</li> <li>https://docs.python.org/3/using/cmdline.html#cmdoption-m</li> </ul>"},{"location":"reference/laser/generic/__main__/#laser.generic.__main__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/__main__/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/","title":"laser.generic.births","text":""},{"location":"reference/laser/generic/births/#laser.generic.births","title":"<code>laser.generic.births</code>","text":"<p>This module defines the Births component, which is responsible for simulating births in a population model.</p> <p>Example:</p> <pre><code>model = YourModelClass()\nbirths = Births(model)\nbirths(model, tick)\nbirths.plot()\n</code></pre>"},{"location":"reference/laser/generic/births/#laser.generic.births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births","title":"<code>laser.generic.births.Births(model, verbose=False)</code>","text":"<p>A component to handle the birth events in a model. Requires a model with a <code>population</code> attribute that has a <code>dob</code> attribute. It calculates the number of births based on the model's parameters and updates the population accordingly. It also provides methods to plot birth statistics.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":"<p>Attributes:</p> Name Type Description <code>model</code> <p>The model instance containing population and parameters.</p> <code>verbose</code> <code>bool</code> <p>Flag to enable verbose output. Default is False.</p> <code>initializers</code> <code>list</code> <p>List of initializers to be called on birth events.</p> <code>metrics</code> <code>DataFrame</code> <p>DataFrame to holding timing metrics for initializers.</p> <p>Initialize the Births component.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The model object which must have a <code>population</code> attribute.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the model does not have a <code>population</code> attribute.</p> <code>AssertionError</code> <p>If the model's population does not have a <code>dob</code> attribute.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.initializers","title":"<code>laser.generic.births.Births.initializers</code>  <code>property</code>","text":"<p>Returns the initializers to call on new agent births.</p> <p>This method retrieves the initializers that are used to set up the initial state or configuration for agents at birth.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.initializers--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of initializers - instances of objects with an <code>on_birth</code> method.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.initializers--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.metrics","title":"<code>laser.generic.births.Births.metrics</code>  <code>property</code>","text":"<p>Returns the timing metrics for the births initializers.</p> <p>This method retrieves the timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.metrics--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A Pandas DataFrame of timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.metrics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.__call__","title":"<code>laser.generic.births.Births.__call__(model, tick)</code>","text":"<p>Adds new agents to each patch based on expected daily births calculated from CBR. Calls each of the registered initializers for the newborns.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.__call__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model containing patches, population, and parameters.</p> required <code>tick</code> <code>int</code> <p>The current time step in the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>This method performs the following steps</p> <ol> <li>Calculates the day of the year (doy) and the current year based on the tick.</li> <li>On the first day of the year, it generates annual births for each patch using a Poisson distribution.</li> <li>Calculates the number of births for the current day.</li> <li>Adds the newborns to the population and sets their date of birth.</li> <li>Assigns node IDs to the newborns.</li> <li>Calls any additional initializers for the newborns and records the timing of these initializations.</li> <li>Updates the population counts for the next tick with the new births.</li> </ol>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.plot","title":"<code>laser.generic.births.Births.plot(fig=None)</code>","text":"<p>Plots the births in the top 5 most populous patches and a pie chart of birth initializer times.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure object. If None, a new figure will be created. Defaults to None.</p> <code>None</code> <p>Yields:</p> Name Type Description <code>None</code> <code>Any</code> <p>This function yields twice to allow for intermediate plotting steps.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop","title":"<code>laser.generic.births.Births_ConstantPop(model, verbose=False)</code>","text":"<p>Handles births in models with a constant population size (births == deaths).</p> <p>This component ensures that the total population remains constant over time by generating daily birth counts that exactly match the expected mortality under a given crude birth rate (CBR). Each birth results in the creation of a new agent with a default susceptible state and a birth timestamp.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":"<p>Key responsibilities</p> <ul> <li>Stochastic generation of new births per patch and time step.</li> <li>Initialization of new agents with appropriate state and properties.</li> <li>Invocation of registered birth-time initializers.</li> <li>Real-time updates to reporting channels (e.g. SEIR counts).</li> </ul> <p>The component assumes that deaths are handled implicitly by replacing expired agents with newly born agents.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":"<p>Expected parameters</p> <ul> <li><code>cbr</code>: Crude birth rate per 1000 people per year (float).</li> <li><code>nticks</code>: Number of time steps in the simulation (int).</li> </ul> <p>Initialize the Births_ConstantPop component.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A Model instance with attributes: - <code>params.cbr</code>: Annual crude birth rate. - <code>params.nticks</code>: Number of time steps. - <code>population</code>: An agent population object. - <code>patches</code>: A patch manager with population counts. - <code>prng</code>: A random number generator supporting <code>.poisson</code> and <code>.exponential</code>.</p> required <code>verbose</code> <code>bool</code> <p>Enable detailed logging if True.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the model lacks a <code>population</code> or <code>dob</code> attribute.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.initializers","title":"<code>laser.generic.births.Births_ConstantPop.initializers</code>  <code>property</code>","text":"<p>Returns the initializers to call on new agent births.</p> <p>This method retrieves the initializers that are used to set up the initial state or configuration for agents at birth.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.initializers--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of initializers - instances of objects with an <code>on_birth</code> method.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.initializers--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.metrics","title":"<code>laser.generic.births.Births_ConstantPop.metrics</code>  <code>property</code>","text":"<p>Returns the timing metrics for the births initializers.</p> <p>This method retrieves the timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.metrics--glossary","title":"Glossary","text":"<p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>A Pandas DataFrame of timing metrics for the births initializers.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.metrics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.__call__","title":"<code>laser.generic.births.Births_ConstantPop.__call__(model, tick)</code>","text":"<p>Execute births for a given time step.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.__call__--glossary","title":"Glossary","text":"<p>For each patch</p> <ul> <li>Determine the number of new agents to birth using a Poisson draw.</li> <li>Assign each agent a birth date and susceptible state.</li> <li>Update SEIR reporting channels to reflect changes.</li> <li>Run all registered <code>on_birth</code> initializers.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick (int).</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.plot","title":"<code>laser.generic.births.Births_ConstantPop.plot(fig=None)</code>","text":"<p>Visualize birth activity and initializer performance.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.plot--glossary","title":"Glossary","text":"<p>Generates two plots</p> <ol> <li>Line plot: Population and birth counts for top 5 most populous patches.</li> <li>Pie chart: Cumulative time spent in each <code>on_birth</code> initializer.</li> </ol> <p>This method is a generator; call <code>next()</code> twice to display both plots.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to reuse. Defaults to new figure.</p> <code>None</code> <p>Yields:</p> Type Description <code>Any</code> <p>None (plot visuals are side effects).</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate","title":"<code>laser.generic.births.Births_ConstantPop_VariableBirthRate(model, verbose=False)</code>","text":"<p>               Bases: <code>Births_ConstantPop</code></p> <p>Birth process with time-varying crude birth rate (CBR) while maintaining constant population.</p> <p>This component extends <code>Births_ConstantPop</code> by allowing the birth rate to vary over time, based on a schedule of crude birth rates (CBRs) defined in the model parameters.</p> <p>Unlike a traditional demographic model, this assumes a constant total population size by balancing births and deaths. The birth rate schedule determines the number of daily births (and therefore deaths) at each timestep.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":"<p>Attributes:</p> Name Type Description <code>model</code> <p>The simulation model, which must contain population and patch data.</p> <p>Initialize the Births_ConstantPop_VariableBirthRate component.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A <code>Model</code> object with <code>population</code>, <code>patches</code>, and <code>params</code> attributes. <code>params.cbr</code> must be a dictionary with:     - \"rates\": list or array of CBR values (per 1000 people per year).     - \"timesteps\": list or array of corresponding time ticks when rates change.</p> required <code>verbose</code> <code>bool</code> <p>If True, print verbose status updates. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the model lacks a <code>population</code> attribute.</p> <code>ValueError</code> <p>If <code>params.cbr</code> is missing or malformed.</p>"},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#laser.generic.births.Births_ConstantPop_VariableBirthRate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/births/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/cli/","title":"laser.generic.cli","text":""},{"location":"reference/laser/generic/cli/#laser.generic.cli","title":"<code>laser.generic.cli</code>","text":"<p>Module that contains the command line app.</p> <p>Why does this file exist, and why not put this in main?</p> <p>You might be tempted to import things from main later, but that will cause   problems: the code will get executed twice:</p> <ul> <li>When you run <code>python -mlaser.generic</code> python will execute     <code>__main__.py</code> as a script. That means there will not be any     <code>laser.generic.__main__</code> in <code>sys.modules</code>.</li> <li>When you import main it will get executed again (as a module) because     there\"s no <code>laser.generic.__main__</code> in <code>sys.modules</code>.</li> </ul> <p>Also see (1) from https://click.palletsprojects.com/en/stable/setuptools/</p>"},{"location":"reference/laser/generic/cli/#laser.generic.cli--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/cli/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/core/","title":"laser.generic.core","text":""},{"location":"reference/laser/generic/core/#laser.generic.core","title":"<code>laser.generic.core</code>","text":""},{"location":"reference/laser/generic/core/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/exposure/","title":"laser.generic.exposure","text":""},{"location":"reference/laser/generic/exposure/#laser.generic.exposure","title":"<code>laser.generic.exposure</code>","text":"<p>This module defines the Exposure class, which models the transition of individuals from being exposed (infected but not yet infectious) to becoming infectious.</p> <p>The component manages the <code>etimer</code> (exposed timer) for each agent, updates patch-level exposed/case counts, handles newborns, and provides simple visualization of exposure by age.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure","title":"<code>laser.generic.exposure.Exposure(model, verbose=False)</code>","text":"<p>LASER component representing the exposed (latent) state of a population.</p> <p>Each agent has an <code>etimer</code> (exposed timer). When <code>etimer &gt; 0</code>, the agent is in the exposed state. On each tick, <code>etimer</code> is decremented. When it reaches zero, the agent transitions to the infectious state, and its <code>itimer</code> (infectious timer) is initialized.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure--glossary","title":"Glossary","text":"<p>Initialize the Exposure component.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure--parameters","title":"Parameters","text":"<p>model : object     LASER model containing:       * <code>population</code> with attributes <code>count</code> and method         <code>add_scalar_property(name, dtype, default)</code>       * <code>patches</code> with method         <code>add_vector_property(name, length, dtype)</code>       * <code>params.nticks</code> (int): number of simulation ticks verbose : bool, optional     If True, enable verbose output. Default is False.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure--side-effects","title":"Side Effects","text":"<ul> <li>Adds a scalar property <code>etimer</code> (dtype=uint16, default=0) to the population.</li> <li>Adds a vector property <code>exposed</code> (dtype=uint32) to the patches.</li> <li>Initializes all etimers to zero.</li> </ul>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.__call__","title":"<code>laser.generic.exposure.Exposure.__call__(model, tick)</code>","text":"<p>Update exposed timers for the population at the given tick.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.__call__--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.__call__--notes","title":"Notes","text":"<ul> <li>Decrements <code>etimer</code> for all exposed agents.</li> <li>Agents whose <code>etimer</code> reaches 0 transition to infectious:</li> <li><code>itimer</code> is set to a draw from Normal(inf_mean, inf_sigma),     with minimum value 1.</li> <li><code>state</code> is set to 2 (infectious).</li> <li>Patch-level accounting:</li> <li><code>patches.exposed_test[t+1]</code> is decremented by the number of     transitions.</li> <li><code>patches.cases_test[t+1]</code> is incremented by the same number.</li> </ul>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.census","title":"<code>laser.generic.exposure.Exposure.census(model, tick)</code>","text":"<p>Aggregate exposed counts into patches at the given tick.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.census--parameters","title":"Parameters","text":"<p>model : object     LASER model with <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.census--notes","title":"Notes","text":"<ul> <li>At tick 0, exposed counts are computed from the population and written   to <code>patches.exposed</code>.</li> <li>For a single patch, exposed agents are counted globally.</li> <li>For multiple patches, exposed agents are distributed according to their   <code>nodeid</code>.</li> <li>In all cases, values are copied into <code>patches.exposed_test</code> for   validation/debugging and carried forward to tick+1.</li> </ul>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.on_birth","title":"<code>laser.generic.exposure.Exposure.on_birth(model, _tick, istart, iend)</code>","text":"<p>Reset exposure timers for newborn agents.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.on_birth--parameters","title":"Parameters","text":"<p>model : object     LASER model containing the population. _tick : int     Current simulation tick (unused). istart : int or ndarray of int64     Start index of newborns (if slice mode), or array of agent indices     (if random-access mode). iend : int or None     End index of newborns (exclusive). If None, <code>istart</code> is treated as     an array of indices.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.on_birth--notes","title":"Notes","text":"<ul> <li>Newborns are set to not exposed: <code>etimer = 0</code>.</li> </ul>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.plot","title":"<code>laser.generic.exposure.Exposure.plot(fig=None)</code>","text":"<p>Plot the distribution of exposures by age.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     A Matplotlib Figure. If None, a new figure is created.</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.plot--yields","title":"Yields","text":"<p>None     This is a generator that currently yields once (<code>None</code>).</p>"},{"location":"reference/laser/generic/exposure/#laser.generic.exposure.Exposure.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/exposure/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/","title":"laser.generic.immunization","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization","title":"<code>laser.generic.immunization</code>","text":"<p>Immunization components for LASER models.</p> <p>These components introduce immunity into the agent population during a simulation.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization--notes","title":"Notes","text":"<ul> <li>Deployment is currently global (all patches). Future extensions may include:</li> <li>targeting by patch or lists of patches,</li> <li>patch-varying coverage,</li> <li>time-varying routine immunization (RI) coverage.</li> <li>The routine immunization window centers on the target age with width \u2248 period,   i.e., [age - period/2, age + period/2).</li> </ul>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign","title":"<code>laser.generic.immunization.ImmunizationCampaign(model, period, coverage, age_lower, age_upper, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that applies an immunization campaign over an age band.</p> <p>On eligible ticks, all agents with age in [age_lower, age_upper) are considered and immunized with probability <code>coverage</code>. Susceptibles become immune (<code>population.susceptibility[idx] = 0</code>). This aligns with the campaign-style immunization component described in the <code>laser-generic</code> docs.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":"<p>Initialize an ImmunizationCampaign instance.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between campaign events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age_lower</code> <code>int</code> <p>Inclusive lower bound of target age band (ticks).</p> required <code>age_upper</code> <code>int</code> <p>Exclusive upper bound of target age band (ticks). Must be &gt; age_lower.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run campaigns. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run campaigns. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between campaign events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age_lower</code> <code>int</code> <p>Inclusive lower age (ticks).</p> <code>age_upper</code> <code>int</code> <p>Exclusive upper age (ticks).</p> <code>start</code> <code>int</code> <p>First campaign tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last campaign tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are out of range (e.g., period &lt; 1, coverage not in [0, 1],         age bounds invalid).</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__","title":"<code>laser.generic.immunization.ImmunizationCampaign.__call__(model, tick)</code>","text":"<p>Apply the immunization campaign at the given tick, if eligible.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":"<p>Triggers when</p> <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> <p>On each event</p> <ul> <li>Agents with age in [age_lower, age_upper) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.patches</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.plot","title":"<code>laser.generic.immunization.ImmunizationCampaign.plot(fig=None)</code>","text":"<p>Placeholder for campaign visualization.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.ImmunizationCampaign.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization","title":"<code>laser.generic.immunization.RoutineImmunization(model, period, coverage, age, start=0, end=-1, verbose=False)</code>","text":"<p>A LASER component that updates immunity via routine immunization (RI).</p> <p>At eligible ticks, agents whose age (in ticks) falls within an RI window centered at <code>age</code> with half-width <code>period // 2</code> are sampled with probability <code>coverage</code> and made immune (by setting <code>population.susceptibility[idx] = 0</code>).</p> <p>This component follows the general component style in <code>laser-generic</code> and can be added to <code>Model.components</code>. See package documentation for details on the component pattern.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":"<p>Initialize a RoutineImmunization instance.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> with <code>population</code>, <code>patches</code>, and <code>params</code>. <code>params.nticks</code> must be defined.</p> required <code>period</code> <code>int</code> <p>Number of ticks between RI events. Must be &gt;= 1.</p> required <code>coverage</code> <code>float</code> <p>Per-event immunization probability in [0.0, 1.0].</p> required <code>age</code> <code>int</code> <p>Target age (in ticks) around which to immunize.</p> required <code>start</code> <code>int</code> <p>First tick (inclusive) to run RI. Default 0.</p> <code>0</code> <code>end</code> <code>int</code> <p>Last tick (exclusive) to run RI. If -1, defaults to <code>model.params.nticks</code>. Default -1.</p> <code>-1</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Default False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model instance.</p> <code>period</code> <code>int</code> <p>Ticks between RI events.</p> <code>coverage</code> <code>float</code> <p>Immunization probability at each event.</p> <code>age</code> <code>int</code> <p>Target age in ticks.</p> <code>start</code> <code>int</code> <p>First RI tick (inclusive).</p> <code>end</code> <code>int</code> <p>Last RI tick (exclusive).</p> <code>verbose</code> <code>bool</code> <p>Verbosity flag.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>period &lt; 1</code>, <code>coverage</code> not in [0, 1], or <code>age &lt; 0</code>.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__","title":"<code>laser.generic.immunization.RoutineImmunization.__call__(model, tick)</code>","text":"<p>Apply routine immunization at the given tick, if eligible.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":"<p>An event fires when</p> <p>tick &gt;= start and ((tick - start) % period == 0) and tick &lt; end</p> <p>On each event</p> <ul> <li>Agents with age in [age - period//2, age + period//2) are considered.</li> <li>A Binomial draw with probability <code>coverage</code> selects agents to immunize.</li> <li>Selected agents have <code>susceptibility</code> set to 0 (immune).</li> <li>If present, test arrays on <code>model.patches</code> are updated for validation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER model (unused; provided for signature parity).</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.plot","title":"<code>laser.generic.immunization.RoutineImmunization.plot(fig=None)</code>","text":"<p>Placeholder for RI visualization.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A Matplotlib Figure to draw into.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.RoutineImmunization.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window","title":"<code>laser.generic.immunization.immunize_in_age_window(model, lower, upper, coverage, tick)</code>","text":"<p>Immunize susceptible agents whose age is in [lower, upper).</p> <p>This function updates agent-level susceptibility and returns the corresponding node IDs for accounting or test-array updates.</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>LASER <code>Model</code> containing <code>population</code> with fields: - dob (array[int]): Agent date-of-birth ticks. - susceptibility (array[int|bool]): 1/True if susceptible, 0/False if immune. - nodeid (array[int]): Patch index per agent.</p> required <code>lower</code> <code>int</code> <p>Inclusive lower bound on age (in ticks). Clamped to &gt;= 0.</p> required <code>upper</code> <code>int</code> <p>Exclusive upper bound on age (in ticks). Must be &gt;= lower.</p> required <code>coverage</code> <code>float</code> <p>Probability in [0, 1] to immunize each eligible susceptible.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required <p>Returns:</p> Type Description <code>Optional[ndarray]</code> <p>np.ndarray | None: Array of <code>nodeid</code> for immunized agents, or None if none.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>upper &lt; lower</code> or <code>coverage</code> not in [0, 1].</p>"},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#laser.generic.immunization.immunize_in_age_window--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/immunization/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/","title":"laser.generic.importation","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation","title":"<code>laser.generic.importation</code>","text":"<p>This module defines Importation classes, which provide methods to import cases into a population during simulation.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch","title":"<code>laser.generic.importation.Infect_Agents_In_Patch(model, verbose=False)</code>","text":"<p>A LASER model component that introduces infections into specific patches of the population at regular intervals. This is useful for modeling geographically targeted importations or outbreaks.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":"<p>Initialize an Infect_Agents_In_Patch instance.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model object that contains the population, patches, and parameters. The following attributes must exist or may optionally exist in <code>model.params</code>:   - importation_period (int): Number of ticks between infection events.   - importation_count (int, optional): Number of agents to infect     per patch per event. Defaults to 1 if not provided.   - importation_patchlist (array-like of int, optional): Indices     of patches where infections will be seeded. Defaults to all patches     if not provided.   - importation_start (int, optional): First tick to apply infections.     Defaults to 0 if not provided.   - importation_end (int, optional): Last tick to apply infections.     Defaults to <code>nticks</code> if not provided.   - nticks (int): Total number of ticks in the simulation.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model used by this component.</p> <code>period</code> <code>int</code> <p>Number of ticks between infection events.</p> <code>count</code> <code>int</code> <p>Number of agents infected per patch at each event.</p> <code>patchlist</code> <code>ndarray</code> <p>List of patch indices to target with infections.</p> <code>start</code> <code>int</code> <p>First tick to apply infections.</p> <code>end</code> <code>int</code> <p>Last tick to apply infections.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__","title":"<code>laser.generic.importation.Infect_Agents_In_Patch.__call__(model, tick)</code>","text":"<p>Introduce infections into the specified patches at the given tick.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__--glossary","title":"Glossary","text":"<p>Infections are seeded if</p> <ul> <li>The current tick is greater than or equal to <code>start</code>.</li> <li>The tick falls on a multiple of <code>period</code> (relative to <code>start</code>).</li> <li>The tick is less than <code>end</code>.</li> </ul> <p>At each eligible tick, every patch in <code>patchlist</code> receives <code>count</code> infections via <code>seed_infections_in_patch</code>.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model containing the population and patches.</p> required <code>tick</code> <code>int</code> <p>The current tick (time step) of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.plot","title":"<code>laser.generic.importation.Infect_Agents_In_Patch.plot(fig=None)</code>","text":"<p>Placeholder for visualization of targeted patch infections.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to plot into. If None, no plot is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Agents_In_Patch.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents","title":"<code>laser.generic.importation.Infect_Random_Agents(model, verbose=False)</code>","text":"<p>A LASER model component that introduces random infections into the population at regular intervals. This is typically used to simulate importation events or background infection pressure.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":"<p>Initialize an Infect_Random_Agents instance.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model object that contains the population, patches, and parameters. The following attributes must exist in <code>model.params</code>:   - importation_period (int): Number of ticks between each infection event.   - importation_count (int): Number of agents to infect per event.   - nticks (int): Total number of ticks in the simulation.   - importation_start (int, optional): First tick to introduce infections.     Defaults to 0 if not provided.   - importation_end (int, optional): Last tick to introduce infections.     Defaults to nticks if not provided.</p> required <code>verbose</code> <code>bool</code> <p>If True, enables verbose output. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>model</code> <code>object</code> <p>The LASER model object used by the component.</p> <code>period</code> <code>int</code> <p>Number of ticks between infection events.</p> <code>count</code> <code>int</code> <p>Number of agents infected at each event.</p> <code>start</code> <code>int</code> <p>First tick to apply infections.</p> <code>end</code> <code>int</code> <p>Last tick to apply infections.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__","title":"<code>laser.generic.importation.Infect_Random_Agents.__call__(model, tick)</code>","text":"<p>Introduce random infections into the population at the given tick.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":"<p>Infections are seeded if</p> <ul> <li>The current tick is greater than or equal to <code>start</code>.</li> <li>The tick falls on a multiple of <code>period</code> (relative to <code>start</code>).</li> <li>The tick is less than <code>end</code>.</li> </ul> <p>This updates both the agent-level infections and, if present, the test arrays in <code>model.patches</code> for validation.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>object</code> <p>The LASER model containing the population and patches.</p> required <code>tick</code> <code>int</code> <p>The current tick (time step) of the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.plot","title":"<code>laser.generic.importation.Infect_Random_Agents.plot(fig=None)</code>","text":"<p>Placeholder for visualization of infection events.</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>A matplotlib Figure to plot into. If None, no plot is generated.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#laser.generic.importation.Infect_Random_Agents.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/importation/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/","title":"laser.generic.infection","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection","title":"<code>laser.generic.infection</code>","text":"<p>This module defines components for modeling infection dynamics in a LASER population.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection--classes","title":"Classes","text":"<p>Infection     Handles general infection-to-recovery transitions. Infection_SIS     Variant for SIS models, where recovered agents become susceptible again.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection","title":"<code>laser.generic.infection.Infection(model, verbose=False)</code>","text":"<p>LASER component for managing infections in an SIR-style model.</p> <p>Each agent has an <code>itimer</code> (infectious timer). When <code>itimer &gt; 0</code>, the agent is infectious. On each tick, <code>itimer</code> is decremented. When it reaches zero, the agent transitions to the recovered state (<code>state=3</code>).</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection--glossary","title":"Glossary","text":"<p>Initialize the Infection component.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection--parameters","title":"Parameters","text":"<p>model : object     LASER model containing:       * <code>population</code> with attributes <code>count</code> and method         <code>add_scalar_property(name, dtype, default)</code>       * <code>patches</code> with method         <code>add_vector_property(name, length, dtype)</code>       * <code>params.nticks</code> (int): number of simulation ticks verbose : bool, optional     If True, enable verbose output. Default is False.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection--side-effects","title":"Side Effects","text":"<ul> <li>Adds a scalar property <code>itimer</code> (dtype=uint16, default=0) to the population.</li> <li>Adds a vector property <code>recovered</code> (dtype=uint32) to the patches.</li> <li>Initializes all infection timers to zero.</li> </ul>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.__call__","title":"<code>laser.generic.infection.Infection.__call__(model, tick)</code>","text":"<p>Update infection timers and patch-level case/recovery counts.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.__call__--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.__call__--notes","title":"Notes","text":"<ul> <li>Decrements <code>itimer</code> for all infectious agents.</li> <li>Agents whose <code>itimer</code> reaches 0 transition to recovered (<code>state=3</code>).</li> <li>Patch-level accounting:</li> <li><code>patches.cases_test[t+1]</code> is decremented by number of transitions.</li> <li><code>patches.recovered_test[t+1]</code> is incremented by the same number.</li> </ul>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.census","title":"<code>laser.generic.infection.Infection.census(model, tick)</code>","text":"<p>Aggregate recovered counts into patches at the given tick.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.census--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.census--notes","title":"Notes","text":"<ul> <li>At tick 0, recovered counts are computed from the population and written   to <code>patches.recovered</code>.</li> <li>Recovery condition:</li> <li>With etimers: susceptibility=0, etimer=0, itimer=0</li> <li>Without etimers: susceptibility=0, itimer=0</li> <li>For a single patch, recovered agents are counted globally.</li> <li>For multiple patches, counts are distributed by agent <code>nodeid</code>.</li> <li>In all cases, values are copied into <code>patches.recovered_test</code> and carried   forward to tick+1.</li> </ul>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.on_birth","title":"<code>laser.generic.infection.Infection.on_birth(model, _tick, istart, iend)</code>","text":"<p>Reset infection timers for newborn agents.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.on_birth--parameters","title":"Parameters","text":"<p>model : object     LASER model containing the population. _tick : int     Current simulation tick (unused). istart : int or ndarray of int64     Start index of newborns (if slice mode), or array of agent indices     (if random-access mode). iend : int or None     End index of newborns (exclusive). If None, <code>istart</code> is treated as     an array of indices.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.on_birth--notes","title":"Notes","text":"<ul> <li>Newborns are initialized with <code>itimer=0</code> (not infectious).</li> </ul>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.plot","title":"<code>laser.generic.infection.Infection.plot(fig=None)</code>","text":"<p>Plot the distribution of infections by age.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     A Matplotlib Figure. If None, a new figure is created.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.plot--yields","title":"Yields","text":"<p>None     This is a generator that currently yields once (<code>None</code>).</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS","title":"<code>laser.generic.infection.Infection_SIS(model, verbose=False)</code>","text":"<p>LASER component for infection in an SIS model.</p> <p>Each agent has an <code>itimer</code>. When it reaches 0, the agent becomes susceptible again (<code>susceptibility[i] = 1</code>).</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS--glossary","title":"Glossary","text":"<p>Initialize the Infection_SIS component.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS--parameters","title":"Parameters","text":"<p>model : object     LASER model containing a population and parameters. verbose : bool, optional     If True, enable verbose output. Default is False.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS--side-effects","title":"Side Effects","text":"<ul> <li>Adds a scalar property <code>itimer</code> (dtype=uint16, default=0) to the population.</li> <li>Initializes all infection timers to zero.</li> </ul>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.__call__","title":"<code>laser.generic.infection.Infection_SIS.__call__(model, tick)</code>","text":"<p>Update infection timers for the population (SIS model).</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.__call__--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.__call__--notes","title":"Notes","text":"<ul> <li>Decrements <code>itimer</code> for all infectious agents.</li> <li>When <code>itimer</code> reaches 0, the agent becomes susceptible again   (<code>susceptibility=1</code>).</li> </ul>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.on_birth","title":"<code>laser.generic.infection.Infection_SIS.on_birth(model, _tick, istart, iend)</code>","text":"<p>Reset infection timers for newborn agents.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.on_birth--parameters","title":"Parameters","text":"<p>model : object     LASER model containing the population. _tick : int     Current simulation tick (unused). istart : int     Start index of newborns. iend : int     End index of newborns (exclusive).</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.on_birth--notes","title":"Notes","text":"<ul> <li>Newborns are initialized with <code>itimer=0</code>.</li> </ul>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.plot","title":"<code>laser.generic.infection.Infection_SIS.plot(fig=None)</code>","text":"<p>Plot the distribution of infections by age.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     A Matplotlib Figure. If None, a new figure is created.</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.plot--yields","title":"Yields","text":"<p>None     This is a generator that currently yields once (<code>None</code>).</p>"},{"location":"reference/laser/generic/infection/#laser.generic.infection.Infection_SIS.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/infection/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/","title":"laser.generic.model","text":""},{"location":"reference/laser/generic/model/#laser.generic.model","title":"<code>laser.generic.model</code>","text":"<p>This module defines a <code>Model</code> class for simulating classic \"generic\" compartmental disease models (SI, SIS, SIR, SEIR, ...). The model supports simple demographics (e.g., births, deaths, aging) and can simulate either a single population patch or multiple patches with an arbitrary connection structure.</p> <p>Imports: - datetime: For handling date and time operations. - click: For command-line interface utilities. - numpy as np: For numerical operations. - pandas as pd: For data handling and tabular reports. - laser.core.laserframe: Provides the LaserFrame class for structured data arrays. - laser.core.propertyset: Provides the PropertySet class for simulation parameters. - laser.core.random: Provides random number generator seeding utilities. - matplotlib: For plotting results. - tqdm: For progress bar visualization during runs.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model","title":"<code>laser.generic.model.Model(scenario, parameters, name='generic')</code>","text":"<p>A LASER simulation model for generic disease dynamics.</p> <p>The <code>Model</code> manages:   - Patch-level populations and their attributes.   - Agent-level population initialization.   - Integration of components (e.g., Births, Infection, Immunization).   - Execution of simulation ticks via <code>run()</code>.   - Recording of metrics and plotting/visualization utilities.</p> <p>Typical usage: <pre><code>scenario = pd.DataFrame({\"population\": [1000, 500], \"latitude\": [...], \"longitude\": [...]})\nparams = PropertySet({\"nticks\": 100, \"seed\": 123, \"verbose\": True})\nmodel = Model(scenario, params)\nmodel.components = [Births, Infection, ImmunizationCampaign]\nmodel.run()\nmodel.visualize(pdf=True)\n</code></pre></p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model--glossary","title":"Glossary","text":"<p>Initialize the model with a scenario and simulation parameters.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model--parameters","title":"Parameters","text":"<p>scenario : pd.DataFrame     Patch-level data. Must include at least:     - <code>population</code>: initial population per patch.     - <code>latitude</code>: latitude coordinate.     - <code>longitude</code>: longitude coordinate.     May also include optional columns like <code>geometry</code>. parameters : PropertySet     Simulation parameters. Must include:     - <code>nticks</code> (int): number of simulation ticks.     - <code>seed</code> (int, optional): RNG seed.     - <code>verbose</code> (bool, optional): enable verbose logging. name : str, optional     Name of the model. Default is \"generic\".</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model--side-effects","title":"Side Effects","text":"<ul> <li>Seeds the random number generator.</li> <li>Initializes patches and population.</li> </ul>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model.components","title":"<code>laser.generic.model.Model.components</code>  <code>property</code> <code>writable</code>","text":"<p>Retrieve the list of model components currently configured.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.components--returns","title":"Returns","text":"<p>list     List of component classes used in the model.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.components--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model.__call__","title":"<code>laser.generic.model.Model.__call__(model, tick)</code>","text":"<p>Advance patch populations one tick forward.</p> <p>Copies population counts from tick <code>t</code> to tick <code>t+1</code>. Components such as births or mortality may then update these values.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.__call__--parameters","title":"Parameters","text":"<p>model : Model     The current model instance. tick : int     Current tick index.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model.plot","title":"<code>laser.generic.model.Model.plot(fig=None)</code>","text":"<p>Yield three plots for model visualization:</p> <ol> <li>A scatter plot of scenario patches by location and population.</li> <li>A histogram of day-of-birth values for the initial population.    (requires that <code>population.dob</code> exists, e.g. via a Births component).</li> <li>A pie chart of cumulative update phase timings.</li> </ol>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     An existing matplotlib Figure. If None, a new figure is created.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.plot--yields","title":"Yields","text":"<p>None     Each <code>yield</code> produces one plot, so iterating this generator     produces three figures sequentially.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model.run","title":"<code>laser.generic.model.Model.run()</code>","text":"<p>Execute the model simulation.</p> <p>For each tick (0..nticks-1):   - Run all censuses (recording metrics).   - Run all phases (update components).   - Record execution times per census/phase.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.run--glossary","title":"Glossary","text":"<p>After completion</p> <ul> <li>Records <code>self.metrics</code>, <code>self.tstart</code>, and <code>self.tfinish</code>.</li> <li>Prints a timing summary if verbose mode is enabled.</li> </ul>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.run--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model.run--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model.run--attributes-set","title":"Attributes Set","text":"<p>tstart : datetime     Start time of execution. tfinish : datetime     End time of execution. metrics : list     List of timing metrics (per tick, per phase).</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.run--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#laser.generic.model.Model.visualize","title":"<code>laser.generic.model.Model.visualize(pdf=True)</code>","text":"<p>Generate visualizations for all components.</p>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.visualize--parameters","title":"Parameters","text":"<p>pdf : bool, optional     If True (default), save plots to a PDF file named     \" .pdf\".     If False, display plots interactively with <code>plt.show()</code>."},{"location":"reference/laser/generic/model/#laser.generic.model.Model.visualize--side-effects","title":"Side Effects","text":"<ul> <li>Saves a PDF file when <code>pdf=True</code>.</li> <li>Calls <code>plt.show()</code> when <code>pdf=False</code>.</li> </ul>"},{"location":"reference/laser/generic/model/#laser.generic.model.Model.visualize--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/model/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/","title":"laser.generic.models","text":""},{"location":"reference/laser/generic/models/#laser.generic.models","title":"<code>laser.generic.models</code>","text":""},{"location":"reference/laser/generic/models/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/","title":"laser.generic.models.SEIR","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR","title":"<code>laser.generic.models.SEIR</code>","text":"<p>Export required components for an SEIR model.</p> <p>Agents transition from Susceptible to Exposed upon infection, with an incubation duration. Agents transition from Exposed to Infectious after the incubation period and are infectious for a duration. Agents transition from Infectious to Recovered after the infectious period. Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Exposed","title":"<code>laser.generic.models.SEIR.Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1)</code>","text":"<p>Exposed Component for SEIR/SEIRS Models with Explicit Incubation Period</p> <p>This component handles the incubation phase in models where agents must transition from an 'exposed' (E) state to 'infectious' (I) after a delay. It supports custom incubation and infectious duration distributions and handles both initialization and per-tick dynamics.</p> <p>Responsibilities: - Initializes exposed individuals at time 0 (if provided in the scenario) - Assigns and tracks per-agent incubation timers (<code>etimer</code>) - Transitions agents from <code>EXPOSED</code> to <code>INFECTIOUS</code> when <code>etimer == 0</code> - Assigns new infection timers (<code>itimer</code>) upon becoming infectious - Updates patch-level EXPOSED (<code>E</code>) and INFECTIOUS case counts - Provides validation hooks for state and timer consistency</p> <p>Required Inputs: - <code>model.scenario.E</code>: initial count of exposed individuals per node (optional) - <code>expdurdist</code>: callable returning sampled incubation durations - <code>infdurdist</code>: callable returning sampled infectious durations - <code>expdurmin</code>: minimum incubation period (default 1 day) - <code>infdurmin</code>: minimum infectious period (default 1 day)</p> <p>Outputs: - <code>model.people.etimer</code>: agent-level incubation timer - <code>model.nodes.E[t, i]</code>: number of exposed individuals at time <code>t</code> in node <code>i</code> - <code>model.nodes.newly_infectious[t, i]</code>: number of newly infectious cases per node per day</p> <p>Validation: - Ensures consistency between individual states and <code>etimer</code> values - Ensures that agents becoming infectious have valid <code>itimer</code> values assigned - Prevents agents with expired <code>etimer</code> from remaining in EXPOSED state</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Exposed--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For each agent:     - Decrease <code>etimer</code>     - If <code>etimer == 0</code>, change state to <code>INFECTIOUS</code> and assign <code>itimer</code>     - Update <code>model.nodes.E</code> and <code>model.nodes.I</code> counts accordingly</p> <p>Plotting: The <code>plot()</code> method provides a time series of exposed individuals per node and total across all nodes.</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Exposed--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     Exposed(model, expdurdist, infdurdist),     SIR.Infectious(model, infdurdist),     ... ]</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Infectious","title":"<code>laser.generic.models.SEIR.Infectious(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious Component for SIR/SEIR Models (With Recovery to Immune)</p> <p>This component manages agents in the infectious state for models where infected individuals recover permanently (i.e., transition to a <code>RECOVERED</code> state without waning). It supports agent-level infection durations and patch-level tracking of recoveries over time.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) based on scenario input - Decrements <code>itimer</code> daily for infectious agents - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Updates patch-level state variables:     \u2022 <code>I[t, i]</code>: infectious count at tick <code>t</code> in node <code>i</code>     \u2022 <code>R[t, i]</code>: recovered count     \u2022 <code>recovered[t, i]</code>: number of recoveries during tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected individuals per patch - <code>infdurdist</code>: function returning infection durations - <code>infdurmin</code>: minimum infectious period (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: countdown timers per agent - <code>model.nodes.I[t]</code>, <code>.R[t]</code>: infectious and recovered counts per patch - <code>model.nodes.recovered[t]</code>: daily recoveries per patch</p> <p>Step Behavior: - Infectious agents decrement <code>itimer</code> - When <code>itimer == 0</code>, agent state is set to <code>RECOVERED</code> - Patch-level <code>I</code> and <code>R</code> are updated; <code>recovered</code> logs today's transitions</p> <p>Validation: - Ensures internal consistency between agent state and timer - Confirms agents with <code>itimer == 1</code> recover exactly one day later - Validates population conservation (<code>S + I + R = N</code>)</p> <p>Plotting: The <code>plot()</code> method shows per-node and total infectious counts across time.</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Infectious--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     SIR.Recovered(model),     ... ]</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Infectious.step","title":"<code>laser.generic.models.SEIR.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Infectious.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Infectious.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Recovered","title":"<code>laser.generic.models.SEIR.Recovered(model)</code>","text":"<p>Recovered Component for SIR/SEIR Models (Permanent Immunity)</p> <p>This component manages agents in the recovered state in models where immunity does not wane (i.e., once recovered, agents stay recovered permanently). It tracks the number of recovered individuals over time at the patch level, but performs no active transitions itself \u2014 recovery transitions must be handled by upstream components.</p> <p>Responsibilities: - Initializes agents as recovered if specified in <code>model.scenario.R</code> - Tracks per-patch recovered counts over time in <code>model.nodes.R</code> - Verifies consistency between agent state and aggregate recovered counts - Propagates recovered totals forward unchanged (unless modified by other components)</p> <p>Required Inputs: - <code>model.scenario.R</code>: number of initially recovered individuals per node</p> <p>Outputs: - <code>model.nodes.R[t, i]</code>: number of recovered individuals at tick <code>t</code> in node <code>i</code></p> <p>Step Behavior: - At each tick, carries forward:     R[t+1] = R[t] - This component does not change any agent's state or internal timers</p> <p>\ud83e\uddea Validation: - Ensures per-agent state matches aggregate <code>R</code> counts before and after each step - Detects accidental changes to recovered counts not explained by upstream logic</p> <p>Plotting: The <code>plot()</code> method shows per-node and total recovered counts over time.</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Recovered--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     Recovered(model),  # passive tracker, assumes recovery handled upstream ]</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Susceptible","title":"<code>laser.generic.models.SEIR.Susceptible(model)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Susceptible--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Susceptible--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission","title":"<code>laser.generic.models.SEIR.Transmission(model, expdurdist, expdurmin=1)</code>","text":"<p>Transmission Component for SEIR/SEIRS Models (S \u2192 E with Incubation Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>EXPOSED</code> in models where infection includes an incubation period before agents become infectious. It handles stochastic exposure based on per-node force of infection (FOI), and assigns individual incubation timers to newly exposed agents.</p> <p>Responsibilities: - Computes force of infection <code>\u03bb = \u03b2 * (I / N)</code> at each tick per node - Adjusts FOI using <code>model.network</code> for inter-node transmission coupling. Required but can be nullified by filling with all zeros. - Applies FOI to susceptible agents to determine exposure - Assigns incubation durations (<code>etimer</code>) to each newly exposed agent - Updates node-level counts for <code>S</code> and <code>E</code> and logs daily incidence</p> <p>Required Inputs: - <code>model.params.beta</code>: global transmission rate - <code>model.network</code>: [n x n] matrix for FOI migration - <code>expdurdist(tick, node)</code>: callable that samples the exposure/incubation duration distribution - <code>expdurmin</code>: minimum incubation period (default = 1)</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at tick <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new exposures per node per day - <code>model.people.etimer</code>: per-agent incubation countdown</p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Optionally applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Validates consistency between agent states and patch-level counts before and after tick - Confirms that <code>incidence[t] == E[t+1] - E[t]</code></p> <p>Plotting: The <code>plot()</code> method shows per-node FOI (<code>\u03bb</code>) trajectories over time.</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSE(model, expdurdist),     Exposed(model, ...),     InfectiousIR(model, ...),     Recovered(model), ]</p> <p>Initializes the TransmissionSE component.</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <p>Minimum incubation duration.</p> <code>1</code>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.VitalDynamics","title":"<code>laser.generic.models.SEIR.VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SEIR/SEIRS Models (Births and Deaths with S, E, I, R States)</p> <p>This component supports full vital dynamics in compartmental models that include an incubation stage (<code>EXPOSED</code>) in addition to infection and recovery.</p> <p>Responsibilities: - Applies daily age-dependent mortality across <code>S</code>, <code>E</code>, <code>I</code>, and <code>R</code> - Marks deceased agents as <code>DECEASED</code>, removing them from the simulation - Adds new agents as <code>SUSCEPTIBLE</code>, assigning age and expected lifespan - Updates per-tick, per-node counts for <code>S</code>, <code>E</code>, <code>I</code>, <code>R</code>, <code>births</code>, and <code>deaths</code></p> <p>Validation: - Ensures consistent agent transitions and patch-level flows - Confirms that changes in population reflect births minus deaths</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.VitalDynamics--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSEIR(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#laser.generic.models.SEIR.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIR/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/","title":"laser.generic.models.SEIRS","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS","title":"<code>laser.generic.models.SEIRS</code>","text":"<p>Export required components for an SEIRS model.</p> <p>Agents transition from Susceptible to Exposed upon infection, with an incubation duration. Agents transition from Exposed to Infectious after the incubation period and are infectious for a duration. Agents transition from Infectious to Recovered after the infectious period. Agents transition from Recovered back to Susceptible upon waning immunity after the waning duration</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Exposed","title":"<code>laser.generic.models.SEIRS.Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1)</code>","text":"<p>Exposed Component for SEIR/SEIRS Models with Explicit Incubation Period</p> <p>This component handles the incubation phase in models where agents must transition from an 'exposed' (E) state to 'infectious' (I) after a delay. It supports custom incubation and infectious duration distributions and handles both initialization and per-tick dynamics.</p> <p>Responsibilities: - Initializes exposed individuals at time 0 (if provided in the scenario) - Assigns and tracks per-agent incubation timers (<code>etimer</code>) - Transitions agents from <code>EXPOSED</code> to <code>INFECTIOUS</code> when <code>etimer == 0</code> - Assigns new infection timers (<code>itimer</code>) upon becoming infectious - Updates patch-level EXPOSED (<code>E</code>) and INFECTIOUS case counts - Provides validation hooks for state and timer consistency</p> <p>Required Inputs: - <code>model.scenario.E</code>: initial count of exposed individuals per node (optional) - <code>expdurdist</code>: callable returning sampled incubation durations - <code>infdurdist</code>: callable returning sampled infectious durations - <code>expdurmin</code>: minimum incubation period (default 1 day) - <code>infdurmin</code>: minimum infectious period (default 1 day)</p> <p>Outputs: - <code>model.people.etimer</code>: agent-level incubation timer - <code>model.nodes.E[t, i]</code>: number of exposed individuals at time <code>t</code> in node <code>i</code> - <code>model.nodes.newly_infectious[t, i]</code>: number of newly infectious cases per node per day</p> <p>Validation: - Ensures consistency between individual states and <code>etimer</code> values - Ensures that agents becoming infectious have valid <code>itimer</code> values assigned - Prevents agents with expired <code>etimer</code> from remaining in EXPOSED state</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Exposed--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For each agent:     - Decrease <code>etimer</code>     - If <code>etimer == 0</code>, change state to <code>INFECTIOUS</code> and assign <code>itimer</code>     - Update <code>model.nodes.E</code> and <code>model.nodes.I</code> counts accordingly</p> <p>Plotting: The <code>plot()</code> method provides a time series of exposed individuals per node and total across all nodes.</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Exposed--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     Exposed(model, expdurdist, infdurdist),     SIR.Infectious(model, infdurdist),     ... ]</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Infectious","title":"<code>laser.generic.models.SEIRS.Infectious(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1)</code>","text":"<p>Infectious Component for SIRS/SEIRS Models (Recovery with Waning Immunity)</p> <p>This component manages infectious individuals in models where recovery confers temporary immunity, after which agents become susceptible again (SIRS/SEIRS).</p> <p>Responsibilities: - Initializes infectious agents from <code>model.scenario.I</code> - Assigns and tracks infectious timers (<code>itimer</code>) per agent - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Assigns a waning immunity timer (<code>rtimer</code>) upon recovery - Updates patch-level state:     \u2022 <code>I[t, i]</code>: current infectious count     \u2022 <code>R[t, i]</code>: current recovered count     \u2022 <code>recovered[t, i]</code>: number of agents recovering on tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected agents per node - <code>infdurdist</code>: function that samples the infectious duration distribution - <code>wandurdist</code>: function that samples the waning immunity duration distribution - <code>infdurmin</code>: minimum infectious period (default = 1 day) - <code>wandurmin</code>: minimum duration of immunity (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: days remaining in the infectious state - <code>model.people.rtimer</code>: days remaining in the recovered state - <code>model.nodes.I</code>, <code>model.nodes.R</code>: counts per node per tick - <code>model.nodes.recovered[t]</code>: number of recoveries recorded on tick <code>t</code></p> <p>Step Behavior: - Infectious agents decrement their <code>itimer</code> - When <code>itimer == 0</code>, agents become recovered and receive an <code>rtimer</code> - Patch-level totals are updated - Downstream components (e.g., <code>Recovered</code>) handle <code>rtimer</code> countdown and eventual return to <code>SUSCEPTIBLE</code></p> <p>Validation: - Ensures timer consistency and population accounting - Confirms correct infectious-to-recovered transitions - Can be chained with recovery and waning components for full SIRS/SEIRS loops</p> <p>Plotting: Two plots are provided: 1. Infected counts per node 2. Total infected and recovered counts across time</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Infectious--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIRS(model, infdurdist, wandurdist),     Exposed(model, ...),     Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Infectious.step","title":"<code>laser.generic.models.SEIRS.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Infectious.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Infectious.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Recovered","title":"<code>laser.generic.models.SEIRS.Recovered(model, wandurdist, wandurmin=1)</code>","text":"<p>Recovered Component for SIRS/SEIRS Models (Waning Immunity)</p> <p>This component manages agents in the recovered state in models where immunity is temporary. It supports per-agent recovery timers, enabling individuals to return to the susceptible state after a configurable waning period. This is essential for SEIRS/SIRS model dynamics.</p> <p>Responsibilities: - Initializes agents in the <code>RECOVERED</code> state using <code>model.scenario.R</code> - Assigns <code>rtimer</code> values to track the duration of immunity - Decrements <code>rtimer</code> each tick; transitions agents to <code>SUSCEPTIBLE</code> when <code>rtimer == 0</code> - Updates patch-level counts:     \u2022 <code>R[t, i]</code>: number of recovered individuals in node <code>i</code> at time <code>t</code>     \u2022 <code>waned[t, i]</code>: number of agents who re-entered susceptibility on time step <code>t</code></p> <p>Required Inputs: - <code>model.scenario.R</code>: initial number of recovered individuals per node - <code>wandurdist</code>: a function sampling the waning immunity duration distribution - <code>wandurmin</code>: minimum duration of immunity (default = 1 time step)</p> <p>Outputs: - <code>model.people.rtimer</code>: per-agent countdown to immunity expiration - <code>model.nodes.R</code>: recovered count per patch per timestep - <code>model.nodes.waned</code>: number of immunity losses per patch per tick</p> <p>Step Behavior: - Agents with <code>state == RECOVERED</code> decrement <code>rtimer</code> - When <code>rtimer == 0</code>, they return to <code>SUSCEPTIBLE</code> - <code>R</code> and <code>S</code> counts are updated to reflect this transition - <code>waned[t]</code> logs the number of agents who lost immunity on time step <code>t</code></p> <p>Validation: - Ensures population conservation and consistency between agent states and patch totals - Detects unexpected changes in <code>R</code> or invalid transitions</p> <p>Plotting: The <code>plot()</code> method provides two views: 1. Per-node recovered trajectories 2. Total recovered and waned agents over time</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Recovered--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SEIRS.Infectious(model, infdurdist, wandurdist),     Exposed(model, ...),     RecoveredRS(model, wandurdist), ]</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Susceptible","title":"<code>laser.generic.models.SEIRS.Susceptible(model)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Susceptible--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Susceptible--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission","title":"<code>laser.generic.models.SEIRS.Transmission(model, expdurdist, expdurmin=1)</code>","text":"<p>Transmission Component for SEIR/SEIRS Models (S \u2192 E with Incubation Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>EXPOSED</code> in models where infection includes an incubation period before agents become infectious. It handles stochastic exposure based on per-node force of infection (FOI), and assigns individual incubation timers to newly exposed agents.</p> <p>Responsibilities: - Computes force of infection <code>\u03bb = \u03b2 * (I / N)</code> at each tick per node - Adjusts FOI using <code>model.network</code> for inter-node transmission coupling. Required but can be nullified by filling with all zeros. - Applies FOI to susceptible agents to determine exposure - Assigns incubation durations (<code>etimer</code>) to each newly exposed agent - Updates node-level counts for <code>S</code> and <code>E</code> and logs daily incidence</p> <p>Required Inputs: - <code>model.params.beta</code>: global transmission rate - <code>model.network</code>: [n x n] matrix for FOI migration - <code>expdurdist(tick, node)</code>: callable that samples the exposure/incubation duration distribution - <code>expdurmin</code>: minimum incubation period (default = 1)</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at tick <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new exposures per node per day - <code>model.people.etimer</code>: per-agent incubation countdown</p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Optionally applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Validates consistency between agent states and patch-level counts before and after tick - Confirms that <code>incidence[t] == E[t+1] - E[t]</code></p> <p>Plotting: The <code>plot()</code> method shows per-node FOI (<code>\u03bb</code>) trajectories over time.</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSE(model, expdurdist),     Exposed(model, ...),     InfectiousIR(model, ...),     Recovered(model), ]</p> <p>Initializes the TransmissionSE component.</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <p>Minimum incubation duration.</p> <code>1</code>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.VitalDynamics","title":"<code>laser.generic.models.SEIRS.VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SEIR/SEIRS Models (Births and Deaths with S, E, I, R States)</p> <p>This component supports full vital dynamics in compartmental models that include an incubation stage (<code>EXPOSED</code>) in addition to infection and recovery.</p> <p>Responsibilities: - Applies daily age-dependent mortality across <code>S</code>, <code>E</code>, <code>I</code>, and <code>R</code> - Marks deceased agents as <code>DECEASED</code>, removing them from the simulation - Adds new agents as <code>SUSCEPTIBLE</code>, assigning age and expected lifespan - Updates per-tick, per-node counts for <code>S</code>, <code>E</code>, <code>I</code>, <code>R</code>, <code>births</code>, and <code>deaths</code></p> <p>Validation: - Ensures consistent agent transitions and patch-level flows - Confirms that changes in population reflect births minus deaths</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.VitalDynamics--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSEIR(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#laser.generic.models.SEIRS.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SEIRS/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/","title":"laser.generic.models.SI","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI","title":"<code>laser.generic.models.SI</code>","text":"<p>Components for an SI model.</p> <p>Agents transition from Susceptible to Infectious upon infection. Agents remain in the Infectious state indefinitely (no recovery).</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious","title":"<code>laser.generic.models.SI.Infectious(model)</code>","text":"<p>Infectious Component for SI Models (No Recovery)</p> <p>This component manages the infectious state in SI-style epidemic models where agents remain infectious indefinitely. It is appropriate for use in models without a recovered or removed state (i.e., no <code>R</code> compartment).</p> <p>Responsibilities: - Initializes agents as infectious based on <code>model.scenario.I</code> - Tracks the number of infectious individuals (<code>I</code>) in each patch over time - Maintains per-tick, per-node counts in <code>model.nodes.I</code> - Validates consistency between agent states and patch-level totals</p> <p>Required Inputs: - <code>model.scenario.I</code>: array of initial infected counts per patch - <code>model.people.state</code>: infection state per agent - <code>model.people.nodeid</code>: patch assignment per agent - <code>model.params.nticks</code>: number of timesteps to simulate</p> <p>Outputs: - <code>model.nodes.I[t, i]</code>: number of infectious individuals in node <code>i</code> at time <code>t</code></p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For each timestep <code>t</code>, this component copies:     I[t+1] = I[t] (No recovery or removal; new infections may be added externally.)</p> <p>Validation: - Ensures that patch-level infectious counts (<code>model.nodes.I</code>) match the agent-level state - Asserts that the sum of <code>S</code> and <code>I</code> matches total population at initialization - Validates that infected counts do not change unexpectedly (unless altered by another component)</p> <p>Plotting: The <code>plot()</code> method shows the number of infectious agents per patch and in total across time.</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousSI(model),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious.step","title":"<code>laser.generic.models.SI.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Infectious.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Susceptible","title":"<code>laser.generic.models.SI.Susceptible(model)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Susceptible--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Susceptible--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Transmission","title":"<code>laser.generic.models.SI.Transmission(model)</code>","text":"<p>Transmission Component for SI-Style Models (S \u2192 I Only, No Recovery)</p> <p>This component simulates the transmission process in simple epidemic models where agents move from the <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> state and remain infectious indefinitely. It computes the force of infection (FOI) for each patch and applies it stochastically to susceptible agents.</p> <p>Responsibilities: - Computes per-node force of infection (<code>\u03bb</code>) at each tick:     \u03bb = \u03b2 * (I / N), with spatial coupling via a migration matrix - Applies probabilistic infection to susceptible agents using <code>nb_transmission_step</code> - Updates per-node <code>S</code> and <code>I</code> counts accordingly - Tracks new infections (incidence) and FOI values per node and tick</p> <p>Required Inputs: - <code>model.nodes.I[t]</code>: number of infectious agents per node at tick <code>t</code> - <code>model.nodes.S[t]</code>: number of susceptible agents per node at tick <code>t</code> - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: matrix of spatial coupling between nodes</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: force of infection in node <code>i</code> at tick <code>t</code> - <code>model.nodes.incidence[t, i]</code>: number of new infections in node <code>i</code> at tick <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between state transitions and incidence records - Checks conservation of population in <code>S</code> and <code>I</code> states - Validates <code>incidence[t] == I[t+1] - I[t]</code></p> <p>Plotting: The <code>plot()</code> method displays the force of infection over time per node.</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Transmission--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSIX(model),     InfectiousSI(model), ]</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.VitalDynamics","title":"<code>laser.generic.models.SI.VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SI/SIS Models (Births and Deaths with S and I Only)</p> <p>This component implements demographic changes for simple SI or SIS models, where the only health states are <code>SUSCEPTIBLE</code> and <code>INFECTIOUS</code>. It supports both daily births and non-disease deaths using age-structured survival curves and crude birth rates (CBR).</p> <p>Responsibilities: - Applies daily mortality by checking agent <code>dod == tick</code> - Removes agents from <code>S</code> or <code>I</code> and marks them <code>DECEASED</code> - Adds new agents as <code>SUSCEPTIBLE</code> using <code>_births()</code>, sampling age and lifespan - Updates patch-level counts in <code>S</code>, <code>I</code>, <code>births</code>, and <code>deaths</code></p> <p>Validation: - Ensures birth and death counts match population changes - Verifies newborn states and death state transitions</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.VitalDynamics--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSI(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#laser.generic.models.SI.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SI/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/","title":"laser.generic.models.SIR","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR","title":"<code>laser.generic.models.SIR</code>","text":"<p>Export required components for an SIR model.</p> <p>Agents transition from Susceptible to Infectious upon infection and are infectious for a duration. Agents transition from Infectious to Recovered upon recovery. Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Infectious","title":"<code>laser.generic.models.SIR.Infectious(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious Component for SIR/SEIR Models (With Recovery to Immune)</p> <p>This component manages agents in the infectious state for models where infected individuals recover permanently (i.e., transition to a <code>RECOVERED</code> state without waning). It supports agent-level infection durations and patch-level tracking of recoveries over time.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) based on scenario input - Decrements <code>itimer</code> daily for infectious agents - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Updates patch-level state variables:     \u2022 <code>I[t, i]</code>: infectious count at tick <code>t</code> in node <code>i</code>     \u2022 <code>R[t, i]</code>: recovered count     \u2022 <code>recovered[t, i]</code>: number of recoveries during tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected individuals per patch - <code>infdurdist</code>: function returning infection durations - <code>infdurmin</code>: minimum infectious period (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: countdown timers per agent - <code>model.nodes.I[t]</code>, <code>.R[t]</code>: infectious and recovered counts per patch - <code>model.nodes.recovered[t]</code>: daily recoveries per patch</p> <p>Step Behavior: - Infectious agents decrement <code>itimer</code> - When <code>itimer == 0</code>, agent state is set to <code>RECOVERED</code> - Patch-level <code>I</code> and <code>R</code> are updated; <code>recovered</code> logs today's transitions</p> <p>Validation: - Ensures internal consistency between agent state and timer - Confirms agents with <code>itimer == 1</code> recover exactly one day later - Validates population conservation (<code>S + I + R = N</code>)</p> <p>Plotting: The <code>plot()</code> method shows per-node and total infectious counts across time.</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Infectious--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     SIR.Recovered(model),     ... ]</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Infectious.step","title":"<code>laser.generic.models.SIR.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Infectious.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Infectious.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Recovered","title":"<code>laser.generic.models.SIR.Recovered(model)</code>","text":"<p>Recovered Component for SIR/SEIR Models (Permanent Immunity)</p> <p>This component manages agents in the recovered state in models where immunity does not wane (i.e., once recovered, agents stay recovered permanently). It tracks the number of recovered individuals over time at the patch level, but performs no active transitions itself \u2014 recovery transitions must be handled by upstream components.</p> <p>Responsibilities: - Initializes agents as recovered if specified in <code>model.scenario.R</code> - Tracks per-patch recovered counts over time in <code>model.nodes.R</code> - Verifies consistency between agent state and aggregate recovered counts - Propagates recovered totals forward unchanged (unless modified by other components)</p> <p>Required Inputs: - <code>model.scenario.R</code>: number of initially recovered individuals per node</p> <p>Outputs: - <code>model.nodes.R[t, i]</code>: number of recovered individuals at tick <code>t</code> in node <code>i</code></p> <p>Step Behavior: - At each tick, carries forward:     R[t+1] = R[t] - This component does not change any agent's state or internal timers</p> <p>\ud83e\uddea Validation: - Ensures per-agent state matches aggregate <code>R</code> counts before and after each step - Detects accidental changes to recovered counts not explained by upstream logic</p> <p>Plotting: The <code>plot()</code> method shows per-node and total recovered counts over time.</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Recovered--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     Recovered(model),  # passive tracker, assumes recovery handled upstream ]</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Susceptible","title":"<code>laser.generic.models.SIR.Susceptible(model)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Susceptible--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Susceptible--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission","title":"<code>laser.generic.models.SIR.Transmission(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.VitalDynamics","title":"<code>laser.generic.models.SIR.VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SIR/SIRS Models (Births and Deaths with S, I, R States)</p> <p>This component manages demographic events for models with susceptible, infectious, and recovered compartments. It handles per-agent births and age-dependent deaths and adjusts patch-level state counts accordingly.</p> <p>Responsibilities: - Applies mortality by removing agents in <code>S</code>, <code>I</code>, or <code>R</code> with <code>dod == tick</code> - Marks deceased agents with <code>State.DECEASED</code> - Adds newborns as <code>SUSCEPTIBLE</code>, updating <code>S</code>, <code>births</code>, and <code>deaths</code> - Maintains per-tick, per-patch counts for <code>S</code>, <code>I</code>, <code>R</code>, <code>births</code>, <code>deaths</code></p> <p>Validation: - Verifies consistent population accounting across all compartments - Asserts correct transition timing for births and deaths</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.VitalDynamics--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSIR(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#laser.generic.models.SIR.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIR/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/","title":"laser.generic.models.SIRS","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS","title":"<code>laser.generic.models.SIRS</code>","text":"<p>Export required components for an SIRS model.</p> <p>Agents transition from Susceptible to Infectious upon infection. Agents transition from Infectious to Recovered upon recovery after the infectious duration. Agents transition from Recovered back to Susceptible upon waning immunity after the waning duration.</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Infectious","title":"<code>laser.generic.models.SIRS.Infectious(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1)</code>","text":"<p>Infectious Component for SIRS/SEIRS Models (Recovery with Waning Immunity)</p> <p>This component manages infectious individuals in models where recovery confers temporary immunity, after which agents become susceptible again (SIRS/SEIRS).</p> <p>Responsibilities: - Initializes infectious agents from <code>model.scenario.I</code> - Assigns and tracks infectious timers (<code>itimer</code>) per agent - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Assigns a waning immunity timer (<code>rtimer</code>) upon recovery - Updates patch-level state:     \u2022 <code>I[t, i]</code>: current infectious count     \u2022 <code>R[t, i]</code>: current recovered count     \u2022 <code>recovered[t, i]</code>: number of agents recovering on tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected agents per node - <code>infdurdist</code>: function that samples the infectious duration distribution - <code>wandurdist</code>: function that samples the waning immunity duration distribution - <code>infdurmin</code>: minimum infectious period (default = 1 day) - <code>wandurmin</code>: minimum duration of immunity (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: days remaining in the infectious state - <code>model.people.rtimer</code>: days remaining in the recovered state - <code>model.nodes.I</code>, <code>model.nodes.R</code>: counts per node per tick - <code>model.nodes.recovered[t]</code>: number of recoveries recorded on tick <code>t</code></p> <p>Step Behavior: - Infectious agents decrement their <code>itimer</code> - When <code>itimer == 0</code>, agents become recovered and receive an <code>rtimer</code> - Patch-level totals are updated - Downstream components (e.g., <code>Recovered</code>) handle <code>rtimer</code> countdown and eventual return to <code>SUSCEPTIBLE</code></p> <p>Validation: - Ensures timer consistency and population accounting - Confirms correct infectious-to-recovered transitions - Can be chained with recovery and waning components for full SIRS/SEIRS loops</p> <p>Plotting: Two plots are provided: 1. Infected counts per node 2. Total infected and recovered counts across time</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Infectious--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIRS(model, infdurdist, wandurdist),     Exposed(model, ...),     Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Infectious.step","title":"<code>laser.generic.models.SIRS.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Infectious.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Infectious.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Recovered","title":"<code>laser.generic.models.SIRS.Recovered(model, wandurdist, wandurmin=1)</code>","text":"<p>Recovered Component for SIRS/SEIRS Models (Waning Immunity)</p> <p>This component manages agents in the recovered state in models where immunity is temporary. It supports per-agent recovery timers, enabling individuals to return to the susceptible state after a configurable waning period. This is essential for SEIRS/SIRS model dynamics.</p> <p>Responsibilities: - Initializes agents in the <code>RECOVERED</code> state using <code>model.scenario.R</code> - Assigns <code>rtimer</code> values to track the duration of immunity - Decrements <code>rtimer</code> each tick; transitions agents to <code>SUSCEPTIBLE</code> when <code>rtimer == 0</code> - Updates patch-level counts:     \u2022 <code>R[t, i]</code>: number of recovered individuals in node <code>i</code> at time <code>t</code>     \u2022 <code>waned[t, i]</code>: number of agents who re-entered susceptibility on time step <code>t</code></p> <p>Required Inputs: - <code>model.scenario.R</code>: initial number of recovered individuals per node - <code>wandurdist</code>: a function sampling the waning immunity duration distribution - <code>wandurmin</code>: minimum duration of immunity (default = 1 time step)</p> <p>Outputs: - <code>model.people.rtimer</code>: per-agent countdown to immunity expiration - <code>model.nodes.R</code>: recovered count per patch per timestep - <code>model.nodes.waned</code>: number of immunity losses per patch per tick</p> <p>Step Behavior: - Agents with <code>state == RECOVERED</code> decrement <code>rtimer</code> - When <code>rtimer == 0</code>, they return to <code>SUSCEPTIBLE</code> - <code>R</code> and <code>S</code> counts are updated to reflect this transition - <code>waned[t]</code> logs the number of agents who lost immunity on time step <code>t</code></p> <p>Validation: - Ensures population conservation and consistency between agent states and patch totals - Detects unexpected changes in <code>R</code> or invalid transitions</p> <p>Plotting: The <code>plot()</code> method provides two views: 1. Per-node recovered trajectories 2. Total recovered and waned agents over time</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Recovered--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SEIRS.Infectious(model, infdurdist, wandurdist),     Exposed(model, ...),     RecoveredRS(model, wandurdist), ]</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Susceptible","title":"<code>laser.generic.models.SIRS.Susceptible(model)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Susceptible--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Susceptible--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission","title":"<code>laser.generic.models.SIRS.Transmission(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.VitalDynamics","title":"<code>laser.generic.models.SIRS.VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SIR/SIRS Models (Births and Deaths with S, I, R States)</p> <p>This component manages demographic events for models with susceptible, infectious, and recovered compartments. It handles per-agent births and age-dependent deaths and adjusts patch-level state counts accordingly.</p> <p>Responsibilities: - Applies mortality by removing agents in <code>S</code>, <code>I</code>, or <code>R</code> with <code>dod == tick</code> - Marks deceased agents with <code>State.DECEASED</code> - Adds newborns as <code>SUSCEPTIBLE</code>, updating <code>S</code>, <code>births</code>, and <code>deaths</code> - Maintains per-tick, per-patch counts for <code>S</code>, <code>I</code>, <code>R</code>, <code>births</code>, <code>deaths</code></p> <p>Validation: - Verifies consistent population accounting across all compartments - Asserts correct transition timing for births and deaths</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.VitalDynamics--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSIR(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#laser.generic.models.SIRS.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIRS/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/","title":"laser.generic.models.SIS","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS","title":"<code>laser.generic.models.SIS</code>","text":"<p>Export required components for an SIS model.</p> <p>Agents transition from Susceptible to Infectious upon infection and are infectious for a duration. Agents transition from Infectious back to Susceptible upon recovery.</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious","title":"<code>laser.generic.models.SIS.Infectious(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious Component for SIS Models (Infection + Recovery to Susceptible)</p> <p>This component handles the infectious state in SIS-style models, where agents recover from infection and immediately return to the susceptible pool. It supports per-agent infection durations and manages patch-level infectious counts over time.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) - Decrements <code>itimer</code> daily for infectious agents - Automatically transitions agents from <code>INFECTIOUS</code> to <code>SUSCEPTIBLE</code> when <code>itimer == 0</code> - Tracks per-day recoveries at the node level in <code>model.nodes.recovered</code> - Maintains node-level <code>I</code> and <code>S</code> counts with full timestep resolution</p> <p>Required Inputs: - <code>model.scenario.I</code>: initial number of infectious agents per patch - <code>infdurdist</code>: a callable function which samples the infectious duration distribution - <code>infdurmin</code>: the minimum infection period (default = 1 time step)</p> <p>Outputs: - <code>model.people.itimer</code>: per-agent infection countdown timer - <code>model.nodes.I[t, i]</code>: number of infectious individuals at tick <code>t</code> in node <code>i</code> - <code>model.nodes.recovered[t, i]</code>: number of recoveries at tick <code>t</code> in node <code>i</code></p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>At each tick: - Infectious agents decrement their <code>itimer</code> - Agents with <code>itimer == 0</code> are transitioned back to susceptible - <code>model.nodes.I</code> is updated accordingly - Recovered counts are recorded in <code>model.nodes.recovered</code></p> <p>Validation: - Ensures consistency between agent <code>state</code> and infection timer (<code>itimer</code>) - Validates <code>I</code> census against agent-level state before and after each tick</p> <p>Plotting: The <code>plot()</code> method displays both per-node and total infectious counts over time.</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIS(model, infdurdist),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious.step","title":"<code>laser.generic.models.SIS.Infectious.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Infectious.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Susceptible","title":"<code>laser.generic.models.SIS.Susceptible(model)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Susceptible--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Susceptible--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission","title":"<code>laser.generic.models.SIS.Transmission(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.VitalDynamics","title":"<code>laser.generic.models.SIS.VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SI/SIS Models (Births and Deaths with S and I Only)</p> <p>This component implements demographic changes for simple SI or SIS models, where the only health states are <code>SUSCEPTIBLE</code> and <code>INFECTIOUS</code>. It supports both daily births and non-disease deaths using age-structured survival curves and crude birth rates (CBR).</p> <p>Responsibilities: - Applies daily mortality by checking agent <code>dod == tick</code> - Removes agents from <code>S</code> or <code>I</code> and marks them <code>DECEASED</code> - Adds new agents as <code>SUSCEPTIBLE</code> using <code>_births()</code>, sampling age and lifespan - Updates patch-level counts in <code>S</code>, <code>I</code>, <code>births</code>, and <code>deaths</code></p> <p>Validation: - Ensures birth and death counts match population changes - Verifies newborn states and death state transitions</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.VitalDynamics--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSI(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#laser.generic.models.SIS.VitalDynamics--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/SIS/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/","title":"laser.generic.models.components","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components","title":"<code>laser.generic.models.components</code>","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Exposed","title":"<code>laser.generic.models.components.Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1)</code>","text":"<p>Exposed Component for SEIR/SEIRS Models with Explicit Incubation Period</p> <p>This component handles the incubation phase in models where agents must transition from an 'exposed' (E) state to 'infectious' (I) after a delay. It supports custom incubation and infectious duration distributions and handles both initialization and per-tick dynamics.</p> <p>Responsibilities: - Initializes exposed individuals at time 0 (if provided in the scenario) - Assigns and tracks per-agent incubation timers (<code>etimer</code>) - Transitions agents from <code>EXPOSED</code> to <code>INFECTIOUS</code> when <code>etimer == 0</code> - Assigns new infection timers (<code>itimer</code>) upon becoming infectious - Updates patch-level EXPOSED (<code>E</code>) and INFECTIOUS case counts - Provides validation hooks for state and timer consistency</p> <p>Required Inputs: - <code>model.scenario.E</code>: initial count of exposed individuals per node (optional) - <code>expdurdist</code>: callable returning sampled incubation durations - <code>infdurdist</code>: callable returning sampled infectious durations - <code>expdurmin</code>: minimum incubation period (default 1 day) - <code>infdurmin</code>: minimum infectious period (default 1 day)</p> <p>Outputs: - <code>model.people.etimer</code>: agent-level incubation timer - <code>model.nodes.E[t, i]</code>: number of exposed individuals at time <code>t</code> in node <code>i</code> - <code>model.nodes.newly_infectious[t, i]</code>: number of newly infectious cases per node per day</p> <p>Validation: - Ensures consistency between individual states and <code>etimer</code> values - Ensures that agents becoming infectious have valid <code>itimer</code> values assigned - Prevents agents with expired <code>etimer</code> from remaining in EXPOSED state</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Exposed--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For each agent:     - Decrease <code>etimer</code>     - If <code>etimer == 0</code>, change state to <code>INFECTIOUS</code> and assign <code>itimer</code>     - Update <code>model.nodes.E</code> and <code>model.nodes.I</code> counts accordingly</p> <p>Plotting: The <code>plot()</code> method provides a time series of exposed individuals per node and total across all nodes.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Exposed--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     Exposed(model, expdurdist, infdurdist),     SIR.Infectious(model, infdurdist),     ... ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Exposed--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIR","title":"<code>laser.generic.models.components.InfectiousIR(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious Component for SIR/SEIR Models (With Recovery to Immune)</p> <p>This component manages agents in the infectious state for models where infected individuals recover permanently (i.e., transition to a <code>RECOVERED</code> state without waning). It supports agent-level infection durations and patch-level tracking of recoveries over time.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) based on scenario input - Decrements <code>itimer</code> daily for infectious agents - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Updates patch-level state variables:     \u2022 <code>I[t, i]</code>: infectious count at tick <code>t</code> in node <code>i</code>     \u2022 <code>R[t, i]</code>: recovered count     \u2022 <code>recovered[t, i]</code>: number of recoveries during tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected individuals per patch - <code>infdurdist</code>: function returning infection durations - <code>infdurmin</code>: minimum infectious period (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: countdown timers per agent - <code>model.nodes.I[t]</code>, <code>.R[t]</code>: infectious and recovered counts per patch - <code>model.nodes.recovered[t]</code>: daily recoveries per patch</p> <p>Step Behavior: - Infectious agents decrement <code>itimer</code> - When <code>itimer == 0</code>, agent state is set to <code>RECOVERED</code> - Patch-level <code>I</code> and <code>R</code> are updated; <code>recovered</code> logs today's transitions</p> <p>Validation: - Ensures internal consistency between agent state and timer - Confirms agents with <code>itimer == 1</code> recover exactly one day later - Validates population conservation (<code>S + I + R = N</code>)</p> <p>Plotting: The <code>plot()</code> method shows per-node and total infectious counts across time.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIR--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     SIR.Recovered(model),     ... ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIR.step","title":"<code>laser.generic.models.components.InfectiousIR.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIR.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIR.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIRS","title":"<code>laser.generic.models.components.InfectiousIRS(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1)</code>","text":"<p>Infectious Component for SIRS/SEIRS Models (Recovery with Waning Immunity)</p> <p>This component manages infectious individuals in models where recovery confers temporary immunity, after which agents become susceptible again (SIRS/SEIRS).</p> <p>Responsibilities: - Initializes infectious agents from <code>model.scenario.I</code> - Assigns and tracks infectious timers (<code>itimer</code>) per agent - Transitions agents from <code>INFECTIOUS</code> to <code>RECOVERED</code> when <code>itimer == 0</code> - Assigns a waning immunity timer (<code>rtimer</code>) upon recovery - Updates patch-level state:     \u2022 <code>I[t, i]</code>: current infectious count     \u2022 <code>R[t, i]</code>: current recovered count     \u2022 <code>recovered[t, i]</code>: number of agents recovering on tick <code>t</code></p> <p>Required Inputs: - <code>model.scenario.I</code>: number of initially infected agents per node - <code>infdurdist</code>: function that samples the infectious duration distribution - <code>wandurdist</code>: function that samples the waning immunity duration distribution - <code>infdurmin</code>: minimum infectious period (default = 1 day) - <code>wandurmin</code>: minimum duration of immunity (default = 1 day)</p> <p>Outputs: - <code>model.people.itimer</code>: days remaining in the infectious state - <code>model.people.rtimer</code>: days remaining in the recovered state - <code>model.nodes.I</code>, <code>model.nodes.R</code>: counts per node per tick - <code>model.nodes.recovered[t]</code>: number of recoveries recorded on tick <code>t</code></p> <p>Step Behavior: - Infectious agents decrement their <code>itimer</code> - When <code>itimer == 0</code>, agents become recovered and receive an <code>rtimer</code> - Patch-level totals are updated - Downstream components (e.g., <code>Recovered</code>) handle <code>rtimer</code> countdown and eventual return to <code>SUSCEPTIBLE</code></p> <p>Validation: - Ensures timer consistency and population accounting - Confirms correct infectious-to-recovered transitions - Can be chained with recovery and waning components for full SIRS/SEIRS loops</p> <p>Plotting: Two plots are provided: 1. Infected counts per node 2. Total infected and recovered counts across time</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIRS--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIRS(model, infdurdist, wandurdist),     Exposed(model, ...),     Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIRS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIRS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIRS.step","title":"<code>laser.generic.models.components.InfectiousIRS.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIRS.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIRS.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS","title":"<code>laser.generic.models.components.InfectiousIS(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious Component for SIS Models (Infection + Recovery to Susceptible)</p> <p>This component handles the infectious state in SIS-style models, where agents recover from infection and immediately return to the susceptible pool. It supports per-agent infection durations and manages patch-level infectious counts over time.</p> <p>Responsibilities: - Initializes infected agents and their infection timers (<code>itimer</code>) - Decrements <code>itimer</code> daily for infectious agents - Automatically transitions agents from <code>INFECTIOUS</code> to <code>SUSCEPTIBLE</code> when <code>itimer == 0</code> - Tracks per-day recoveries at the node level in <code>model.nodes.recovered</code> - Maintains node-level <code>I</code> and <code>S</code> counts with full timestep resolution</p> <p>Required Inputs: - <code>model.scenario.I</code>: initial number of infectious agents per patch - <code>infdurdist</code>: a callable function which samples the infectious duration distribution - <code>infdurmin</code>: the minimum infection period (default = 1 time step)</p> <p>Outputs: - <code>model.people.itimer</code>: per-agent infection countdown timer - <code>model.nodes.I[t, i]</code>: number of infectious individuals at tick <code>t</code> in node <code>i</code> - <code>model.nodes.recovered[t, i]</code>: number of recoveries at tick <code>t</code> in node <code>i</code></p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>At each tick: - Infectious agents decrement their <code>itimer</code> - Agents with <code>itimer == 0</code> are transitioned back to susceptible - <code>model.nodes.I</code> is updated accordingly - Recovered counts are recorded in <code>model.nodes.recovered</code></p> <p>Validation: - Ensures consistency between agent <code>state</code> and infection timer (<code>itimer</code>) - Validates <code>I</code> census against agent-level state before and after each tick</p> <p>Plotting: The <code>plot()</code> method displays both per-node and total infectious counts over time.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIS(model, infdurdist),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS.step","title":"<code>laser.generic.models.components.InfectiousIS.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousIS.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI","title":"<code>laser.generic.models.components.InfectiousSI(model)</code>","text":"<p>Infectious Component for SI Models (No Recovery)</p> <p>This component manages the infectious state in SI-style epidemic models where agents remain infectious indefinitely. It is appropriate for use in models without a recovered or removed state (i.e., no <code>R</code> compartment).</p> <p>Responsibilities: - Initializes agents as infectious based on <code>model.scenario.I</code> - Tracks the number of infectious individuals (<code>I</code>) in each patch over time - Maintains per-tick, per-node counts in <code>model.nodes.I</code> - Validates consistency between agent states and patch-level totals</p> <p>Required Inputs: - <code>model.scenario.I</code>: array of initial infected counts per patch - <code>model.people.state</code>: infection state per agent - <code>model.people.nodeid</code>: patch assignment per agent - <code>model.params.nticks</code>: number of timesteps to simulate</p> <p>Outputs: - <code>model.nodes.I[t, i]</code>: number of infectious individuals in node <code>i</code> at time <code>t</code></p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For each timestep <code>t</code>, this component copies:     I[t+1] = I[t] (No recovery or removal; new infections may be added externally.)</p> <p>Validation: - Ensures that patch-level infectious counts (<code>model.nodes.I</code>) match the agent-level state - Asserts that the sum of <code>S</code> and <code>I</code> matches total population at initialization - Validates that infected counts do not change unexpectedly (unless altered by another component)</p> <p>Plotting: The <code>plot()</code> method shows the number of infectious agents per patch and in total across time.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousSI(model),     SIR.Transmission(model, ...), ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI.step","title":"<code>laser.generic.models.components.InfectiousSI.step(tick)</code>","text":"<p>Step function for the Infected component.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI.step--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.InfectiousSI.step--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Recovered","title":"<code>laser.generic.models.components.Recovered(model)</code>","text":"<p>Recovered Component for SIR/SEIR Models (Permanent Immunity)</p> <p>This component manages agents in the recovered state in models where immunity does not wane (i.e., once recovered, agents stay recovered permanently). It tracks the number of recovered individuals over time at the patch level, but performs no active transitions itself \u2014 recovery transitions must be handled by upstream components.</p> <p>Responsibilities: - Initializes agents as recovered if specified in <code>model.scenario.R</code> - Tracks per-patch recovered counts over time in <code>model.nodes.R</code> - Verifies consistency between agent state and aggregate recovered counts - Propagates recovered totals forward unchanged (unless modified by other components)</p> <p>Required Inputs: - <code>model.scenario.R</code>: number of initially recovered individuals per node</p> <p>Outputs: - <code>model.nodes.R[t, i]</code>: number of recovered individuals at tick <code>t</code> in node <code>i</code></p> <p>Step Behavior: - At each tick, carries forward:     R[t+1] = R[t] - This component does not change any agent's state or internal timers</p> <p>\ud83e\uddea Validation: - Ensures per-agent state matches aggregate <code>R</code> counts before and after each step - Detects accidental changes to recovered counts not explained by upstream logic</p> <p>Plotting: The <code>plot()</code> method shows per-node and total recovered counts over time.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Recovered--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     InfectiousIR(model, infdurdist),     Recovered(model),  # passive tracker, assumes recovery handled upstream ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Recovered--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.RecoveredRS","title":"<code>laser.generic.models.components.RecoveredRS(model, wandurdist, wandurmin=1)</code>","text":"<p>Recovered Component for SIRS/SEIRS Models (Waning Immunity)</p> <p>This component manages agents in the recovered state in models where immunity is temporary. It supports per-agent recovery timers, enabling individuals to return to the susceptible state after a configurable waning period. This is essential for SEIRS/SIRS model dynamics.</p> <p>Responsibilities: - Initializes agents in the <code>RECOVERED</code> state using <code>model.scenario.R</code> - Assigns <code>rtimer</code> values to track the duration of immunity - Decrements <code>rtimer</code> each tick; transitions agents to <code>SUSCEPTIBLE</code> when <code>rtimer == 0</code> - Updates patch-level counts:     \u2022 <code>R[t, i]</code>: number of recovered individuals in node <code>i</code> at time <code>t</code>     \u2022 <code>waned[t, i]</code>: number of agents who re-entered susceptibility on time step <code>t</code></p> <p>Required Inputs: - <code>model.scenario.R</code>: initial number of recovered individuals per node - <code>wandurdist</code>: a function sampling the waning immunity duration distribution - <code>wandurmin</code>: minimum duration of immunity (default = 1 time step)</p> <p>Outputs: - <code>model.people.rtimer</code>: per-agent countdown to immunity expiration - <code>model.nodes.R</code>: recovered count per patch per timestep - <code>model.nodes.waned</code>: number of immunity losses per patch per tick</p> <p>Step Behavior: - Agents with <code>state == RECOVERED</code> decrement <code>rtimer</code> - When <code>rtimer == 0</code>, they return to <code>SUSCEPTIBLE</code> - <code>R</code> and <code>S</code> counts are updated to reflect this transition - <code>waned[t]</code> logs the number of agents who lost immunity on time step <code>t</code></p> <p>Validation: - Ensures population conservation and consistency between agent states and patch totals - Detects unexpected changes in <code>R</code> or invalid transitions</p> <p>Plotting: The <code>plot()</code> method provides two views: 1. Per-node recovered trajectories 2. Total recovered and waned agents over time</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.RecoveredRS--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SEIRS.Infectious(model, infdurdist, wandurdist),     Exposed(model, ...),     RecoveredRS(model, wandurdist), ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.RecoveredRS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.RecoveredRS--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Susceptible","title":"<code>laser.generic.models.components.Susceptible(model)</code>","text":"<p>Susceptible Component for Patch-Based Agent-Based Models (S, SI, SIS, SIR, SEIR, etc.)</p> <p>This component initializes and tracks the count of susceptible individuals (<code>S</code>) in a spatially structured agent-based model. It is compatible with all standard LASER disease progression models that include a \"susceptible\" state.</p> <p>Responsibilities: - Initializes agent-level properties:     \u2022 <code>nodeid</code>: Patch ID of each agent (uint16)     \u2022 <code>state</code>: Infection state (int8), defaulting to <code>State.SUSCEPTIBLE</code> - Initializes node-level property:     \u2022 <code>S[t, i]</code>: Susceptible count in node <code>i</code> at time <code>t</code> - At each timestep, propagates the susceptible count forward (<code>S[t+1] = S[t]</code>),   unless modified by other components (e.g., exposure, births). - Validates consistency between patch-level susceptible counts and agent-level state.</p> <p>Usage: Add this component early in the component list for any model with SUSCEPTIBLE agents, typically before transmission or exposure components. Compatible with:     - <code>SIR.Transmission</code>     - <code>SIR.Exposure</code>     - <code>SIR.Infectious</code>     - <code>SIR.Recovered</code>     - Custom SEIRS extensions</p> <p>Requires: - <code>model.people</code>: A LaserFrame for all agents - <code>model.nodes</code>: Patch-level state - <code>model.scenario</code>: Input DataFrame with <code>population</code> and optionally <code>S</code> columns - <code>model.params.nticks</code>: Number of simulation ticks</p> <p>Validation: - Ensures consistency of susceptible counts before and after each step - Prevents unintentional state drift by validating against agent <code>state</code> values</p> <p>Output: - <code>model.nodes.S</code>: A <code>(nticks+1, num_nodes)</code> array of susceptible counts - Optional plotting via <code>plot()</code> for visual inspection of per-node and total <code>S</code></p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Susceptible--glossary","title":"Glossary","text":"<p>Step Behavior</p> <p>For tick t:     S[t+1] = S[t]     # Unless explicitly modified by other components</p> <p>This component does not alter agent states directly but serves as a synchronized counter and validator of susceptible individuals.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Susceptible--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     SIR.Transmission(model, ...),     SIR.Exposure(model),     SIR.Infectious(model, ...),     SIR.Recovered(model), ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.Susceptible--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE","title":"<code>laser.generic.models.components.TransmissionSE(model, expdurdist, expdurmin=1)</code>","text":"<p>Transmission Component for SEIR/SEIRS Models (S \u2192 E with Incubation Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>EXPOSED</code> in models where infection includes an incubation period before agents become infectious. It handles stochastic exposure based on per-node force of infection (FOI), and assigns individual incubation timers to newly exposed agents.</p> <p>Responsibilities: - Computes force of infection <code>\u03bb = \u03b2 * (I / N)</code> at each tick per node - Adjusts FOI using <code>model.network</code> for inter-node transmission coupling. Required but can be nullified by filling with all zeros. - Applies FOI to susceptible agents to determine exposure - Assigns incubation durations (<code>etimer</code>) to each newly exposed agent - Updates node-level counts for <code>S</code> and <code>E</code> and logs daily incidence</p> <p>Required Inputs: - <code>model.params.beta</code>: global transmission rate - <code>model.network</code>: [n x n] matrix for FOI migration - <code>expdurdist(tick, node)</code>: callable that samples the exposure/incubation duration distribution - <code>expdurmin</code>: minimum incubation period (default = 1)</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at tick <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new exposures per node per day - <code>model.people.etimer</code>: per-agent incubation countdown</p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Optionally applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Validates consistency between agent states and patch-level counts before and after tick - Confirms that <code>incidence[t] == E[t+1] - E[t]</code></p> <p>Plotting: The <code>plot()</code> method shows per-node FOI (<code>\u03bb</code>) trajectories over time.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSE(model, expdurdist),     Exposed(model, ...),     InfectiousIR(model, ...),     Recovered(model), ]</p> <p>Initializes the TransmissionSE component.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <p>Minimum incubation duration.</p> <code>1</code>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSE--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI","title":"<code>laser.generic.models.components.TransmissionSI(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission Component for SIS/SIR/SIRS Models (S \u2192 I with Duration)</p> <p>This component simulates the transition from <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> in models where infectious individuals have a finite infection duration (<code>itimer</code>). It supports full spatial coupling and allows infection durations to vary by node and tick.</p> <p>Responsibilities: - Computes force of infection (FOI) <code>\u03bb = \u03b2 * (I / N)</code> per patch each tick - Applies optional spatial coupling via <code>model.network</code> (infection pressure transfer) - Converts FOI into Bernoulli probabilities using <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents stochastically, assigning per-agent <code>itimer</code> - Updates patch-level susceptible (<code>S</code>) and infectious (<code>I</code>) counts - Records number of new infections per tick in <code>model.nodes.incidence</code></p> <p>Required Inputs: - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: [n x n] matrix of transmission coupling - <code>infdurdist(tick, node)</code>: callable sampling the infectious duration distribution - <code>model.people.itimer</code>: preallocated per-agent infection timer</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: computed FOI in node <code>i</code> at time <code>t</code> - <code>model.nodes.incidence[t, i]</code>: new infections in node <code>i</code> on time step <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between incidence and change in <code>I</code> - Checks for correct state and population accounting before and after tick</p> <p>Plotting: The <code>plot()</code> method visualizes per-node FOI (<code>\u03bb</code>) over simulation time.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSI(model, infdurdist),     InfectiousIR(model, infdurdist), ]</p> <p>Initializes the TransmissionSI component.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSIX","title":"<code>laser.generic.models.components.TransmissionSIX(model)</code>","text":"<p>Transmission Component for SI-Style Models (S \u2192 I Only, No Recovery)</p> <p>This component simulates the transmission process in simple epidemic models where agents move from the <code>SUSCEPTIBLE</code> to <code>INFECTIOUS</code> state and remain infectious indefinitely. It computes the force of infection (FOI) for each patch and applies it stochastically to susceptible agents.</p> <p>Responsibilities: - Computes per-node force of infection (<code>\u03bb</code>) at each tick:     \u03bb = \u03b2 * (I / N), with spatial coupling via a migration matrix - Applies probabilistic infection to susceptible agents using <code>nb_transmission_step</code> - Updates per-node <code>S</code> and <code>I</code> counts accordingly - Tracks new infections (incidence) and FOI values per node and tick</p> <p>Required Inputs: - <code>model.nodes.I[t]</code>: number of infectious agents per node at tick <code>t</code> - <code>model.nodes.S[t]</code>: number of susceptible agents per node at tick <code>t</code> - <code>model.params.beta</code>: transmission rate (global) - <code>model.network</code>: matrix of spatial coupling between nodes</p> <p>Outputs: - <code>model.nodes.forces[t, i]</code>: force of infection in node <code>i</code> at tick <code>t</code> - <code>model.nodes.incidence[t, i]</code>: number of new infections in node <code>i</code> at tick <code>t</code></p> <p>Step Behavior: - Computes FOI (<code>\u03bb</code>) for each node - Applies inter-node infection pressure via <code>model.network</code> - Converts FOI into a Bernoulli probability using: <code>p = 1 - exp(-\u03bb)</code> - Infects susceptible agents probabilistically - Updates state and records incidence</p> <p>Validation: - Ensures consistency between state transitions and incidence records - Checks conservation of population in <code>S</code> and <code>I</code> states - Validates <code>incidence[t] == I[t+1] - I[t]</code></p> <p>Plotting: The <code>plot()</code> method displays the force of infection over time per node.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSIX--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components = [     SIR.Susceptible(model),     TransmissionSIX(model),     InfectiousSI(model), ]</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSIX--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.TransmissionSIX--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsBase","title":"<code>laser.generic.models.components.VitalDynamicsBase(model, birthrates, pyramid, survival, states=None)</code>","text":"<p>Base Component for Vital Dynamics (Births and Deaths)</p> <p>This abstract base class implements shared functionality for components that model vital population dynamics in infectious disease simulations \u2014 including both births and non-disease deaths. Subclasses must define a <code>step()</code> method that controls the timing and triggering of these events (e.g., daily, seasonal, or condition-based).</p> <p>Responsibilities: - Adds <code>dob</code> (date of birth) and <code>dod</code> (date of death) agent-level properties - Samples date of birth using an age pyramid distribution - Samples date of death using a survival curve estimator - Tracks births and deaths at the node level per tick - Updates susceptible and deceased populations accordingly - Validates population accounting before and after demographic changes - Invokes <code>on_birth(...)</code> hooks in downstream components (if defined)</p> <p>Required Inputs: - <code>birthrates[t, i]</code>: annual crude birth rate for each node - <code>pyramid</code>: instance of <code>AliasedDistribution</code> to sample agent age at birth (only for initial population) - <code>survival</code>: instance of <code>KaplanMeierEstimator</code> to sample lifespan from age (for both initial population and future births) - <code>states</code>: list of state labels used in population accounting (default = <code>[\"S\", \"E\", \"I\", \"R\"]</code>)</p> <p>Outputs: - <code>model.people.dob</code>, <code>model.people.dod</code>: per-agent date of birth and death - <code>model.nodes.births[t, i]</code>: number of births on tick <code>t</code> in node <code>i</code> - <code>model.nodes.deaths[t, i]</code>: number of deaths on tick <code>t</code> in node <code>i</code> - <code>model.nodes.S[t, i]</code>: susceptible counts incremented by births</p> <p>Behavior Overview: - <code>prevalidate_step()</code>: caches population and death status for change detection - <code>postvalidate_step()</code>: checks that births/deaths were applied consistently - <code>_births()</code>: allocates newborns across patches, assigns <code>dob</code>, <code>dod</code>, and default state - Death processing is expected to occur in a subclass implementation</p> <p>Validation: - Verifies changes in total agent count are consistent with births - Ensures patch-level birth and death counts match aggregated agent transitions - Asserts population conservation across susceptible and infectious compartments</p> <p>Extension Notes: This class does not implement <code>step()</code> and must be subclassed with a scheduling strategy.</p> <p>Plotting: The <code>plot()</code> method provides daily and cumulative trends for births and deaths.</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsBase--glossary","title":"Glossary","text":"<p>Example</p> <p>class VitalDaily(VitalDynamicsBase):     def step(self, tick: int) -&gt; None:         self._births(tick)         self._deaths(tick)</p> <p>model.components.append(VitalDaily(...))</p> <p>Initializes the VitalDynamicsBase component.</p> <p>Args:</p> <pre><code>model: The epidemiological model instance.\nbirthrates: Array of birth rates, CBR, in effect for each tick and node.\npyramid (AliasedDistribution): Age pyramid distribution for sampling date of birth.\nsurvival (KaplanMeierEstimator): Survival curve for sampling date of death.\nstates: List of states to consider for population counts (default: [\"S\", \"E\", \"I\", \"R\"]).\n</code></pre>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsBase--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsBase--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsBase--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSEIR","title":"<code>laser.generic.models.components.VitalDynamicsSEIR(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SEIR/SEIRS Models (Births and Deaths with S, E, I, R States)</p> <p>This component supports full vital dynamics in compartmental models that include an incubation stage (<code>EXPOSED</code>) in addition to infection and recovery.</p> <p>Responsibilities: - Applies daily age-dependent mortality across <code>S</code>, <code>E</code>, <code>I</code>, and <code>R</code> - Marks deceased agents as <code>DECEASED</code>, removing them from the simulation - Adds new agents as <code>SUSCEPTIBLE</code>, assigning age and expected lifespan - Updates per-tick, per-node counts for <code>S</code>, <code>E</code>, <code>I</code>, <code>R</code>, <code>births</code>, and <code>deaths</code></p> <p>Validation: - Ensures consistent agent transitions and patch-level flows - Confirms that changes in population reflect births minus deaths</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSEIR--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSEIR(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSEIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSEIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSI","title":"<code>laser.generic.models.components.VitalDynamicsSI(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SI/SIS Models (Births and Deaths with S and I Only)</p> <p>This component implements demographic changes for simple SI or SIS models, where the only health states are <code>SUSCEPTIBLE</code> and <code>INFECTIOUS</code>. It supports both daily births and non-disease deaths using age-structured survival curves and crude birth rates (CBR).</p> <p>Responsibilities: - Applies daily mortality by checking agent <code>dod == tick</code> - Removes agents from <code>S</code> or <code>I</code> and marks them <code>DECEASED</code> - Adds new agents as <code>SUSCEPTIBLE</code> using <code>_births()</code>, sampling age and lifespan - Updates patch-level counts in <code>S</code>, <code>I</code>, <code>births</code>, and <code>deaths</code></p> <p>Validation: - Ensures birth and death counts match population changes - Verifies newborn states and death state transitions</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSI--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSI(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSIR","title":"<code>laser.generic.models.components.VitalDynamicsSIR(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital Dynamics for SIR/SIRS Models (Births and Deaths with S, I, R States)</p> <p>This component manages demographic events for models with susceptible, infectious, and recovered compartments. It handles per-agent births and age-dependent deaths and adjusts patch-level state counts accordingly.</p> <p>Responsibilities: - Applies mortality by removing agents in <code>S</code>, <code>I</code>, or <code>R</code> with <code>dod == tick</code> - Marks deceased agents with <code>State.DECEASED</code> - Adds newborns as <code>SUSCEPTIBLE</code>, updating <code>S</code>, <code>births</code>, and <code>deaths</code> - Maintains per-tick, per-patch counts for <code>S</code>, <code>I</code>, <code>R</code>, <code>births</code>, <code>deaths</code></p> <p>Validation: - Verifies consistent population accounting across all compartments - Asserts correct transition timing for births and deaths</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSIR--glossary","title":"Glossary","text":"<p>Example</p> <p>model.components.append(     VitalDynamicsSIR(model, birthrates, pyramid, survival) )</p>"},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#laser.generic.models.components.VitalDynamicsSIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/components/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/model/","title":"laser.generic.models.model","text":""},{"location":"reference/laser/generic/models/model/#laser.generic.models.model","title":"<code>laser.generic.models.model</code>","text":""},{"location":"reference/laser/generic/models/model/#laser.generic.models.model.Model","title":"<code>laser.generic.models.model.Model(scenario, params, birthrates=None, skip_capacity=False)</code>","text":"<p>Initialize the SI model.</p>"},{"location":"reference/laser/generic/models/model/#laser.generic.models.model.Model--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>GeoDataFrame</code> <p>The scenario data containing per patch population, initial S and I counts, and geometry.</p> required <code>params</code> <code>PropertySet</code> <p>The parameters for the model, including 'nticks' and 'beta'.</p> required <code>birthrates</code> <code>ndarray</code> <p>Birth rates in CBR per patch per tick. Defaults to None.</p> <code>None</code> <code>skip_capacity</code> <code>bool</code> <p>If True, skips capacity checks. Defaults to False.</p> <code>False</code>"},{"location":"reference/laser/generic/models/model/#laser.generic.models.model.Model--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/model/#laser.generic.models.model.Model--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/model/#laser.generic.models.model.Model--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/model/#laser.generic.models.model.Model--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/model/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/models/shared/","title":"laser.generic.models.shared","text":""},{"location":"reference/laser/generic/models/shared/#laser.generic.models.shared","title":"<code>laser.generic.models.shared</code>","text":""},{"location":"reference/laser/generic/models/shared/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/","title":"laser.generic.newutils","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils","title":"<code>laser.generic.newutils</code>","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.TimingContext","title":"<code>laser.generic.newutils.TimingContext(label, stats, parent)</code>","text":"<p>Internal class for timing context management.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.TimingContext--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap","title":"<code>laser.generic.newutils.ValuesMap(nnodes, nsteps)</code>","text":"<p>A class to efficiently represent values mapped over nodes and time steps.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>nnodes</code> <code>int</code> <p>Number of nodes.</p> required <code>nsteps</code> <code>int</code> <p>Number of time steps.</p> required <p>Methods to create ValuesMap from different data sources</p> <ul> <li>from_scalar(scalar: float, nnodes: int, nsteps: int)</li> <li>from_timeseries(data: np.ndarray, nnodes: int)</li> <li>from_nodes(data: np.ndarray, nsteps: int)</li> <li>from_array(data: np.ndarray, writeable: bool = False)</li> </ul>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.nnodes","title":"<code>laser.generic.newutils.ValuesMap.nnodes</code>  <code>property</code>","text":"<p>Number of nodes.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.nnodes--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.nsteps","title":"<code>laser.generic.newutils.ValuesMap.nsteps</code>  <code>property</code>","text":"<p>Number of time steps.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.nsteps--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.shape","title":"<code>laser.generic.newutils.ValuesMap.shape</code>  <code>property</code>","text":"<p>Shape of the underlying data array (nsteps, nnodes).</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.shape--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.values","title":"<code>laser.generic.newutils.ValuesMap.values</code>  <code>property</code>","text":"<p>Underlying data array of shape (nsteps, nnodes).</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.values--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_array","title":"<code>laser.generic.newutils.ValuesMap.from_array(data, writeable=False)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap from a 2D array of data.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_array--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>2D array of shape (nsteps, nnodes).</p> required <code>writeable</code> <code>bool</code> <p>If True, the underlying data array is writeable and can be modified during simulation. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_array--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_array--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_array--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_nodes","title":"<code>laser.generic.newutils.ValuesMap.from_nodes(data, nsteps)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap from a nodes array for all time steps.</p> <p>All time steps have the same node data.</p> <p>nnodes is inferred from the length of data.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_nodes--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>1D array of node data.</p> required <code>nsteps</code> <code>int</code> <p>Number of time steps.</p> required <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_nodes--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_nodes--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_nodes--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_scalar","title":"<code>laser.generic.newutils.ValuesMap.from_scalar(scalar, nnodes, nsteps)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap with the same scalar value for all nodes and time steps.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_scalar--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>float</code> <p>The scalar value to fill the map.</p> required <code>nnodes</code> <code>int</code> <p>Number of nodes.</p> required <code>nsteps</code> <code>int</code> <p>Number of time steps.</p> required <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_scalar--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_scalar--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_scalar--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_scalar--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_timeseries","title":"<code>laser.generic.newutils.ValuesMap.from_timeseries(data, nnodes)</code>  <code>staticmethod</code>","text":"<p>Create a ValuesMap from a time series array for all nodes.</p> <p>All nodes have the same time series data.</p> <p>nsteps is inferred from the length of data.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_timeseries--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>1D array of time series data.</p> required <code>nnodes</code> <code>int</code> <p>Number of nodes.</p> required <p>Returns:</p> Name Type Description <code>ValuesMap</code> <code>ValuesMap</code> <p>The created ValuesMap instance.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_timeseries--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_timeseries--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.ValuesMap.from_timeseries--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.estimate_capacity","title":"<code>laser.generic.newutils.estimate_capacity(birthrates, initial_pop)</code>","text":"<p>Estimate the carrying capacity of each node given birthrates and initial population.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.estimate_capacity--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>birthrates</code> <code>ndarray</code> <p>2D array of shape (nticks, nnodes) with CBR (birthrates per 1000 individuals per year) in effect at each tick.</p> required <code>initial_pop</code> <code>ndarray</code> <p>1D array of shape (nnodes,) with initial population per node.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: 1D array of shape (nnodes,) with estimated final population count per node.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.estimate_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.estimate_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.estimate_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.get_centroids","title":"<code>laser.generic.newutils.get_centroids(gdf)</code>","text":"<p>Get centroids of geometries in gdf in degrees (EPSG:4326).</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.get_centroids--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid","title":"<code>laser.generic.newutils.grid(M=5, N=5, node_size_km=10, population_fn=None, origin_x=0, origin_y=0)</code>","text":"<p>Create an MxN grid of cells anchored at (0, 0) with populations and geometries.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>M</code> <code>int</code> <p>Number of rows (north-south).</p> <code>5</code> <code>N</code> <code>int</code> <p>Number of columns (east-west).</p> <code>5</code> <code>node_size_km</code> <code>float</code> <p>Size of each cell in kilometers (default 10).</p> <code>10</code> <code>population_fn</code> <code>callable</code> <p>Function returning population for a cell.</p> <code>None</code> <code>origin_x</code> <code>float</code> <p>longitude of the origin (bottom-left corner) -180 &lt;= origin_x &lt; 180.</p> <code>0</code> <code>origin_y</code> <code>float</code> <p>latitude of the origin (bottom-left corner) -90 &lt;= origin_y &lt; 90.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>GeoDataFrame</code> <code>GeoDataFrame</code> <p>Columns are nodeid, population, geometry.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.grid--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.validate","title":"<code>laser.generic.newutils.validate(pre, post)</code>","text":"<p>Decorator to add pre- and post-validation to a method.</p> <p>Calls the given pre- and post-validation methods if the model or component is in validating mode.</p>"},{"location":"reference/laser/generic/newutils/#laser.generic.newutils.validate--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/newutils/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/susceptibility/","title":"laser.generic.susceptibility","text":""},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility","title":"<code>laser.generic.susceptibility</code>","text":"<p>This module defines the Susceptibility class for managing and visualizing the susceptibility of a population in LASER models.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility","title":"<code>laser.generic.susceptibility.Susceptibility(model, verbose=False)</code>","text":"<p>A LASER model component representing the susceptibility of a population.</p> <p>This component adds a scalar property <code>susceptibility</code> to the population and a vector property to the patches. It tracks which agents are susceptible at any given tick and provides helper functions for updating these values.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility--glossary","title":"Glossary","text":"<p>Initialize the susceptibility component of the model.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility--parameters","title":"Parameters","text":"<p>model : object     A LASER model instance. Must have <code>population</code>, <code>patches</code>, and <code>params</code>     with the following:       * population.add_scalar_property(name, dtype, default)       * patches.add_vector_property(name, nticks, dtype)       * params.nticks (int) - number of simulation ticks. verbose : bool, optional     If True, enables verbose output. Default is False.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility--notes","title":"Notes","text":"<ul> <li>This method adds a scalar property <code>susceptibility</code> to each agent in   the population, initialized to <code>1</code> (susceptible).</li> <li>It also adds a vector property <code>susceptibility</code> to each patch, which   tracks aggregated susceptible counts over time.</li> </ul>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.__call__","title":"<code>laser.generic.susceptibility.Susceptibility.__call__(model, tick)</code>","text":"<p>Make the component callable. Required for LASER component interface.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.__call__--parameters","title":"Parameters","text":"<p>model : object     The LASER model containing population and patches. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.__call__--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.__call__--notes","title":"Notes","text":"<p>This component does not perform per-tick updates. The method exists only to satisfy the LASER component interface.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.census","title":"<code>laser.generic.susceptibility.Susceptibility.census(model, tick)</code>","text":"<p>Aggregate susceptible counts into patches at the given tick.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.census--parameters","title":"Parameters","text":"<p>model : object     LASER model containing <code>population</code> and <code>patches</code>. tick : int     Current simulation tick.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.census--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.census--notes","title":"Notes","text":"<ul> <li>At tick 0, this computes susceptible counts from the population   and writes them into <code>patches.susceptibility</code>.</li> <li>For a single patch, counts are summed globally.</li> <li>For multiple patches, counts are distributed by agent <code>nodeid</code>.</li> <li>In all cases, values are copied into <code>patches.susceptibility_test</code>   for validation/debugging.</li> </ul>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.on_birth","title":"<code>laser.generic.susceptibility.Susceptibility.on_birth(model, _tick, istart, iend)</code>","text":"<p>Handle the birth event by setting susceptibility of newborns.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.on_birth--parameters","title":"Parameters","text":"<p>model : object     LASER model containing the population. _tick : int     Current simulation tick (unused). istart : int or ndarray of int64     Start index of newborns (if slice mode), or array of agent indices (if random-access mode). iend : int or None     End index of newborns (exclusive). If None, <code>istart</code> is treated as     an index array for random-access updates.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.on_birth--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.on_birth--notes","title":"Notes","text":"<ul> <li>Newborns are set to susceptible (1).</li> <li>Uses either slice-based or random-access update functions.</li> </ul>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.plot","title":"<code>laser.generic.susceptibility.Susceptibility.plot(fig=None)</code>","text":"<p>Placeholder for plotting susceptibility distribution by age.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     A Matplotlib Figure to draw into. If None, a new figure would be created     in a full implementation.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.plot--yields","title":"Yields","text":"<p>None     The generator currently yields once (<code>None</code>). This is a placeholder     and should be replaced with actual plotting logic in the future.</p>"},{"location":"reference/laser/generic/susceptibility/#laser.generic.susceptibility.Susceptibility.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/susceptibility/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/","title":"laser.generic.transmission","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission","title":"<code>laser.generic.transmission</code>","text":"<p>This module defines the Transmission class, which models the transmission of measles in a population.</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission","title":"<code>laser.generic.transmission.Transmission(model, verbose=False)</code>","text":"<p>A LASER-generic component that models inter-agent disease transmission within and between patches.</p> <p>This component calculates the force of infection at each time step using: - Agent state (infectious status) - Node-level infectious prevalence - Network-based movement between patches - Time-varying transmission modifiers (e.g., seasonality or biweekly scaling)</p> <p>It supports multiple transmission dynamics depending on the structure of the population (e.g., SI, SEIR).</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission--glossary","title":"Glossary","text":"<p>Initialize the Transmission component and register per-patch properties.</p> <p>Adds the following properties: - <code>cases</code>: Total cumulative infections per patch per time step - <code>forces</code>: Force of infection for each patch (float32) - <code>incidence</code>: New infections per patch per time step - <code>doi</code>: Date of infection for each individual (set on infection)</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>A LASER Model instance, which must expose <code>.patches</code>, <code>.population</code>, and <code>.params</code>.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints debug info during initialization (currently unused).</p> <code>False</code>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.__call__","title":"<code>laser.generic.transmission.Transmission.__call__(model, tick)</code>","text":"<p>Compute and apply transmission dynamics for the current tick.</p> <p>This function: - Computes node-level contagion (infectious density) - Modifies contagion using a network matrix if present - Applies time-varying scalars (seasonality, biweekly modifiers) to beta - Calculates force of infection per patch - Samples new infections using Numba-accelerated kernels depending on model structure</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.__call__--glossary","title":"Glossary","text":"<p>Notes</p> <p>The appropriate infection update kernel is selected based on the presence of <code>etimer</code> or <code>itimer</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The LASER model instance.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.census","title":"<code>laser.generic.transmission.Transmission.census(model, tick)</code>","text":"<p>Snapshot infectious counts into <code>cases_test</code> at tick <code>t</code> and propagate to tick <code>t+1</code>.</p> <p>This method: - Initializes <code>cases_test[t]</code> using individual infection status - Copies <code>cases_test[t]</code> into <code>cases_test[t+1]</code> to maintain continuity</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.census--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The LASER model instance.</p> required <code>tick</code> <code>int</code> <p>Current simulation tick.</p> required"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.census--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.on_birth","title":"<code>laser.generic.transmission.Transmission.on_birth(model, _tick, istart, iend)</code>","text":"<p>Initialize <code>doi</code> (date of infection) for newborns.</p> <p>This birth handler sets the date-of-infection field to zero for all new individuals.</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.on_birth--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The LASER model.</p> required <code>_tick</code> <code>int</code> <p>The current tick (unused).</p> required <code>istart</code> <code>int</code> <p>Start index of new agents.</p> required <code>iend</code> <code>int</code> <p>End index of new agents (exclusive). If None, assumes single agent at <code>istart</code>.</p> required"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.on_birth--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.plot","title":"<code>laser.generic.transmission.Transmission.plot(fig=None)</code>","text":"<p>Generate a 2x2 subplot figure showing cases and incidence over time.</p> <p>For the two most populous patches, this creates: - Line plot of <code>cases</code> over time - Line plot of <code>incidence</code> over time</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.plot--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>An existing figure object to draw on. If None, a new figure is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>None</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.Transmission.plot--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.TransmissionSIR","title":"<code>laser.generic.transmission.TransmissionSIR(model, verbose=False)</code>","text":"<p>               Bases: <code>Transmission</code></p> <p>Specialized transmission component for SIR models (no latent/exposed state).</p> <p>This subclass of <code>Transmission</code> models disease transmission in a Susceptible-Infected-Recovered (SIR) framework. It uses simplified logic assuming no explicit Exposed phase (i.e., no <code>etimer</code>). Infection dynamics are based on agent infectiousness, network structure (if any), and a constant recovery rate.</p> <p>This class is typically paired with <code>Infection</code> (not <code>Exposure</code>) components.</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.TransmissionSIR--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.TransmissionSIR.__call__","title":"<code>laser.generic.transmission.TransmissionSIR.__call__(model, tick)</code>","text":"<p>Perform a transmission step for an SIR model at a specific simulation tick.</p> <p>This method: - Computes the number of infectious individuals (based on susceptibility == 0) - Updates <code>cases[tick]</code> with current infectious counts - Applies network-based infection transfer between patches (if applicable) - Computes force of infection (FoI) per patch using \u03b2 and population - Stochastically infects agents using Numba-accelerated update</p> <p>This version assumes a simplified SIR model with: - No exposed state (<code>etimer</code>) - Infected agents are those with non-zero <code>itimer</code></p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.TransmissionSIR.__call__--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The LASER model instance, containing <code>.patches</code>, <code>.population</code>, and <code>.params</code>.</p> required <code>tick</code> <code>int</code> <p>Current timestep in the simulation.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.TransmissionSIR.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.TransmissionSIR.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#laser.generic.transmission.TransmissionSIR.__call__--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/transmission/#glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/","title":"laser.generic.utils","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils","title":"<code>laser.generic.utils</code>","text":"<p>This module provides utility functions for the laser-measles project.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity","title":"<code>laser.generic.utils.calc_capacity(population, nticks, cbr, verbose=False)</code>","text":"<p>Estimate the maximum population size after a given number of ticks, assuming constant exponential growth driven by a crude birth rate (CBR) and no net mortality.</p> <p>This function is typically used to preallocate memory for agent arrays and patch-level data in simulations with population turnover. It assumes births and deaths are either absent or balanced, and that population grows exponentially based on the provided CBR.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>population</code> <code>uint32</code> <p>Initial population size at tick 0.</p> required <code>nticks</code> <code>uint32</code> <p>Number of ticks (simulation time steps) to simulate.</p> required <code>cbr</code> <code>float32</code> <p>Crude birth rate (per 1000 people per year).</p> required <code>verbose</code> <code>bool</code> <p>If True, prints estimated population growth using daily and annual methods.</p> <code>False</code> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: Estimated upper bound on population size at tick = nticks.</p> <p>Notes</p> <ul> <li>The primary growth formula used is daily compounding:     population * (1 + daily_rate) ** nticks   where daily_rate is derived from the annual CBR.</li> <li>An alternate estimate using annual compounding is also printed if <code>verbose=True</code>.</li> <li>This is a conservative estimator used to size internal data structures, not a predictor   of actual population dynamics (which may be capped or stochastic).</li> </ul>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_capacity--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances","title":"<code>laser.generic.utils.calc_distances(latitudes, longitudes, verbose=False)</code>","text":"<p>Compute the full pairwise Haversine distance matrix between geographic locations.</p> <p>This function calculates the great-circle distances between all pairs of points defined by the input latitude and longitude arrays. Distances are computed using the Haversine formula (via the <code>distance()</code> function from laser.core.migration), and the result is returned as a square, symmetric matrix of distances in kilometers.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>latitudes</code> <code>ndarray</code> <p>A 1D array of latitudes in decimal degrees. Must match the shape of <code>longitudes</code>.</p> required <code>longitudes</code> <code>ndarray</code> <p>A 1D array of longitudes in decimal degrees. Must match <code>latitudes</code>.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the top-left 4x4 corner of the distance matrix for inspection.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A square matrix (n x n) where the element at [i, j] is the distance in kilometers         between point <code>i</code> and point <code>j</code>.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>latitudes</code> is not 1D or if <code>latitudes</code> and <code>longitudes</code> do not have equal shape.</p> <p>Notes</p> <ul> <li>Output matrix is symmetric with zeros on the diagonal.</li> <li>Internally uses the Haversine formula via <code>distance(...)</code>.</li> <li>Computation scales as O(n\u00b2); not recommended for very large n unless optimized.</li> <li>Input coordinates should be in decimal degrees and within valid bounds:     lat \u2208 [-90, 90], lon \u2208 [-180, 180]</li> </ul>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.calc_distances--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.get_default_parameters","title":"<code>laser.generic.utils.get_default_parameters()</code>","text":"<p>Returns a default PropertySet with common parameters used across laser-generic models.</p> <p>Each parameter in the returned PropertySet is described below, along with its default value and rationale:</p> <pre><code>nticks (int, default=730): Number of simulation ticks (days). Default is 2 years (365*2), which is a typical duration for seasonal epidemic simulations.\nbeta (float, default=0.15): Transmission rate per contact. Chosen as a moderate value for SIR-type models to reflect realistic disease spread.\nbiweekly_beta_scalar (list of float, default=[1.0]*biweekly_steps): Scalar for beta for each biweekly period. Default is 1.0 for all periods, meaning no seasonal variation unless specified.\ncbr (float, default=0.03): Constant birth rate. Set to 0.03 to represent a typical annual birth rate in population models.\nexp_shape (float, default=2.0): Shape parameter for the exposed period distribution. Default chosen for moderate dispersion.\nexp_scale (float, default=2.0): Scale parameter for the exposed period distribution. Default chosen for moderate mean duration.\ninf_mean (float, default=4.0): Mean infectious period (days). Set to 4.0 to reflect typical infectious durations for diseases like measles.\ninf_sigma (float, default=1.0): Standard deviation of infectious period. Default is 1.0 for moderate variability.\nseasonality_factor (float, default=0.2): Amplitude of seasonal forcing. Chosen to allow moderate seasonal variation in transmission.\nseasonality_phase (float, default=0.0): Phase offset for seasonality. Default is 0.0, meaning no phase shift.\nimportation_count (int, default=1): Number of cases imported per importation event. Default is 1 for sporadic importation.\nimportation_period (int, default=30): Days between importation events. Default is 30 to represent monthly importation.\nimportation_start (int, default=0): Start day for importation events. Default is 0 (simulation start).\nimportation_end (int, default=730): End day for importation events. Default is 2 years (365*2).\nseed (int, default=123): Random seed for reproducibility. Default is 123.\nverbose (bool, default=False): If True, enables verbose output. Default is False for minimal output.\n</code></pre> <p>These values are chosen to be broadly reasonable for seasonal SIR-type models with importation.</p> <p>We need a function like this because even-though laser-core requires no particular param name, laser-generic code does presume certain parameters and there's no elegant way to just discover what those are. So we put them here.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.get_default_parameters--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_in_patch","title":"<code>laser.generic.utils.seed_infections_in_patch(model, ipatch, ninfections=1)</code>","text":"<p>Seed initial infections in a specific patch of the population at the start of the simulation. This function randomly selects individuals from the specified patch and sets their infection timer to the mean infection duration, effectively marking them as infected. The process continues until the desired number of initial infections is reached.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_in_patch--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model containing the population and parameters.</p> required <code>ipatch</code> <code>int</code> <p>The identifier of the patch where infections should be seeded.</p> required <code>ninfections</code> <code>int</code> <p>The number of initial infections to seed. Defaults to 100.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly","title":"<code>laser.generic.utils.seed_infections_randomly(model, ninfections=100)</code>","text":"<p>Randomly seed initial infections across the entire population.</p> <p>This function selects up to <code>ninfections</code> susceptible individuals at random from the full population. It marks them as infected by: - Setting their infection timer (<code>itimer</code>) to the model's mean infectious duration (<code>inf_mean</code>), - Setting their susceptibility to zero.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model, which must contain a <code>population</code> with    <code>susceptibility</code>, <code>itimer</code>, and <code>nodeid</code> arrays, and a <code>params</code> object with <code>inf_mean</code>.</p> required <code>ninfections</code> <code>int</code> <p>The number of individuals to infect. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The node IDs of the newly infected individuals.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly_SI","title":"<code>laser.generic.utils.seed_infections_randomly_SI(model, ninfections=100)</code>","text":"<p>Randomly seed initial infections for SI-style models without using timers.</p> <p>This function randomly selects <code>ninfections</code> individuals from the population who are currently susceptible and marks them as infected by setting their <code>susceptibility</code> to zero. It does not assign any infection timers, making it suitable for simple SI or SIR models where timers are not required.</p> <p>Unlike other seeding methods, this function explicitly ensures that only susceptible individuals are infected, even if the total population includes recovered or previously infected agents.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly_SI--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model, which must contain a <code>population</code> with    <code>count</code> and <code>susceptibility</code> attributes, and a PRNG in <code>model.prng</code>.</p> required <code>ninfections</code> <code>int</code> <p>Number of initial infections to seed. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly_SI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly_SI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.seed_infections_randomly_SI--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_in_patch","title":"<code>laser.generic.utils.set_initial_susceptibility_in_patch(model, ipatch, susc_frac=1.0)</code>","text":"<p>Randomly assign susceptibility levels to individuals in a specific patch at the start of the simulation.</p> <p>This function sets a random fraction of individuals in the specified patch to be fully immune (susceptibility = 0), based on the given <code>susc_frac</code> value. The remaining individuals retain their default susceptibility.</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_in_patch--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model, which must contain a <code>population</code> object with    <code>susceptibility</code>, <code>nodeid</code>, and <code>count</code> attributes.</p> required <code>ipatch</code> <code>int</code> <p>The index of the patch in which to set susceptibility.</p> required <code>susc_frac</code> <code>float</code> <p>The fraction (0.0 to 1.0) of individuals in the patch                          to remain susceptible. Defaults to 1.0 (i.e., all remain susceptible).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_in_patch--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_randomly","title":"<code>laser.generic.utils.set_initial_susceptibility_randomly(model, susc_frac=1.0)</code>","text":"<p>Randomly assign susceptibility levels to individuals in the population at the start of the simulation.</p> <p>This function sets a random fraction of the population to be fully immune (susceptibility = 0), based on the given <code>susc_frac</code> value. The rest retain their default susceptibility (typically 1.0).</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_randomly--glossary","title":"Glossary","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model containing the population and parameters. The model must have    a <code>population</code> object with a <code>susceptibility</code> attribute and a <code>count</code> attribute.</p> required <code>susc_frac</code> <code>float</code> <p>The fraction (0.0 to 1.0) of the population to remain susceptible.                          Defaults to 1.0 (i.e., no initial immunity).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_randomly--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_randomly--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#laser.generic.utils.set_initial_susceptibility_randomly--glossary","title":"Glossary","text":""},{"location":"reference/laser/generic/utils/#glossary","title":"Glossary","text":""},{"location":"software-overview/","title":"Software overview","text":"<p>LASER is a modeling framework that includes a variety of ways for users to implement the code to model infectious diseases.</p>"},{"location":"software-overview/#design-principles","title":"Design principles","text":"<p>The philosophy driving the development of LASER was to create a framework that was flexible, powerful, and fast, able to tackle a variety of complex modeling scenarios without sacrificing performance. But complexity often slows performance, and not every modeling question requires a full suite of model features. To solve this problem, LASER was designed as a set of core components, each with fundamental features that could be added--or not--to build working models. Users can optimize performance by creating models tailored to their research needs, only using components necessary for their modeling question. This building-block framework enables parsimony in model design, but also facilitates the building of powerful models with bespoke, complex dynamics.</p>"},{"location":"software-overview/#software-architecture","title":"Software architecture","text":""},{"location":"software-overview/#input-and-output-files","title":"Input and output files","text":""},{"location":"software-overview/#software-components","title":"Software components","text":"<p>Components are modular units of functionality within the simulation, responsible for performing specific updates or computations on the agent population or node-level data. Each component is implemented as a class with an initialization function to set up any required state and a step function to execute the component\u2019s logic during each timestep.</p> <p>Components vary in their complexity and functionality. Some may be simple counters or used for general accounting purposes, such as tracking individuals in different diseases states, while others will include disease dynamics or even data analysis functionality. LASER enables users to customize which components are used in order to help customize model functions to specific research questions, while providing basic set up examples and ready-to-use model configurations. The following sections provide background on some of the main components; see the API documentation for all class information.</p>"},{"location":"software-overview/#glossary","title":"Glossary","text":""},{"location":"software-overview/database/","title":"Simulation data and properties","text":"<p>LASER is designed to handle large populations with high numbers of independent agents. In order to track agents and their properties, LASER includes functions that store and update this information.</p> <p>The classes described below are only a subset of LASER components. For a full list of all LASER classes, see the API reference.</p>"},{"location":"software-overview/database/#laserframe-and-propertyset","title":"LaserFrame and PropertySet","text":"<p><code>LaserFrame</code> can be thought of as a database system for LASER models. It is a class that is used to dynamically manage and allocate data for nodes and agents, and supports both scalar and vector properties.</p> <p><code>PropertySet</code> stores agent properties in a dictionary-like object. Properties can be dynamically updated and this class is used to help define simulation parameters.</p> <p>The tutorial Build SIR models demonstrates how these two classes can be implemented.</p>"},{"location":"software-overview/database/#sortedque","title":"SortedQue","text":"<p>Timing of events is an important function for agent-based models. Management and tracking of values, especially as the number of agents reaches the millions, can be problematic. <code>SortedQue</code> is a custom process created for LASER to track and sort these values, and works directly with <code>LaserFrame</code> object arrays.</p>"},{"location":"software-overview/database/#glossary","title":"Glossary","text":""},{"location":"software-overview/migration/","title":"Migration","text":"<p>The ability to add spatial dynamics to LASER models is one of the features that makes the framework so powerful. There are multiple methods available for adding migration to your model, and the class you choose will depend on which features are important for your research question. Each of the migration models will distribute your population of agents among a set of nodes, with set distances between nodes, and utilize a matrix to define the connection between nodes. How agents or infectivity travels between the nodes (and which nodes they may travel to) will be determined by the specific migration model you choose.</p>"},{"location":"software-overview/migration/#sequential-migration-matrix","title":"Sequential migration matrix","text":""},{"location":"software-overview/migration/#gravity-model","title":"Gravity model","text":"<p>The gravity model can be used to compute the migration of people between nodes located at specific distances, with migration rates proportional to population size and the distance between nodes. This type of migration is useful when you would like to add 2-dimensional movement of agents to nodes.</p> <p>Functional form:</p> \\[ M_{ij} = k \\frac{P_i^{a} P_j^{b}}{d_{ij}^{c}} \\] <p>Where:</p> <ul> <li>\\(M_{ij}\\) = migration flow from origin i to destination j</li> <li>\\(P_i, P_j\\) = populations of origin and destination</li> <li>\\(d_{ij}\\) = distance between i and j</li> <li>\\(k\\) = Parameter: scaling constant</li> <li>\\(a\\) = Parameter: exponent for the population of the origin</li> <li>\\(b\\) = Parameter: exponent for the population of the destination</li> <li>\\(c\\) = Parameter: exponent for the distance</li> </ul> <p>The following example demonstrates implementing the gravity model to calculate the number of migrants moving between nodes. Agents are randomly assigned to different migration paths.</p> <pre><code>import numpy as np\nfrom laser_core.migration import gravity\n\n# Define populations and distances\npopulations = np.array([5000, 10000, 15000, 20000, 25000])  # Unequal populations\ndistances = np.array([\n    [0.0, 10.0, 15.0, 20.0, 25.0],\n    [10.0, 0.0, 10.0, 15.0, 20.0],\n    [15.0, 10.0, 0.0, 10.0, 15.0],\n    [20.0, 15.0, 10.0, 0.0, 10.0],\n    [25.0, 20.0, 15.0, 10.0, 0.0]\n])\n\n# Gravity model parameters\nk = 0.1    # Scaling constant\na = 0.5    # Exponent for the population of the origin\nb = 1.0    # Exponent for the population of the destination\nc = 2.0    # Exponent for the distance\n\n# Compute the gravity model network\nmigration_network = gravity(populations, distances, k=k, a=a, b=b, c=c)\n\n# Normalize to ensure total migrations represent 1% of the population\ntotal_population = np.sum(populations)\nmigration_fraction = 0.01  # 1% of the population migrates\nscaling_factor = (total_population * migration_fraction) / np.sum(migration_network)\nmigration_network *= scaling_factor\n\n# Generate a node ID array for agents\nnode_ids = np.concatenate([np.full(count, i) for i, count in enumerate(populations)])\n\n# Initialize a 2D array for migration counts\nmigration_matrix = np.zeros_like(distances, dtype=int)\n\n# Select migrants based on the gravity model\nfor origin in range(len(populations)):\n    for destination in range(len(populations)):\n        if origin != destination:\n            # Number of migrants to move from origin to destination\n            num_migrants = int(migration_network[origin, destination])\n            # Select migrants randomly\n            origin_ids = np.where(node_ids == origin)[0]\n            selected_migrants = np.random.choice(origin_ids, size=num_migrants, replace=False)\n            # Update the migration matrix\n            migration_matrix[origin, destination] = num_migrants\n</code></pre>"},{"location":"software-overview/migration/#the-competing-destinations-model","title":"The competing destinations model","text":"<p>The competing destinations model extends the gravity model by incorporating the fact that nodes may not be independent, but instead may \"compete\" with each other for incoming agents. Some nodes may be more or less attractive than other nodes, regardless of their proximity to the origin node. There may  be synergistic or antagonistic effects of nodes, creating specific networks and relationships among a series of nodes.</p> <p>For example, in a \u201csynergistic\u201d version, perhaps migratory flow from Boston to Baltimore is higher than flow between two comparator cities of similar population and at similar distance, because the proximity of Washington, D.C. to Baltimore makes travel to Baltimore more attractive to Bostonians. This would be accounted for by a positive value of \\(\\delta\\). On the other hand, this term may also be \u201cantagonistic\u201d if Washington is such an attractive destination that Bostonians eschew travel to Baltimore entirely; this would indicate a negative value of \\(\\delta\\).</p> <p>Functional form:</p> \\[ M_{i,j} = k \\frac{P_i^{a} P_j^{b}}{d_{ij}^{c}} \\left(\\sum_{k \\neq i,j} \\frac{P_k^{b}}{d_{jk}^{c}}\\right)^{\\delta} \\]"},{"location":"software-overview/migration/#stouffers-rank-model","title":"Stouffer's rank model","text":"<p>Stouffer argued that human mobility patterns do not respond to absolute distance directly, but only indirectly through the accumulation of intervening opportunities for destinations. Stouffer thus proposed a model with no distance-dependence at all, rather only a term that accounts for all potential destinations closer than destination \\(j\\); thus, longer-distance travel depends on the density of attractive destinations at shorter distances.</p> <p>Mathematical formulation:</p> <p>Define \\(\\Omega (i,j)\\) to be the set of all locations \\(k\\) such that \\(D_{i,k} \\leq D_{i,j}\\)</p> \\[ M_{i,j} = kp_i^a \\sum_j \\left(\\frac{p_j}{\\sum_{k \\in D(i,j)} p_k}\\right)^b \\] <p>This presents us with the choice of whether or not the origin population \\(i\\) is included in \\(\\Omega\\) - i.e., does the same \"gravity\" that brings others to visit a community reduce the propensity of that community's members to travel to other communities?</p> <p>This Stouffer model does not include the impact from the local community:</p> \\[ \\Omega(i,j) = \\left(k:0 &lt; D_{i,k} \\leq D_{i,j}\\right). \\] <p>The Stouffer variant model does include the impact of the local community:</p> \\[ \\Omega(i,j) = \\left(k:0 \\leq D_{i,k} \\leq D_{i,j}\\right). \\] <p>To simplify the code, <code>laser-core</code>'s implementation of the Stouffer model includes a parameter <code>include_home</code>.</p>"},{"location":"software-overview/migration/#radiation-model","title":"Radiation model","text":"<p>The radiation model is a parameter-free model (up to an overall scaling constant for total migration flux), derived from arguments around job-related commuting. The radiation model overcomes limitations of the gravity model (which is limited to flow at two specific points and is proportional to the populations at source and destination) by only requiring data on population densities. It can describe situations in which outbound migration flux from origin to destination is enhanced by destination population and absorbed by the density of nearer destinations.</p> <p>Mathematical formulation, whith \\(\\Omega\\) defined as above in the Stouffer model:</p> \\[ M_{i,j} = k \\frac{p_i p_j}{\\left(p_i + \\sum_{k \\in \\theta(i,j)} p_k\\right) \\left(p_i + p_j + \\sum_{k \\in \\theta(i,j)} p_k\\right)} \\] <p>We again use the parameter <code>include_home</code> to determine whether or not location \\(i\\) is to be included in \\(\\Omega(i,j)\\).</p>"},{"location":"software-overview/migration/#glossary","title":"Glossary","text":""},{"location":"software-overview/transmission/","title":"Disease transmission","text":""},{"location":"software-overview/transmission/#transmission-modes","title":"Transmission modes","text":"<p>The LASER framework includes modules for canonical transmission dynamics, including SI, SIS, SIR, SIRS, SEIR, and SEIRS.</p> <p>To build and explore model dynamics, see the Tutorials section.</p>"},{"location":"software-overview/transmission/#immunization","title":"Immunization","text":"<p>Immunity can be introduced into the agent population through several component types.</p> <p>Routine immunization (RI) can be implemented, such that at specified time steps susceptible agents whose age falls within a specified age range will be selected through a binomial draw to be immunized. Routine immunization events can be set up as recurring events that will continuously sample agents in the specified age range at specified time steps to provide immunization coverage.</p> <p>Immunization campaigns can be implemented, such that agents within an age band can be targeted for specific immunization events.</p>"},{"location":"software-overview/transmission/#glossary","title":"Glossary","text":""},{"location":"software-overview/demographics/","title":"Demographics","text":""},{"location":"software-overview/demographics/#age-structure","title":"Age structure","text":"<p>If you want to work with age structure for a short simulation which doesn\u2019t need births you can just give everyone an age (based on distribution) and increment it each timestep. The <code>laser_core.demographics.pyramid</code> module is provided to support the initialization of agents with plausible initial ages.</p>"},{"location":"software-overview/demographics/#births","title":"Births","text":""},{"location":"software-overview/demographics/#preborn-management-in-laser","title":"Preborn management in LASER","text":"<p>LASER\u2019s design philosophy emphasizes contiguous and fixed-size arrays, meaning all agents\u2014both currently active and preborn\u2014are created at the start of the simulation. Preborns are \u201cactivated\u201d as they are born, rather than being dynamically added. Several approaches to handling preborns while adhering to these principles are outlined below:</p> <p>Negative and Positive Birthdays:</p> <ul> <li>Assign <code>date_of_birth</code> values in the past (negative) for active agents.</li> <li>Assign <code>date_of_birth</code> values in the future (positive) for preborns.</li> </ul> <p>Unified Preborn Marker:</p> <ul> <li>Set all preborns\u2019 <code>date_of_birth</code> to a placeholder value (e.g., -1).</li> <li>Update the <code>date_of_birth</code> to the current timestep when a preborn is born.</li> </ul> <p>Active Flag Only (if not modeling age structure):</p> <ul> <li>If the model doesn\u2019t require age structure, you can skip date_of_birth entirely. Instead, use an active flag. Preborns start with <code>active = False</code> and are switched to <code>active = True</code> during the fertility step. This simplifies implementation while remaining consistent with LASER principles.</li> </ul>"},{"location":"software-overview/demographics/#calculating-age-from-birthday","title":"Calculating age from birthday","text":"<p>If calculating age isn\u2019t frequent or essential, you can avoid explicitly tracking an age property. Instead, compute age dynamically as the difference between the current timestep (now) and <code>date_of_birth</code>. For models that depend on age-specific dynamics (e.g., fertility rates by age group), consider adding a dedicated age property that updates at each timestep.</p>"},{"location":"software-overview/demographics/#deaths","title":"Deaths","text":"<p>The recommended way of doing mortality in LASER is by precalculating a lifespan for each agent, rather than probabilistically killing agents as the simulation runs. This can take different forms: If you prefer to track agent age, you can also have an agent lifespan. Alternatively, if you are just using <code>date_of_birth</code> you can have a <code>date_of_death</code>, where theses \u2018dates\u2019 are really simulation times (\u2018sim day of birth\u2019 and \u2018sim day of death\u2019).</p> <p>In LASER, we strive to leave the contiguous arrays of agent data in place, without adding or deleting elements (allocating or freeing). This means that to model mortality, we prefer to \u2018kill\u2019 agents by doing either:</p> <ol> <li> <p>check that their age is greater than their lifespan (or that the current timestep is greater than their \u2018sim day of death\u2019) in each component that cares, or</p> </li> <li> <p>Set an active flag to \"false\" or a dead flag to \"true.\"</p> </li> </ol> <p>The second approach is simpler, and avoids doing millions of comparison operations, at the cost of an additional property. Note that many component operations (step functions) can be done without checking whether the agent is alive, because, for example, as long as transmission never infects a dead person, decrementing all non-zero infection timers will only operate on live agents.</p> <p>Finally, while you can set lifespans using any algorithm you want, <code>laser_core.demographics.kmestimator</code> is provided to support these calculations.</p>"},{"location":"software-overview/demographics/#population-pyramids","title":"Population pyramids","text":"<p>The <code>AliasedDistribution</code> class provides a way to sample from a set of options with unequal probabilities, e.g., a population pyramid.</p> <p>The input to the <code>AliasedDistribution</code> constructor is an array of counts by bin as we would naturally get from a population pyramid (# of people in each age bin).</p> <p><code>AliasedDistribution.sample()</code> returns bin indices so it is up to the user to convert the values returned from <code>sample()</code> to actual ages.</p> <p>Expected format of the population pyramid CSV file for <code>load_pyramid_csv()</code>:</p> <pre><code>Header: Age,M,F\nstart-end,#males,#females\nstart-end,#males,#females\nstart-end,#males,#females\n\u2026\nstart-end,#males,#females\nmax+,#males,#females\n</code></pre> <p>For example,</p> <pre><code>Age,M,F\n0-4,9596708,9175309\n5-9,10361680,9904126\n10-14,10781688,10274310\n15-19,11448281,10950664\n\u2026\n90-94,757034,1281854\n95-99,172530,361883\n100+,27665,76635\n</code></pre> <p><code>load_pyramid_csv()</code> returns a 4 column NumPy array with the following columns:</p> <pre><code>0 - Lower bound of age bin, inclusive\n1 - Upper bound of age bin, inclusive\n2 - number of males in the age bin\n3 - number of females in the age bin\n</code></pre> Code example: Loading population pyramids from .csv files <pre><code>import numpy as np\nfrom laser_core.demographics import load_pyramid_csv, AliasedDistribution\nimport importlib.util\nimport os\n\nMCOL = 2\nFCOL = 3\n\nMINCOL = 0\nMAXCOL = 1\n\n# Access the bundled file dynamically\nlaser_core_path = importlib.util.find_spec(\"laser_core\").origin\nlaser_core_dir = os.path.dirname(laser_core_path)\npyramid_file = os.path.join(laser_core_dir, \"data/us-pyramid-2023.csv\")\n\npyramid = load_pyramid_csv(pyramid_file)\nsampler = AliasedDistribution(pyramid[:, MCOL])    # We'll use the male population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = pyramid[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (pyramid[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(pyramid)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n\n# in some LASER models we convert current ages to dates of birth by negating the age\n# dob = -ages\n</code></pre> <p>To explore working with age pyramids, see Age pyramid examples.</p>"},{"location":"software-overview/demographics/#kaplan-meier-estimators","title":"Kaplan-Meier estimators","text":"<p>The <code>KaplanMeierEstimator</code> is used to predict age or year of death. It takes an array of cumulative deaths and returns an object that will sample from the Kaplan-Meier distribution.</p> <p>A sample input array of cumulative deaths might look like this:</p> <pre><code>cd[0] = 687 # 687 deaths in the first year (age 0)\ncd[1] = 733 # +46 deaths in the second year (age 1)\ncd[2] = 767 # +34 deaths in the third year (age 2)\n...\ncd[100] = 100_000  # 100,000 deaths by end of year\n</code></pre> <p><code>predict_year_of_death()</code> takes an array of current ages (in years) and returns an array of predicted years of death based on the cumulative deaths input array.</p> <p>Note</p> <p><code>predict_year_of_death()</code> can use non-constant width age bins and will return predictions by age bin. In this case, it is up to the user to convert the returned bin indices to actual years.</p> <p>A sample non-constant width age bin input array might look like this:</p> <pre><code>cd[0] = 340 # 1/2 of first year deaths in the first 3 months\ncd[1] = 510 # another 1/4 (+170) of first year deaths in the next 3 months\ncd[2] = 687 # another 1/4 (+177) of first year deaths in the last 6 months\ncd[3] = 733 # 46 deaths in the second year (age 1)\ncd[4] = 767 # 34 deaths in the third year (age 2)\n...\ncd[103] = 100_000  # 100,000 deaths by end of year 100\n</code></pre> <p>In this example, values returned from predict_year_of_death() would need to be mapped as follows:</p> <pre><code>0 -&gt; (0, 3] months\n1 -&gt; (3, 6] months\n2 -&gt; (6, 12] months\n3 -&gt; 1 year\n4 -&gt; 2 years\n...\n102 -&gt; 100 years\n</code></pre> <p><code>predict_age_at_death()</code> takes an array of current ages (in days) and returns an array of predicted ages (in days) at death. The implementation assumes that the cumulative deaths input array to the estimator represents one year age bins. If you are using non-constant width age bins, you should manually convert bin indices returned from <code>predict_year_of_death()</code> to ages.</p> <p>To explore working with Kapaln-Meier estimators, see Non-disease death estimation.</p>"},{"location":"software-overview/demographics/#spatial-distributions-of-populations","title":"Spatial distributions of populations","text":"<p>For spatial models, LASER includes functions to distribute populations across nodes. Populations may be distributed in either a skewed or tapered pattern.</p> <p>For a skewed distribution, populations are distributed across nodes according to a simple exponential random distribution, with adjustments to ensure the total population and the specified fraction of rural population is adhered to.</p> <p>For a tapered distribution, populations are distributed following a logarithmic-like decay pattern where the first node (node 0) receives the largest subset of the population (typically half the population), and subsequent nodes receive progressively smaller proportions.</p>"},{"location":"software-overview/demographics/#glossary","title":"Glossary","text":""},{"location":"software-overview/demographics/age_pyramid/","title":"Age pyramid examples","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom IPython.display import Image\nImage(filename=\"Nigeria-2024.png\")\nImage(filename=\"UnitedStates-2024.png\")\nimport numpy as np\n\nfrom laser_core.demographics import AliasedDistribution\nfrom laser_core.demographics import load_pyramid_csv\n</pre> from pathlib import Path from IPython.display import Image Image(filename=\"Nigeria-2024.png\") Image(filename=\"UnitedStates-2024.png\") import numpy as np  from laser_core.demographics import AliasedDistribution from laser_core.demographics import load_pyramid_csv  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 7\n      4 Image(filename=\"UnitedStates-2024.png\")\n      5 import numpy as np\n----&gt; 7 from laser_core.demographics import AliasedDistribution\n      8 from laser_core.demographics import load_pyramid_csv\n\nModuleNotFoundError: No module named 'laser_core'</pre> In\u00a0[2]: Copied! <pre>MCOL = 2\nFCOL = 3\n\nMINCOL = 0\nMAXCOL = 1\n\nnigeria = load_pyramid_csv(Path.cwd() / \"Nigeria-2024.csv\")\nsampler = AliasedDistribution(nigeria[:, MCOL])    # We'll use the male population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = nigeria[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (nigeria[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(nigeria)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n</pre> MCOL = 2 FCOL = 3  MINCOL = 0 MAXCOL = 1  nigeria = load_pyramid_csv(Path.cwd() / \"Nigeria-2024.csv\") sampler = AliasedDistribution(nigeria[:, MCOL])    # We'll use the male population in this example. n_agents = 100_000 samples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution. # samples will be bin indices, so we need to convert them to ages. bin_min_age_days = nigeria[:, MINCOL] * 365          # minimum age for bin, in days (include this value) bin_max_age_days = (nigeria[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value) mask = np.zeros(n_agents, dtype=bool) ages = np.zeros(n_agents, dtype=np.int32) for i in range(len(nigeria)):   # for each possible bin value...     mask[:] = samples == i      # ...find the agents that belong to this bin     # ...and assign a random age, in days, within the bin     ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 7\n      4 MINCOL = 0\n      5 MAXCOL = 1\n----&gt; 7 nigeria = load_pyramid_csv(Path.cwd() / \"Nigeria-2024.csv\")\n      8 sampler = AliasedDistribution(nigeria[:, MCOL])    # We'll use the male population in this example.\n      9 n_agents = 100_000\n\nNameError: name 'load_pyramid_csv' is not defined</pre> In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, ax1 = plt.subplots()\n\n# Plot histogram of samples on primary y-axis\n\nfraction = nigeria[:, MCOL]/nigeria[:, MCOL:FCOL+1].sum()\nax1.plot(fraction, color=\"green\")\nax1.set_xlabel(\"Age Bin\")\nbins = [f\"{i, j}\" for i, j in zip(nigeria[:, MINCOL], nigeria[:, MAXCOL])]\nplt.xticks(rotation=90)\nax1.set_xticks(ticks=range(len(bins)), labels=bins)\nax1.set_ylim(-0.01, 0.1)\nax1.set_ylabel(\"% Population (Input)\", color=\"green\")\n\n# Create secondary y-axis\nax2 = ax1.twinx()\n\n# We will calculate the histogram manually because the final bin isn't the same width as the others.\nhistogram = np.zeros(21, dtype=np.int32)\nfor i in range(histogram.shape[0]):\n    mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices\n    histogram[i] = mask.sum()\n\nscale = nigeria[:,MCOL].sum() / nigeria[:,MCOL:FCOL+1].sum()   # male / male+female\nfraction = (histogram*scale)/histogram.sum()\nax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\")\nax2.set_ylim(-0.01, 0.1)\nax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")\n\nplt.title(\"Age Distribution in Nigeria\")\nplt.show()\n</pre> import matplotlib.pyplot as plt  fig, ax1 = plt.subplots()  # Plot histogram of samples on primary y-axis  fraction = nigeria[:, MCOL]/nigeria[:, MCOL:FCOL+1].sum() ax1.plot(fraction, color=\"green\") ax1.set_xlabel(\"Age Bin\") bins = [f\"{i, j}\" for i, j in zip(nigeria[:, MINCOL], nigeria[:, MAXCOL])] plt.xticks(rotation=90) ax1.set_xticks(ticks=range(len(bins)), labels=bins) ax1.set_ylim(-0.01, 0.1) ax1.set_ylabel(\"% Population (Input)\", color=\"green\")  # Create secondary y-axis ax2 = ax1.twinx()  # We will calculate the histogram manually because the final bin isn't the same width as the others. histogram = np.zeros(21, dtype=np.int32) for i in range(histogram.shape[0]):     mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices     histogram[i] = mask.sum()  scale = nigeria[:,MCOL].sum() / nigeria[:,MCOL:FCOL+1].sum()   # male / male+female fraction = (histogram*scale)/histogram.sum() ax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\") ax2.set_ylim(-0.01, 0.1) ax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")  plt.title(\"Age Distribution in Nigeria\") plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 7\n      3 fig, ax1 = plt.subplots()\n      5 # Plot histogram of samples on primary y-axis\n----&gt; 7 fraction = nigeria[:, MCOL]/nigeria[:, MCOL:FCOL+1].sum()\n      8 ax1.plot(fraction, color=\"green\")\n      9 ax1.set_xlabel(\"Age Bin\")\n\nNameError: name 'nigeria' is not defined</pre> In\u00a0[4]: Copied! <pre>america = load_pyramid_csv(Path.cwd() / \"United States of America-2024.csv\")\nsampler = AliasedDistribution(america[:, FCOL])    # We'll use the female population in this example.\nn_agents = 100_000\nsamples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution.\n# samples will be bin indices, so we need to convert them to ages.\nbin_min_age_days = america[:, MINCOL] * 365          # minimum age for bin, in days (include this value)\nbin_max_age_days = (america[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value)\nmask = np.zeros(n_agents, dtype=bool)\nages = np.zeros(n_agents, dtype=np.int32)\nfor i in range(len(america)):   # for each possible bin value...\n    mask[:] = samples == i      # ...find the agents that belong to this bin\n    # ...and assign a random age, in days, within the bin\n    ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())\n</pre> america = load_pyramid_csv(Path.cwd() / \"United States of America-2024.csv\") sampler = AliasedDistribution(america[:, FCOL])    # We'll use the female population in this example. n_agents = 100_000 samples = sampler.sample(n_agents)              # Sample 100,000 people from the distribution. # samples will be bin indices, so we need to convert them to ages. bin_min_age_days = america[:, MINCOL] * 365          # minimum age for bin, in days (include this value) bin_max_age_days = (america[:, MAXCOL] + 1) * 365    # maximum age for bin, in days (exclude this value) mask = np.zeros(n_agents, dtype=bool) ages = np.zeros(n_agents, dtype=np.int32) for i in range(len(america)):   # for each possible bin value...     mask[:] = samples == i      # ...find the agents that belong to this bin     # ...and assign a random age, in days, within the bin     ages[mask] = np.random.randint(bin_min_age_days[i], bin_max_age_days[i], mask.sum())  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 america = load_pyramid_csv(Path.cwd() / \"United States of America-2024.csv\")\n      2 sampler = AliasedDistribution(america[:, FCOL])    # We'll use the female population in this example.\n      3 n_agents = 100_000\n\nNameError: name 'load_pyramid_csv' is not defined</pre> In\u00a0[5]: Copied! <pre>fig, ax1 = plt.subplots()\n\n# Plot histogram of samples on primary y-axis\n\nfraction = america[:, FCOL]/america[:, MCOL:FCOL+1].sum()\nax1.plot(fraction, color=\"g\")\nax1.set_xlabel(\"Age Bin\")\nplt.xticks(rotation=90)\nbins = [f\"{i, j}\" for i, j in zip(america[:, MINCOL], america[:, MAXCOL])]\nax1.set_xticks(ticks=range(len(bins)), labels=bins)\nax1.set_ylim(-0.01, 0.05)\nax1.set_ylabel(\"% Population (Input)\", color=\"g\")\n\n# We will calculate the histogram manually because the final bin isn't the same width as the others.\nhistogram = np.zeros(21, dtype=np.int32)\nfor i in range(histogram.shape[0]):\n    mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices\n    histogram[i] = mask.sum()\n\n# Create secondary y-axis\nax2 = ax1.twinx()\nscale = america[:,FCOL].sum() / america[:,MCOL:FCOL+1].sum()   # female / male+female\nfraction = (histogram*scale)/histogram.sum()\nax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\")\nax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\")\nax2.set_ylim(-0.01, 0.05)\n\n\nplt.title(\"Age Distribution in the United States\")\nplt.show()\n</pre> fig, ax1 = plt.subplots()  # Plot histogram of samples on primary y-axis  fraction = america[:, FCOL]/america[:, MCOL:FCOL+1].sum() ax1.plot(fraction, color=\"g\") ax1.set_xlabel(\"Age Bin\") plt.xticks(rotation=90) bins = [f\"{i, j}\" for i, j in zip(america[:, MINCOL], america[:, MAXCOL])] ax1.set_xticks(ticks=range(len(bins)), labels=bins) ax1.set_ylim(-0.01, 0.05) ax1.set_ylabel(\"% Population (Input)\", color=\"g\")  # We will calculate the histogram manually because the final bin isn't the same width as the others. histogram = np.zeros(21, dtype=np.int32) for i in range(histogram.shape[0]):     mask = (ages // 1825) == i  # Convert ages in days to 5-year bin indices     histogram[i] = mask.sum()  # Create secondary y-axis ax2 = ax1.twinx() scale = america[:,FCOL].sum() / america[:,MCOL:FCOL+1].sum()   # female / male+female fraction = (histogram*scale)/histogram.sum() ax2.plot(range(histogram.shape[0]), fraction, color=\"orange\", marker=\"x\") ax2.set_ylabel(\"% Population (Sampled)\", color=\"orange\") ax2.set_ylim(-0.01, 0.05)   plt.title(\"Age Distribution in the United States\") plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 5\n      1 fig, ax1 = plt.subplots()\n      3 # Plot histogram of samples on primary y-axis\n----&gt; 5 fraction = america[:, FCOL]/america[:, MCOL:FCOL+1].sum()\n      6 ax1.plot(fraction, color=\"g\")\n      7 ax1.set_xlabel(\"Age Bin\")\n\nNameError: name 'america' is not defined</pre>"},{"location":"software-overview/demographics/age_pyramid/#age-pyramid-examples","title":"Age pyramid examples\u00b6","text":"<p>We will use a U.S. age pyramid and a Nigerian age pyramid for examples.</p>"},{"location":"software-overview/demographics/age_pyramid/#nigeria","title":"Nigeria\u00b6","text":"<p>Source: https://www.populationpyramid.net/nigeria/2024/</p> <p></p>"},{"location":"software-overview/demographics/age_pyramid/#united-states","title":"United States\u00b6","text":"<p>Source: https://www.populationpyramid.net/united-states-of-america/2024/</p> <p></p>"},{"location":"software-overview/demographics/kmestimator/","title":"Date of non-disease death estimation","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\ncumulative = np.array([\n     8131,  9396, 10562, 11636, 12620, 13506, 14287, 14958, 15523, 15997,   # year  0.. 9\n    16400, 16756, 17083, 17401, 17725, 18067, 18437, 18837, 19268, 19726,   # year 10..19\n    20207, 20705, 21215, 21732, 22256, 22785, 23319, 23860, 24407, 24961,   # year 20..29\n    25522, 26091, 26668, 27252, 27845, 28446, 29059, 29684, 30324, 30979,   # year 30..39\n    31649, 32334, 33031, 33737, 34452, 35176, 35913, 36666, 37442, 38247,   # year 40..49\n    39085, 39959, 40869, 41815, 42795, 43811, 44866, 45966, 47118, 48330,   # year 50..59\n    49608, 50958, 52380, 53876, 55442, 57080, 58790, 60574, 62435, 64372,   # year 60..69\n    66380, 68451, 70569, 72719, 74880, 77039, 79179, 81288, 83353, 85355,   # year 70..79\n    87274, 89085, 90766, 92299, 93672, 94884, 95936, 96837, 97594, 98216,   # year 80..89\n    98713, 99097, 99383, 99590, 99735, 99833, 99897, 99939, 99965, 99980,   # year 90..99\n    100000, # year 100+\n], dtype=np.int32)\n</pre> import numpy as np  cumulative = np.array([      8131,  9396, 10562, 11636, 12620, 13506, 14287, 14958, 15523, 15997,   # year  0.. 9     16400, 16756, 17083, 17401, 17725, 18067, 18437, 18837, 19268, 19726,   # year 10..19     20207, 20705, 21215, 21732, 22256, 22785, 23319, 23860, 24407, 24961,   # year 20..29     25522, 26091, 26668, 27252, 27845, 28446, 29059, 29684, 30324, 30979,   # year 30..39     31649, 32334, 33031, 33737, 34452, 35176, 35913, 36666, 37442, 38247,   # year 40..49     39085, 39959, 40869, 41815, 42795, 43811, 44866, 45966, 47118, 48330,   # year 50..59     49608, 50958, 52380, 53876, 55442, 57080, 58790, 60574, 62435, 64372,   # year 60..69     66380, 68451, 70569, 72719, 74880, 77039, 79179, 81288, 83353, 85355,   # year 70..79     87274, 89085, 90766, 92299, 93672, 94884, 95936, 96837, 97594, 98216,   # year 80..89     98713, 99097, 99383, 99590, 99735, 99833, 99897, 99939, 99965, 99980,   # year 90..99     100000, # year 100+ ], dtype=np.int32) In\u00a0[2]: Copied! <pre>from laser_core.demographics import KaplanMeierEstimator\n\nestimator = KaplanMeierEstimator(cumulative)\nnagents = 100_000\ndobs = np.zeros(nagents)    # dates of birth, newborns = 0\ndods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days\n</pre> from laser_core.demographics import KaplanMeierEstimator  estimator = KaplanMeierEstimator(cumulative) nagents = 100_000 dobs = np.zeros(nagents)    # dates of birth, newborns = 0 dods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 from laser_core.demographics import KaplanMeierEstimator\n      3 estimator = KaplanMeierEstimator(cumulative)\n      4 nagents = 100_000\n\nModuleNotFoundError: No module named 'laser_core'</pre> In\u00a0[3]: Copied! <pre>import matplotlib.pyplot as plt\n\nhistogram = np.zeros(cumulative.shape[0]+1, np.int32)\nyods = dods // 365  # years of death\nfor i in range(cumulative.shape[0]+1):\n    histogram[i] = np.sum(yods == i)\n\nfig, ax1 = plt.subplots()\n\ncolor = \"tab:orange\"\nax1.set_xlabel(\"Age\")\nax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color)\nax1.plot(np.cumsum(histogram), color=color, marker=\"x\")\nax1.tick_params(axis=\"y\", labelcolor=color)\n\nax2 = ax1.twinx()\ncolor = \"tab:green\"\nax2.set_ylabel(\"Input Cumulative Deaths\", color=color)\nax2.plot(cumulative, color=color)\nax2.tick_params(axis=\"y\", labelcolor=color)\n\nfig.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt  histogram = np.zeros(cumulative.shape[0]+1, np.int32) yods = dods // 365  # years of death for i in range(cumulative.shape[0]+1):     histogram[i] = np.sum(yods == i)  fig, ax1 = plt.subplots()  color = \"tab:orange\" ax1.set_xlabel(\"Age\") ax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color) ax1.plot(np.cumsum(histogram), color=color, marker=\"x\") ax1.tick_params(axis=\"y\", labelcolor=color)  ax2 = ax1.twinx() color = \"tab:green\" ax2.set_ylabel(\"Input Cumulative Deaths\", color=color) ax2.plot(cumulative, color=color) ax2.tick_params(axis=\"y\", labelcolor=color)  fig.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 4\n      1 import matplotlib.pyplot as plt\n      3 histogram = np.zeros(cumulative.shape[0]+1, np.int32)\n----&gt; 4 yods = dods // 365  # years of death\n      5 for i in range(cumulative.shape[0]+1):\n      6     histogram[i] = np.sum(yods == i)\n\nNameError: name 'dods' is not defined</pre> In\u00a0[4]: Copied! <pre>nagents = 100_000 - cumulative[49]          # how many 50+ years old do we expect?\ndobs = np.full(nagents, 365*50)             # dates of birth, 50 years old\ndobs += np.random.randint(0, 365, nagents)  # add random days\ndods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days\n</pre> nagents = 100_000 - cumulative[49]          # how many 50+ years old do we expect? dobs = np.full(nagents, 365*50)             # dates of birth, 50 years old dobs += np.random.randint(0, 365, nagents)  # add random days dods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 4\n      2 dobs = np.full(nagents, 365*50)             # dates of birth, 50 years old\n      3 dobs += np.random.randint(0, 365, nagents)  # add random days\n----&gt; 4 dods = estimator.predict_age_at_death(dobs, max_year=100)   # dates of death in days\n\nNameError: name 'estimator' is not defined</pre> In\u00a0[5]: Copied! <pre>histogram = np.zeros(cumulative.shape[0]+1, np.int32)\nyods = dods // 365  # years of death\nfor i in range(cumulative.shape[0]+1):\n    histogram[i] = np.sum(yods == i)\n\nfig, ax1 = plt.subplots()\n\ncolor = \"tab:orange\"\nax1.set_xlabel(\"Age\")\nax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color)\nax1.plot(np.cumsum(histogram), color=color, marker=\"x\")\nax1.tick_params(axis=\"y\", labelcolor=color)\n\nax2 = ax1.twinx()\ncolor = \"tab:green\"\nax2.set_ylabel(\"Input Cumulative Deaths (50+)\", color=color)\nsubsequent = np.maximum(cumulative - cumulative[49], 0)\nax2.plot(subsequent, color=color)\nax2.tick_params(axis=\"y\", labelcolor=color)\n\nfig.tight_layout()\nplt.show()\n</pre> histogram = np.zeros(cumulative.shape[0]+1, np.int32) yods = dods // 365  # years of death for i in range(cumulative.shape[0]+1):     histogram[i] = np.sum(yods == i)  fig, ax1 = plt.subplots()  color = \"tab:orange\" ax1.set_xlabel(\"Age\") ax1.set_ylabel(\"Cumulative Sampled Deaths\", color=color) ax1.plot(np.cumsum(histogram), color=color, marker=\"x\") ax1.tick_params(axis=\"y\", labelcolor=color)  ax2 = ax1.twinx() color = \"tab:green\" ax2.set_ylabel(\"Input Cumulative Deaths (50+)\", color=color) subsequent = np.maximum(cumulative - cumulative[49], 0) ax2.plot(subsequent, color=color) ax2.tick_params(axis=\"y\", labelcolor=color)  fig.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 2\n      1 histogram = np.zeros(cumulative.shape[0]+1, np.int32)\n----&gt; 2 yods = dods // 365  # years of death\n      3 for i in range(cumulative.shape[0]+1):\n      4     histogram[i] = np.sum(yods == i)\n\nNameError: name 'dods' is not defined</pre>"},{"location":"software-overview/demographics/kmestimator/#date-of-non-disease-death-estimation","title":"Date of non-disease death estimation\u00b6","text":"<p>The Kaplan-Meier estimator uses survival information to draw for a date of death based on current age.</p> <p>Current age may be non-zero for an initial population or zero for newborn agents.</p>"},{"location":"software-overview/demographics/kmestimator/#population-of-100000","title":"Population of 100,000\u00b6","text":"<p>The input to the Kaplan-Meier estimator is the cumulative number of deaths by bin/age.</p> <p>The following data from Nigeria follow a hypothetical 100,000-person population giving the cumulative number of deaths by each age.</p>"},{"location":"software-overview/demographics/kmestimator/#population-of-50000","title":"Population of 50,000\u00b6","text":"<p>The input to the Kaplan-Meier estimator is the cumulative number of deaths by bin/age.</p> <p>The following data from Nigeria follow a hypothetical 50,000-person population giving the cumulative number of deaths by each age.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The following code examples demonstrate how to build and run models using LASER.</p> <p>In the Notebooks section, interactive Jupyter notebooks will allow you to explore dynamics of pre-built LASER models, beginning with simple SI models with no demographics and adding in more complexity in each subsequent notebook.</p>"},{"location":"tutorials/#glossary","title":"Glossary","text":""},{"location":"tutorials/sir/","title":"Build SIR models","text":"<p>One of the simplest and most commonly used models to describe the progression of an outbreak or epidemic is the SIR (Susceptible - Infected - Recovered) model. We can use the SIR model to explore how to use the LASER framework, staring with a basic SIR model and adding complexity.</p> <p>This tutorial will:</p> <ul> <li>Demonstrate how the <code>LASERframe</code> and <code>PropertySet</code> libraries are used</li> <li>Structure a basic disease transmission framework</li> <li>Track and visualize results</li> </ul> <p>As you progress through the sections, you will learn how to add spatial dynamics and migration into the disease model, using both synthetic and real-world data.</p>"},{"location":"tutorials/sir/#simple-sir","title":"Simple SIR","text":"<p>The SIR model presented here simulates disease dynamics within a closed population in a single node using the <code>LASERFrame</code> framework. The population starts with a defined number of susceptible and infected individuals, progresses over time with recovery and transmission components, and tracks results for visualization. This example serves as a practical guide for modeling simple epidemic dynamics. This simple example does not include vital dynamics, age-structured populations, vaccination, or other complex interactions.</p>"},{"location":"tutorials/sir/#model-components","title":"Model components","text":"<p>The <code>SIRModel</code> class is the core of the implementation. It initializes a population using <code>LaserFrame</code>, sets up disease state and recovery timer properties, and tracks results across timesteps.</p> Code example: Implementing <code>SIRModel</code> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom laser.core import LaserFrame\nfrom laser.core import PropertySet\n\nclass SIRModel:\n    def __init__(self, params):\n        # Model Parameters\n        self.params = params\n\n        # Initialize the population LaserFrame\n        self.population = LaserFrame(capacity=params.population_size,initial_count=params.population_size)\n\n        # Add disease state property (0 = Susceptible, 1 = Infected, 2 = Recovered)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)\n\n        # Add a recovery timer property (for intrahost progression, optional for timing)\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n\n        # Results tracking\n        self.results = LaserFrame( capacity = 1 ) # number of nodes\n        self.results.add_vector_property( \"S\", length=params[\"timesteps\"], dtype=np.float32 )\n        self.results.add_vector_property( \"I\", length=params[\"timesteps\"], dtype=np.float32 )\n        self.results.add_vector_property( \"R\", length=params[\"timesteps\"], dtype=np.float32 )\n\n        # Components\n        self.components = []\n\n    def add_component(self, component):\n        self.components.append(component)\n\n    def track_results(self, tick):\n        susceptible = (self.population.disease_state == 0).sum()\n        infected = (self.population.disease_state == 1).sum()\n        recovered = (self.population.disease_state == 2).sum()\n        total = self.population.count\n        self.results.S[tick] = susceptible / total\n        self.results.I[tick] = infected / total\n        self.results.R[tick] = recovered / total\n\n    def run(self):\n        for tick in range(self.params.timesteps):\n            for component in self.components:\n                component.step()\n            self.track_results(tick)\n\n    def plot_results(self):\n        plt.figure(figsize=(10, 6))\n        plt.plot(self.results.S, label=\"Susceptible (S)\", color=\"blue\")\n        plt.plot(self.results.I, label=\"Infected (I)\", color=\"red\")\n        plt.plot(self.results.R, label=\"Recovered (R)\", color=\"green\")\n        plt.title(\"SIR Model Dynamics with LASER Components\")\n        plt.xlabel(\"Time (Timesteps)\")\n        plt.ylabel(\"Fraction of Population\")\n        plt.legend()\n        plt.grid()\n        plt.show()\n        plt.savefig(\"gpt_sir.png\")\n</code></pre> <p>The <code>IntrahostProgression</code> class manages recovery dynamics by updating infected individuals based on a given recovery rate.</p> Code example: Implementing <code>IntrahostProgression</code> <pre><code>class IntrahostProgression:\n    def __init__(self, model):\n        self.population = model.population\n\n        # Seed the infection\n        num_initial_infected = int(0.01 * params.population_size)  # e.g., 1% initially infected\n        infected_indices = np.random.choice(params.population_size, size=num_initial_infected, replace=False)\n        self.population.disease_state[infected_indices] = 1\n\n        # Initialize recovery timer for initially infected individuals\n        initially_infected = self.population.disease_state == 1\n        self.population.recovery_timer[initially_infected] = np.random.randint(5, 15, size=initially_infected.sum())\n\n    def step(self):\n        infected = self.population.disease_state == 1\n\n        # Decrement recovery timer\n        self.population.recovery_timer[infected] -= 1\n\n        # Recover individuals whose recovery_timer has reached 0\n        recoveries = infected &amp; (self.population.recovery_timer &lt;= 0)\n        self.population.disease_state[recoveries] = 2\n</code></pre> <p>The <code>Transmission</code> class manages disease spread by modeling interactions between susceptible and infected individuals.</p> Code example: Implementing <code>Transmission</code> <pre><code>class Transmission:\n    def __init__(self, model):\n        self.population = model.population\n        self.infection_rate = model.params.infection_rate\n\n    def step(self):\n        susceptible = self.population.disease_state == 0\n        infected = self.population.disease_state == 1\n\n        num_susceptible = susceptible.sum()\n        num_infected = infected.sum()\n        population_size = len(self.population)\n\n        # Fraction of infected and susceptible individuals\n        fraction_infected = num_infected / population_size\n\n        # Transmission logic: Probability of infection per susceptible individual\n        infection_probability = self.infection_rate * fraction_infected\n\n        # Apply infection probability to all susceptible individuals\n        new_infections = np.random.rand(num_susceptible) &lt; infection_probability\n\n        # Set new infections and initialize their recovery_timer\n        susceptible_indices = np.where(susceptible)[0]\n        newly_infected_indices = susceptible_indices[new_infections]\n        self.population.disease_state[newly_infected_indices] = 1\n        self.population.recovery_timer[newly_infected_indices] = np.random.randint(5, 15, size=newly_infected_indices.size)  # Random recovery time\n</code></pre> <p>The simulation parameters are defined using the <code>PropertySet</code> class.</p> Code example: Defining simulation parameters using <code>PropertySet</code> <pre><code>params = PropertySet({\n    \"population_size\": 100_000,\n    \"infection_rate\": 0.3,\n    \"timesteps\": 160\n})\n</code></pre> <p>The model is initialized with the defined parameters, components are added, and the simulation is run for the specified timesteps. Results are then visualized.</p> Code example: Intiailize, run the simulation, and plot the results <pre><code># Initialize the model\nsir_model = SIRModel(params)\n\n# Initialize and add components\nsir_model.add_component(IntrahostProgression(sir_model))\nsir_model.add_component(Transmission(sir_model))\n\n# Run the simulation\nsir_model.run()\n\n# Plot results\nsir_model.plot_results()\n</code></pre>"},{"location":"tutorials/sir/#spatial-sir","title":"Spatial SIR","text":"<p>Building upon the simple SIR  model created above, we can add spatial complexity to the framework. Here the simple SIR model will spread the population across 20 nodes. The nodes are arranged in a 1-dimensional chain and infection spreads spatially from node 0 as agents migrate; migration is based on a migration matrix.</p> <p>In this example, two migration options are available:</p> <ol> <li>Sequential migration matrix: Agents can only move to the next node in the chain.</li> <li>Gravity model migration matrix: Agents can move in a 2-dimensional spatial dynamic, where migration probabilities depend on node distances and population sizes.</li> </ol> <p>For this example, the population is distributed across nodes using a rural-urban skew, and migration timers are assigned to control agent migration frequency.</p>"},{"location":"tutorials/sir/#model-components_1","title":"Model components","text":"<p>As above, the model will require the use of <code>LaserFrame</code>, but will now also include spatial components.</p> Code example: Initial model importations <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport csv\nfrom laser.core.laserframe import LaserFrame\nfrom laser.core.demographics.spatialpops import distribute_population_skewed as dps\nfrom laser.core.migration import gravity\n</code></pre> <p>Instead of using the <code>SIRModel</code>, we will use the <code>MultiNodeSIRModel</code>.</p> Code example: Creating a model using <code>MultiNodeSIRModel</code> <pre><code># Define the model\nclass MultiNodeSIRModel:\n    \"\"\"\n    A multi-node SIR (Susceptible-Infected-Recovered) disease transmission model.\n\n    Attributes:\n        params (dict): Configuration parameters for the model.\n        nodes (int): Number of nodes in the simulation.\n        population (LaserFrame): Represents the population with agent-level properties.\n        results (np.ndarray): Stores simulation results for S, I, and R per node.\n        components (list): List of components (e.g., Migration, Transmission) added to the model.\n    \"\"\"\n\n    def __init__(self, params):\n        \"\"\"\n        Initializes the SIR model with the given parameters.\n\n        Args:\n            params (dict): Dictionary containing parameters such as population size,\n                           number of nodes, timesteps, and rates for transmission/migration.\n        \"\"\"\n        self.components = []\n        self.params = params\n        self.nodes = params[\"nodes\"]\n        self.population = LaserFrame(capacity=params[\"population_size\"], initial_count=params[\"population_size\"])\n\n        # Define properties\n        self.population.add_scalar_property(\"node_id\", dtype=np.int32)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)  # 0=S, 1=I, 2=R\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n        self.population.add_scalar_property(\"migration_timer\", dtype=np.int32, default=0)\n\n        # Initialize population distribution\n        node_pops = dps(params[\"population_size\"], self.nodes, frac_rural=0.3)\n        node_ids = np.concatenate([np.full(count, i) for i, count in enumerate(node_pops)])\n        np.random.shuffle(node_ids)\n        self.population.node_id[:params[\"population_size\"]] = node_ids\n\n        # Reporting structure: Use LaserFrame for reporting\n        self.results = LaserFrame( capacity=self.nodes ) # not timesteps for capacity\n        for state in [\"S\", \"I\", \"R\"]:\n            self.results.add_vector_property(state, length=params[\"timesteps\"], dtype=np.int32)\n\n        # Record results: reporting could actually be a component if we wanted. Or it can be\n        # done in a log/report function in the relevant component (e.g., Transmission)\n        self.results.S[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 0)\n            for i in range(self.nodes)\n        ]\n        self.results.I[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 1)\n            for i in range(self.nodes)\n        ]\n        self.results.R[self.current_timestep, :] = [\n            np.sum(self.population.disease_state[self.population.node_id == i] == 2)\n            for i in range(self.nodes)\n        ]\n\n    def add_component(self, component):\n        \"\"\"\n        Adds a component (e.g., Migration, Transmission, Recovery) to the model.\n\n        Args:\n            component: An instance of a component to be added.\n        \"\"\"\n        self.components.append(component)\n\n    def step(self):\n        \"\"\"\n        Advances the simulation by one timestep, updating all components and recording results.\n        \"\"\"\n        for component in self.components:\n            component.step()\n\n        # Record results\n        for i in range(self.nodes):\n            in_node = self.population.node_id == i\n            self.results[self.current_timestep, i, 0] = (self.population.disease_state[in_node] == 0).sum()\n            self.results[self.current_timestep, i, 1] = (self.population.disease_state[in_node] == 1).sum()\n            self.results[self.current_timestep, i, 2] = (self.population.disease_state[in_node] == 2).sum()\n\n    def run(self):\n        \"\"\"\n        Runs the simulation for the configured number of timesteps.\n        \"\"\"\n        from tqdm import tqdm\n        for self.current_timestep in tqdm(range(self.params[\"timesteps\"])):\n            self.step()\n\n    def save_results(self, filename):\n        \"\"\"\n        Saves the simulation results to a CSV file.\n\n        Args:\n            filename (str): Path to the output file.\n        \"\"\"\n        with open(filename, mode='w', newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"Timestep\", \"Node\", \"Susceptible\", \"Infected\", \"Recovered\"])\n            for t in range(self.params[\"timesteps\"]):\n                for node in range(self.nodes):\n                    writer.writerow([t, node, *self.results[t, node]])\n\n    def plot_results(self):\n        \"\"\"\n        Plots the prevalence of infected agents over time for all nodes.\n        \"\"\"\n        plt.figure(figsize=(10, 6))\n        for i in range(self.nodes):\n            prevalence = self.results.I[:, i] / (\n                self.results.S[:, i] +\n                self.results.I[:, i] +\n                self.results.R[:, i]\n            )\n            plt.plot(prevalence, label=f\"Node {i}\")\n\n        plt.title(\"Prevalence Across All Nodes\")\n        plt.xlabel(\"Timesteps\")\n        plt.ylabel(\"Prevalence of Infected Agents\")\n        plt.legend()\n        plt.show()\n</code></pre> <p>To add migration between nodes, we will need to select the type of migration model to use and import the component. Here, we will use the sequential migration matrix to move agents sequentially between nodes. The 0th node is the 'urban' node which contains the largest population and where we seed the infection. The infection will travel sequentially from node to node, but the below example breaks the connection at node 13 for demonstrative purposes.</p> Code example: Adding migration using the sequential migration matrix <pre><code>class MigrationComponent:\n    \"\"\"\n    Handles migration behavior of agents between nodes in the model.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n        migration_matrix (ndarray): A matrix representing migration probabilities between nodes.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the MigrationComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n        # Set initial migration timers\n        max_timer = int(1 / model.params[\"migration_rate\"])\n        model.population.migration_timer[:] = np.random.randint(1, max_timer + 1, size=model.params[\"population_size\"])\n\n        self.migration_matrix = self.get_sequential_migration_matrix(model.nodes)\n\n        # Example customization: Disable migration from node 13 to 14\n        def break_matrix_node(matrix, from_node, to_node):\n            matrix[from_node][to_node] = 0\n        break_matrix_node(self.migration_matrix, 13, 14)\n\n    def get_sequential_migration_matrix(self, nodes):\n        \"\"\"\n        Creates a migration matrix where agents can only migrate to the next sequential node.\n\n        Args:\n            nodes (int): Number of nodes in the simulation.\n\n        Returns:\n            ndarray: A migration matrix where migration is allowed only to the next node.\n        \"\"\"\n        migration_matrix = np.zeros((nodes, nodes))\n        for i in range(nodes - 1):\n            migration_matrix[i, i + 1] = 1.0\n        return migration_matrix\n\n    def step(self):\n        \"\"\"\n        Updates the migration state of the population by determining which agents migrate\n        and their destinations based on the migration matrix.\n        \"\"\"\n        node_ids = self.model.population.node_id\n\n        # Decrement migration timers\n        self.model.population.migration_timer -= 1\n\n        # Identify agents ready to migrate\n        migrating_indices = np.where(self.model.population.migration_timer &lt;= 0)[0]\n        if migrating_indices.size == 0:\n            return\n\n        # Shuffle migrants and assign destinations based on migration matrix\n        np.random.shuffle(migrating_indices)\n        destinations = np.empty(len(migrating_indices), dtype=int)\n        for origin in range(self.model.nodes):\n            origin_mask = node_ids[migrating_indices] == origin\n            num_origin_migrants = origin_mask.sum()\n\n            if num_origin_migrants &gt; 0:\n                # Assign destinations proportionally to migration matrix\n                destination_counts = np.round(self.migration_matrix[origin] * num_origin_migrants).astype(int)\n                destination_counts = np.maximum(destination_counts, 0)  # Clip negative values\n                if destination_counts.sum() == 0:  # No valid destinations\n                    destinations[origin_mask] = origin  # Stay in the same node\n                    continue\n                destination_counts[origin] += num_origin_migrants - destination_counts.sum()  # Adjust rounding errors\n\n                # Create ordered destination assignments\n                destination_indices = np.repeat(np.arange(self.model.nodes), destination_counts)\n                destinations[origin_mask] = destination_indices[:num_origin_migrants]\n\n        # Update node IDs of migrants\n        node_ids[migrating_indices] = destinations\n\n        # Reset migration timers for migrated agents\n        self.model.population.migration_timer[migrating_indices] = np.random.randint(\n            1, int(1 / self.model.params[\"migration_rate\"]) + 1, size=migrating_indices.size\n        )\n</code></pre> <p>To create more complicated and more realistic migration dynamics, instead of using sequential migration we can use the gravity model to implement 2-D migration. Migration rates are proportional to population sizes, but the example still uses synthetic distances for ease of demonstration.</p> Code example: Adding migration using the gravity model of migration <pre><code>class MigrationComponent2D:\n    \"\"\"\n    Handles migration behavior of agents between nodes in the model.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n        migration_matrix (ndarray): A matrix representing migration probabilities between nodes.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the MigrationComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n        # Set initial migration timers\n        max_timer = int(1 / model.params[\"migration_rate\"])\n        model.population.migration_timer[:] = np.random.randint(1, max_timer + 1, size=model.params[\"population_size\"])\n\n        self.migration_matrix = self.get_gravity_migration_matrix(model.nodes)\n\n    def get_gravity_migration_matrix(self, nodes):\n        \"\"\"\n        Generates a gravity-based migration matrix based on population and distances between nodes.\n\n        Args:\n            nodes (int): Number of nodes in the simulation.\n\n        Returns:\n            ndarray: A migration matrix where each row represents probabilities of migration to other nodes.\n        \"\"\"\n        pops = np.array([np.sum(self.model.population.node_id == i) for i in range(nodes)])\n        distances = np.ones((nodes, nodes)) - np.eye(nodes)\n        migration_matrix = gravity(pops, distances, k=1.0, a=0.5, b=0.5, c=2.0)\n        migration_matrix = migration_matrix / migration_matrix.sum(axis=1, keepdims=True)\n        return migration_matrix\n\n    def step(self):\n\n        \"\"\"\n        Executes the migration step for the agent-based model.\n\n        This function selects a fraction of agents to migrate based on expired migration timers.\n        It then changes their node_id according to the migration matrix, ensuring that movements\n        follow the prescribed probability distributions.\n\n        Steps:\n        - Selects a subset of the population for migration.\n        - Determines the origin nodes of migrating agents.\n        - Uses a multinomial draw to assign new destinations based on the migration matrix.\n        - Updates the agents' node assignments accordingly.\n\n        Returns:\n            None\n        \"\"\"\n        # Decrement migration timers\n        self.model.population.migration_timer -= 1\n\n        # Identify agents ready to migrate\n        migrating_indices = np.where(self.model.population.migration_timer &lt;= 0)[0]\n        if migrating_indices.size == 0:\n            return\n\n        np.random.shuffle(migrating_indices)\n\n        origins = model.population.node_id[migrating_indices]\n        origin_counts = np.bincount(origins, minlength=model.params[\"nodes\"])\n\n        offset = 0\n\n        for origin in range(model.params[\"nodes\"]):\n            count = origin_counts[origin]\n            if count == 0:\n                continue\n\n            origin_slice = migrating_indices[offset : offset + count]\n            offset += count\n\n            row = self.migration_matrix[origin]\n            row_sum = row.sum()\n            if row_sum &lt;= 0:\n                continue\n\n            fraction_row = row / row_sum\n            destination_counts = np.random.multinomial(count, fraction_row)\n            destinations = np.repeat(np.arange(model.params[\"nodes\"]), destination_counts)\n            model.population.node_id[origin_slice] = destinations[:count]\n\n        # Reset migration timers for migrated agents\n        self.model.population.migration_timer[migrating_indices] = np.random.randint(\n            1, int(1 / self.model.params[\"migration_rate\"]) + 1, size=migrating_indices.size\n        )\n</code></pre> <p>After selecting your desired migration patterns, you will need to add in a transmission component to create disease dynamics.</p> Code example: Adding in disease transmission <pre><code>class TransmissionComponent:\n    \"\"\"\n    Handles the disease transmission dynamics within the population.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the TransmissionComponent and infects initial agents.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n    def step(self):\n        \"\"\"\n        Simulates disease transmission for each node in the current timestep.\n        \"\"\"\n        for i in range(self.model.nodes):\n            in_node = self.model.population.node_id == i\n            susceptible = in_node &amp; (self.model.population.disease_state == 0)\n            infected = in_node &amp; (self.model.population.disease_state == 1)\n\n            num_susceptible = susceptible.sum()\n            num_infected = infected.sum()\n            total_in_node = in_node.sum()\n\n            if total_in_node &gt; 0 and num_infected &gt; 0 and num_susceptible &gt; 0:\n                infectious_fraction = num_infected / total_in_node\n                susceptible_fraction = num_susceptible / total_in_node\n\n                new_infections = int(\n                    self.model.params[\"transmission_rate\"] * infectious_fraction * susceptible_fraction * total_in_node\n                )\n\n                susceptible_indices = np.where(susceptible)[0]\n                newly_infected_indices = np.random.choice(susceptible_indices, size=new_infections, replace=False)\n\n                self.model.population.disease_state[newly_infected_indices] = 1\n                self.model.population.recovery_timer[newly_infected_indices] = np.random.randint(5, 15, size=new_infections)\n</code></pre> <p>Finally, we need to add recovery dynamics to the model to move agents through the disease progression.</p> Code example: Adding in recovery dynamics <pre><code>class RecoveryComponent:\n    \"\"\"\n    Handles the recovery dynamics of infected individuals in the population.\n\n    Attributes:\n        model (MultiNodeSIRModel): The simulation model instance.\n    \"\"\"\n\n    def __init__(self, model):\n        \"\"\"\n        Initializes the RecoveryComponent.\n\n        Args:\n            model (MultiNodeSIRModel): The simulation model instance.\n        \"\"\"\n        self.model = model\n\n    def step(self):\n        \"\"\"\n        Updates the recovery state of infected individuals, moving them to the recovered state\n        if their recovery timer has elapsed.\n        \"\"\"\n        infected = self.model.population.disease_state == 1\n        self.model.population.recovery_timer[infected] -= 1\n        self.model.population.disease_state[(infected) &amp; (self.model.population.recovery_timer &lt;= 0)] = 2\n</code></pre> <p>To run the created model and visualize your output, we will need to set our model parameters and run the simulation.</p> Code example: Running your spatial SIR model <pre><code># Parameters\nparams = {\n    \"population_size\": 1_000_000,\n    \"nodes\": 20,\n    \"timesteps\": 600,\n    \"initial_infected_fraction\": 0.01,\n    \"transmission_rate\": 0.25,\n    \"migration_rate\": 0.001\n}\n\n# Run simulation\nmodel = MultiNodeSIRModel(params)\nmodel.add_component(MigrationComponent(model))\nmodel.add_component(TransmissionComponent(model))\nmodel.add_component(RecoveryComponent(model))\nmodel.run()\nmodel.save_results(\"simulation_results.csv\")\nmodel.plot_results()\n</code></pre>"},{"location":"tutorials/sir/#using-real-data","title":"Using real data","text":"<p>To utilize SIR models to understand real-world transmission dynamics, you will need to use real data. Model structure will be similar to what was presented above, but instead of using a synthetic population we will initialize the model using real population data. In this example, we will use data from Rwanda. You will want your data saved in a .csv file, with the following information:</p> <ul> <li>Region_id: node location, here each node is a city in Rwanda</li> <li>Population: the population of the node</li> <li>Centroid_lat and centroid-long: the latitude and longitude at the center of the node</li> <li>Birth_rate: the birth rate for the node</li> </ul> region_id population centroid_lat centroid_long birth_rate Ryansoro 46482.7 -3.70727 29.7988 11.6565 Ndava 72979.3 -3.39156 29.7534 15.8815 Buyengero 76468.8 -3.84874 29.533 12.5038 Bugarama 44571.9 -3.69048 29.4004 11.0256 Rumonge 300248 -3.96221 29.4571 19.5677 Burambi 63219.7 -3.79864 29.4524 9.19902 Kanyosha1 115018 -3.43097 29.4153 37.9514 Kabezi 71913.8 -3.5311 29.37 31.8319 Muhuta 88141.7 -3.62351 29.4152 21.5989 <p>The model code will be very similar to the code used above, but the population data will be loaded from the .csv file instead of created synthetically. In the following example, numbers are rounded and scaled down (which is optional), and each node is assigned an ID.</p> Code example: Creating a model using data loaded from a CSV <pre><code>class SpatialSIRModelRealData:\n    def __init__(self, params, population_data):\n        \"\"\"\n            Initialize the mode, LASER-style, using the population_data loaded from a csv file (pandas).\n            Create nodes and a migration_matrix based on populations and locations of each node.\n\n        \"\"\"\n        self.params = params\n        # We scale down population here from literal values but this may not be necessary.\n        population_data[\"scaled_population\"] = (population_data[\"population\"] / params[\"scale_factor\"]).round().astype(int)\n        total_population = int(population_data[\"scaled_population\"].sum())\n        print( f\"{total_population=}\" )\n\n        # Set up the properties as before\n        self.population = LaserFrame(capacity=total_population, initial_count=total_population)\n        self.population.add_scalar_property(\"node_id\", dtype=np.int32)\n        self.population.add_scalar_property(\"disease_state\", dtype=np.int32, default=0)\n        self.population.add_scalar_property(\"recovery_timer\", dtype=np.int32, default=0)\n        self.population.add_scalar_property(\"migration_timer\", dtype=np.int32, default=0)\n\n        node_pops = population_data[\"scaled_population\"].values\n        self.params[\"nodes\"] = len(node_pops)\n\n        node_ids = np.concatenate([np.full(count, i) for i, count in enumerate(node_pops)])\n        np.random.shuffle(node_ids)\n        self.population.node_id[:total_population] = node_ids\n\n        # seed in big node\n        big_node_id = np.argmax( node_pops )\n        available_population = population_data[\"scaled_population\"][big_node_id]\n        initial_infected = int(params[\"initial_infected_fraction\"] * available_population)\n        infection_indices = np.random.choice(np.where(self.population.node_id == big_node_id)[0], initial_infected, replace=False)\n        self.population.disease_state[infection_indices] = 1\n        self.population.recovery_timer[infection_indices] = np.random.uniform(params[\"recovery_time\"] - 3, params[\"recovery_time\"] + 3, size=initial_infected).astype(int)\n\n        pop_sizes = np.array(node_pops)\n        latitudes = population_data[\"centroid_lat\"].values\n        longitudes = population_data[\"centroid_long\"].values\n        distances = np.zeros((self.params[\"nodes\"], self.params[\"nodes\"]))\n\n        # Nested for loop here is optimized for readbility, not performance\n        for i in range(self.params[\"nodes\"]):\n            for j in range(self.params[\"nodes\"]):\n                if i != j:\n                    distances[i, j] = distance(latitudes[i], longitudes[i], latitudes[j], longitudes[j])\n\n        # Set up our migration_matrix based on gravity model and input data (pops &amp; distances)\n        self.distances = distances\n        self.migration_matrix = gravity(pop_sizes, distances, k=10.0, a=1.0, b=1.0, c=1.0)\n        self.migration_matrix /= self.migration_matrix.sum(axis=1, keepdims=True) # normalize\n</code></pre>"},{"location":"tutorials/sir/#alternative-migration-approach","title":"Alternative migration approach","text":"<p>In the above examples, we modeled migration by moving individual agents from node to node. An alternative approach is to model the migration of infection instead of individuals; this allows for computational efficiency while maintaining accurate disease transmission dynamics. Note that in this example, we do not use a <code>MigrationComponent</code> or <code>migration_timer</code>.</p> Code example: Modeling migration of infection instead of individuals <pre><code>import numpy as np\nfrom laser.core.migration import gravity\nfrom laser.core.utils import calc_distances\n\nclass TransmissionComponent:\n    \"\"\"\n    Transmission Component\n    =======================\n\n    This class models the transmission of disease using \"infection migration\"\n    instead of human movement. Instead of tracking individual movement,\n    infection is spread probabilistically based on a gravity-inspired network.\n\n    This approach can significantly improve computational efficiency for\n    large-scale spatial epidemic simulations.\n\n    Attributes:\n    ------------\n    model : object\n        The simulation model containing population and node information.\n    network : ndarray\n        A matrix representing the transmission probabilities between nodes.\n    locations : ndarray\n        Array of node latitude and longitude coordinates.\n    \"\"\"\n    def __init__(self, model):\n        \"\"\"\n        Initializes the transmission component by computing the infection migration network.\n\n        Parameters:\n        -----------\n        model : object\n            The simulation model containing population and node information.\n        \"\"\"\n        self.model = model\n        model.nodes.add_vector_property(\"network\", length=model.nodes.count, dtype=np.float32)\n        self.network = model.nodes.network\n\n        # Extract node locations and populations from model.population_data\n        self.locations = np.column_stack((model.population_data[\"centroid_lat\"], model.population_data[\"centroid_long\"]))\n        initial_populations = np.array(model.population_data[\"population\"])\n\n        # Initialize heterogeneous transmission factor per agent (0.5 to 2.0)\n        self.model.population.tx_hetero_factor = np.random.uniform(0.5, 2.0, size=model.population.capacity)\n\n        # Compute the infection migration network based on node populations.\n        a, b, c, k = self.model.params.a, self.model.params.b, self.model.params.c, self.model.params.k\n\n        # Compute all pairwise distances in one call (this speeds up initialization significantly)\n        # from laser.core.migration import gravity, row_normalizer\n        # from laser.core.utils import calc_distances\n        distances = calc_distances(self.locations[:, 0], self.locations[:, 1])\n        self.network = gravity(initial_populations, distances, k, a, b, c)\n        self.network /= np.power(initial_populations.sum(), c)  # Normalize\n        self.network = row_normalizer(self.network, 0.01) # 0.01=max_frac\n\n   def step(self):\n        \"\"\"\n        Simulates disease transmission and infection migration across the network.\n\n        New infections are determined deterministically based on contagion levels and susceptible fraction.\n        \"\"\"\n        contagious_indices = np.where(self.model.population.disease_state == 1)[0]\n        values = self.model.population.tx_hetero_factor[contagious_indices]  # Apply heterogeneity factor\n\n        # Compute contagion levels per node\n        contagion = np.bincount(\n            self.model.population.node_id[contagious_indices],\n            weights=values,\n            minlength=self.model.nodes.count\n        ).astype(np.float64)\n\n        # Apply network-based infection movement\n        transfer = (contagion * self.network).round().astype(np.float64)\n\n        # Ensure net contagion remains positive after movement\n        contagion += transfer.sum(axis=1) - transfer.sum(axis=0)\n        contagion = np.maximum(contagion, 0)  # Prevent negative contagion\n\n        # Infect susceptible individuals in each node deterministically\n        for i in range(self.model.nodes.count):\n            node_population = np.where(self.model.population.node_id == i)[0]\n            susceptible = node_population[self.model.population.disease_state[node_population] == 0]\n\n            if len(susceptible) &gt; 0:\n                # Compute new infections deterministically based on prevalence and susceptible fraction\n                num_new_infections = int(min(len(susceptible), (\n                    self.model.params.transmission_rate * contagion[i] * len(susceptible) / len(node_population)\n                )))\n\n                # Randomly select susceptible individuals for infection\n                new_infected_indices = np.random.choice(susceptible, size=num_new_infections, replace=False)\n                self.model.population.disease_state[new_infected_indices] = 1\n\n                # Assign recovery timers to newly infected individuals\n                self.model.population.recovery_timer[new_infected_indices] = np.random.randint(5, 15, size=num_new_infections)\n</code></pre>"},{"location":"tutorials/sir/#glossary","title":"Glossary","text":""},{"location":"tutorials/notebooks/","title":"Tutorials","text":"<p>The following Jupyter notebook tutorials walk through different workflows to configure the LASER-generic model, starting with a simple SI model with no demographics and adding more complexity with each tutorial to illustrate various features of the model.</p>"},{"location":"tutorials/notebooks/#glossary","title":"Glossary","text":""},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/","title":"SI Model with no demographics","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom matplotlib import pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\nimport laser.generic.models.SI as SI\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from matplotlib import pyplot as plt from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic import laser.generic.models.SI as SI from laser.generic.models.model import Model from laser.generic.newutils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>np.__version__='2.3.5'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>pop = 1e6\ninit_inf = 1\n# Seattle: 47\u00b036'35\" -122\u00b019'59\"\nlatitude = 47+(36+(35/60))/60\nlongitude = -(122+(19+(59/60))/60)\nscenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\nparameters = PropertySet({\"seed\": 6, \"nticks\": 730, \"verbose\": True, \"beta\": 0.05})\n\n# Run until we get an outbreak\noutbreak = False\nwhile not outbreak:\n\n    parameters.seed += 1\n    model = Model(scenario, parameters)\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.Transmission(model),\n    ]\n\n    model.run()\n\n    outbreak = np.any(model.nodes.I[180] != 0)\n</pre> pop = 1e6 init_inf = 1 # Seattle: 47\u00b036'35\" -122\u00b019'59\" latitude = 47+(36+(35/60))/60 longitude = -(122+(19+(59/60))/60) scenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf parameters = PropertySet({\"seed\": 6, \"nticks\": 730, \"verbose\": True, \"beta\": 0.05})  # Run until we get an outbreak outbreak = False while not outbreak:      parameters.seed += 1     model = Model(scenario, parameters)     model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.Transmission(model),     ]      model.run()      outbreak = np.any(model.nodes.I[180] != 0)  <pre>/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/shapely/constructive.py:375: RuntimeWarning: invalid value encountered in centroid\n  return lib.centroid(geometry, **kwargs)\n</pre> <pre>\r1000000 agents in f1 nodes:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\r1000000 agents in f1 nodes:   0%|          | 1/730 [00:00&lt;04:57,  2.45it/s]</pre> <pre>\r1000000 agents in f1 nodes:   3%|\u258e         | 22/730 [00:00&lt;00:12, 55.60it/s]</pre> <pre>\r1000000 agents in f1 nodes:   6%|\u258c         | 43/730 [00:00&lt;00:07, 96.12it/s]</pre> <pre>\r1000000 agents in f1 nodes:   9%|\u2589         | 64/730 [00:00&lt;00:05, 126.31it/s]</pre> <pre>\r1000000 agents in f1 nodes:  12%|\u2588\u258f        | 85/730 [00:00&lt;00:04, 148.32it/s]</pre> <pre>\r1000000 agents in f1 nodes:  15%|\u2588\u258d        | 106/730 [00:00&lt;00:03, 164.26it/s]</pre> <pre>\r1000000 agents in f1 nodes:  17%|\u2588\u258b        | 127/730 [00:01&lt;00:03, 175.42it/s]</pre> <pre>\r1000000 agents in f1 nodes:  20%|\u2588\u2588        | 148/730 [00:01&lt;00:03, 183.38it/s]</pre> <pre>\r1000000 agents in f1 nodes:  23%|\u2588\u2588\u258e       | 169/730 [00:01&lt;00:02, 189.57it/s]</pre> <pre>\r1000000 agents in f1 nodes:  26%|\u2588\u2588\u258c       | 190/730 [00:01&lt;00:02, 193.86it/s]</pre> <pre>\r1000000 agents in f1 nodes:  29%|\u2588\u2588\u2589       | 211/730 [00:01&lt;00:02, 197.85it/s]</pre> <pre>\r1000000 agents in f1 nodes:  32%|\u2588\u2588\u2588\u258f      | 233/730 [00:01&lt;00:02, 202.48it/s]</pre> <pre>\r1000000 agents in f1 nodes:  35%|\u2588\u2588\u2588\u258c      | 257/730 [00:01&lt;00:02, 211.81it/s]</pre> <pre>\r1000000 agents in f1 nodes:  39%|\u2588\u2588\u2588\u2589      | 285/730 [00:01&lt;00:01, 230.08it/s]</pre> <pre>\r1000000 agents in f1 nodes:  49%|\u2588\u2588\u2588\u2588\u2589     | 361/730 [00:01&lt;00:00, 385.78it/s]</pre> <pre>\r1000000 agents in f1 nodes:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 628/730 [00:01&lt;00:00, 1060.89it/s]</pre> <pre>\r1000000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:01&lt;00:00, 367.14it/s] </pre> <pre>\n</pre> In\u00a0[3]: Copied! <pre>plt.plot(model.nodes.I, lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S, \"--\", lw=3)\nplt.plot(init_inf + np.insert(np.cumsum(model.nodes.incidence[:-1]), 0, 0), \":\", lw=2, color=\"black\")\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\n</pre> plt.plot(model.nodes.I, lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S, \"--\", lw=3) plt.plot(init_inf + np.insert(np.cumsum(model.nodes.incidence[:-1]), 0, 0), \":\", lw=2, color=\"black\") plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])  Out[3]: <pre>&lt;matplotlib.legend.Legend at 0x7fee897a0d40&gt;</pre> <p>Introducing stochasticity into a model can have more effects on an individual model realization than just inducing noise around a mean trajectory - this simple model is a great example.  In the early stages of the outbreak, the infection count is low, and the timing of those first few infections dictates when the logistic growth really takes off.  This appears as a random time-shift in the entire outbreak trajectory.</p> <p>To illustrate this phenomenon, the below plot shows the model output, the expected logistic growth curve, and the expected logistic growth curve fit to the model with one free parameter -  an offset $t_0$.  The resulting plot should show good concordance between the model output and the expected logistic equation with the known model inputs $\\beta$ and population.</p> <p>The goodness of this fit will be turned into a strict pass/fail test down the line.</p> In\u00a0[4]: Copied! <pre>def SI_logistic(t, beta, size, t0):\n    return size / (1 + (size - 1) * np.exp(-beta * (t - t0)))\n\n\nplt.plot(model.nodes.I, lw=4)\n\nt = np.arange(model.params.nticks)\n\n\ndef objective(t0):\n    return np.sum((1 - SI_logistic(t, model.params.beta, pop, t0) / np.squeeze(model.nodes.I[1:])) ** 2)\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(t, SI_logistic(t, model.params.beta, pop, 0), \"--\", lw=2)\nplt.plot(t, SI_logistic(t, model.params.beta, pop, t0_opt), \"--\", lw=3, color=\"k\")\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\n</pre> def SI_logistic(t, beta, size, t0):     return size / (1 + (size - 1) * np.exp(-beta * (t - t0)))   plt.plot(model.nodes.I, lw=4)  t = np.arange(model.params.nticks)   def objective(t0):     return np.sum((1 - SI_logistic(t, model.params.beta, pop, t0) / np.squeeze(model.nodes.I[1:])) ** 2)   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(t, SI_logistic(t, model.params.beta, pop, 0), \"--\", lw=2) plt.plot(t, SI_logistic(t, model.params.beta, pop, t0_opt), \"--\", lw=3, color=\"k\") plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7fee896ecb00&gt;</pre> In\u00a0[5]: Copied! <pre>%%capture\nnticks = 730\nt = np.arange(730)\npop = 1e5\n\nseeds = list(range(10))\nbetas = [0.01 * i for i in range(2, 12)]\noutput = pd.DataFrame(columns=[\"seed\", \"beta\", \"cases\", \"fitted_beta\", \"fitted_size\", \"fitted_t0\"])\n\n# scenario = pd.DataFrame(data=[[\"homenode\", pop, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])\nscenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\n\nfor seed, beta in zip(seeds, betas):\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta})\n    model = Model(scenario, parameters)\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.Transmission(model),\n    ]\n    # seed_infections_randomly_SI(model, ninfections=1)\n    model.run()\n    cases = [model.nodes.I[i][0] for i in range(nticks)]\n    popt, pcov = curve_fit(SI_logistic, t, cases, p0=[0.05, 1.1e5, 1])\n\n    output = pd.concat(\n        [\n            output,\n            pd.DataFrame.from_dict(\n                {\n                    \"seed\": seed,\n                    \"beta\": beta,\n                    \"cases\": [np.array(cases)],\n                    \"fitted_beta\": popt[0],\n                    \"fitted_size\": popt[1],\n                    \"fitted_t0\": popt[2],\n                }\n            ),\n        ],\n        ignore_index=True,\n    )\n</pre> %%capture nticks = 730 t = np.arange(730) pop = 1e5  seeds = list(range(10)) betas = [0.01 * i for i in range(2, 12)] output = pd.DataFrame(columns=[\"seed\", \"beta\", \"cases\", \"fitted_beta\", \"fitted_size\", \"fitted_t0\"])  # scenario = pd.DataFrame(data=[[\"homenode\", pop, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"]) scenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf  for seed, beta in zip(seeds, betas):     parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta})     model = Model(scenario, parameters)     model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.Transmission(model),     ]     # seed_infections_randomly_SI(model, ninfections=1)     model.run()     cases = [model.nodes.I[i][0] for i in range(nticks)]     popt, pcov = curve_fit(SI_logistic, t, cases, p0=[0.05, 1.1e5, 1])      output = pd.concat(         [             output,             pd.DataFrame.from_dict(                 {                     \"seed\": seed,                     \"beta\": beta,                     \"cases\": [np.array(cases)],                     \"fitted_beta\": popt[0],                     \"fitted_size\": popt[1],                     \"fitted_t0\": popt[2],                 }             ),         ],         ignore_index=True,     ) In\u00a0[6]: Copied! <pre>plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlabel(\"True beta\")\nplt.ylabel(\"Fitted beta\")\nplt.figure()\nplt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"], \"o\")\nplt.xlabel(\"True beta\")\nplt.ylabel(\"Relative error in fitted beta\")\n</pre> plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlabel(\"True beta\") plt.ylabel(\"Fitted beta\") plt.figure() plt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"], \"o\") plt.xlabel(\"True beta\") plt.ylabel(\"Relative error in fitted beta\") Out[6]: <pre>Text(0, 0.5, 'Relative error in fitted beta')</pre> In\u00a0[7]: Copied! <pre>print(\n    \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05))\n)\n</pre> print(     \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05)) ) <pre>All fitted beta are within 5% of known beta: True\n</pre>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#si-model-with-no-demographics","title":"SI Model with no demographics\u00b6","text":"<p>We will begin with perhaps the simplest possible model of an infectious disease - the SI model without demography.  This model hsa two classes of individuals, the infective and the susceptible, and 1 parameter, $\\beta$, describing the per-timestep, per-infective person rate at which susceptibles transition to infectives.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} \\\\  \\dot{I} = \\frac{\\beta*S*I}{N} $$</p> <p>Noting that $S = N-I$, we can substitute $S$ in the second equation to get a standard form logistic equation</p> <p>$$ \\dot{I} = \\beta \\frac{(I-N)I}{N} = \\beta I (1 - \\frac{I}{N}) $$</p> <p>With solution $$ \\frac{N}{1+(\\frac{N}{I_0}-1)e^{-\\beta t}} $$</p> <p>To run the model in a discrete, constant time-step solver, the differential equation above is converted into a stochastic finite difference equation</p> <p>$$ \\Delta I = Bin(S_t, 1-exp^{-\\beta \\Delta t \\frac{I}{N}}) \\\\ S_{t+1} = S_t - \\Delta I \\\\ I_{t+1} = I_t + \\Delta I $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#constuct-the-model","title":"Constuct the model\u00b6","text":"<p>In the first few cells, we import the <code>laser.generic.SI</code> model.  Then we construct a single-patch LASER model with two components: the Susceptible and Infected states, and the Transmission step in which Infecteds can infect Susceptibles. Finally, we initialize with a single infection and run.</p> <p>Note that LASER-generic has separate importable models for different generic model types (SI, SIS, SIR, SEIR, etc.).  Model code can be imported or copied over from one \"sub-package\" to another as desired, but maintaining this separation enables model-specific performance optimizations and cleaner code than requiring the components to \"know\" the global model configuration and change internal behvaior based on that (for example, whether agents in the <code>Infected</code> state need to cound down a timer or not; whether <code>Transmission</code> should send newly infected agents to the Infectious state as in the SI, SIS, SIR, or to an Exposed state as in an SEIR).</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.  We also confirm that $I_t = I_0 + \\sum_{t'=0}^t \\Delta I_{t'}$</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  We select a few values of $\\beta$, run the model, fit the outputs to the logistic equation, and compare the fitted value of $\\beta$ to the known value.  Because we are approximating continuously compounding growth, in the logistic equation, with a discrete time-step approximation, we expect the fitted values of $\\beta$ to be biased slightly downward - that is, the modeled trajectory is slightly slower than the continuous-time counterpart.  This error grows as $\\beta$ gets larger; the test fails if any of the fitted $\\beta$ values are more than 5% away from the known values.</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#constructing-the-model","title":"Constructing the model\u00b6","text":""},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#question-is-this-still-the-case-i-think-the-reporting-setup-should-now-always-be-recording-state-variables-like-s-i-etc-at-end-of-timestep-so-that-they-should-always-sum-to-n-there-is-a-question-of-whether-i_t-sum-of-delta-i-from-0-t-1-or-from-0-t","title":"Question - is this still the case?  I think the reporting setup should now always be recording state variables like S, I, etc. at end of timestep so that they should always sum to N.  There is a question of whether I_t = sum of delta I from 0 -&gt; t-1, or from 0-&gt;t.\u00b6","text":"<p>A note that order of the model components matters, because of how recording of relevant statistics into outputs occurs.  If transmission comes before susceptibility, then we have $N = S+I+\\Delta I$, because we record $I$, record $\\Delta I$, do transmission, then record $S$ after the transmission process occurs.  With susceptibility first, we record $S$, then record $I$, then do transmission (and record $\\Delta I$), and so we have $N = S+I$.</p>"},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#first-set-of-sanity-checks","title":"First set of sanity checks\u00b6","text":""},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#note-this-test-is-not-useful-we-should-look-at-s-i-and-incidence-for-consistency","title":"Note - this test is not useful, we should look at S, I, and incidence for consistency.\u00b6","text":""},{"location":"tutorials/notebooks/01_SI_nobirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of $\\beta$  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>Because we are approximating continuously compounding growth by discrete-time compounding growth, we should expect the fitted $\\beta$  to consistently be slightly underestimated relative to the true $\\beta$ , with the relative difference growing as $\\beta$  gets larger.</p> <p>In the future, we could probably compute the expected error from this approximation.  But for now, to make this a pass-fail test, we will raise a flag if the fitted $\\beta$ is more than 5% different than the known $\\beta$.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/","title":"SI Model with constant-population demographics","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\n\nimport laser.generic.models.SI as SI\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import ValuesMap\nfrom laser.generic.newutils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic  import laser.generic.models.SI as SI from laser.generic.models.model import Model from laser.generic.newutils import ValuesMap from laser.generic.newutils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.5'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>pop = 1e6\ninit_inf = 1\n# Just for fun, use coordinates of Seattle, WA\nlatitude = 47+(36+(35/60))/60\nlongitude = -(122+(19+(59/60))/60)\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\nparameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.04, \"cbr\": 40.0})\n# Question - if I provide a scalar birth rate, should the demographics steps know to convert that to a ratemap behind the scenes?\nbirthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1).values\nmortality  = ValuesMap.from_scalar(0.0, nsteps=parameters.nticks, nnodes=1).values\n\n# Run until we see an outbreak\noutbreak = False\n\nwhile not outbreak:\n    parameters.seed += 1\n    model = Model(scenario, parameters, birthrates)\n\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.ConstantPopVitalDynamics(model, birthrates, mortality),\n        SI.Transmission(model),\n        ]\n\n    model.run()\n\n    outbreak = np.any(model.nodes.I[200] &gt; 0)\n</pre> pop = 1e6 init_inf = 1 # Just for fun, use coordinates of Seattle, WA latitude = 47+(36+(35/60))/60 longitude = -(122+(19+(59/60))/60) scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf parameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.04, \"cbr\": 40.0}) # Question - if I provide a scalar birth rate, should the demographics steps know to convert that to a ratemap behind the scenes? birthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1).values mortality  = ValuesMap.from_scalar(0.0, nsteps=parameters.nticks, nnodes=1).values  # Run until we see an outbreak outbreak = False  while not outbreak:     parameters.seed += 1     model = Model(scenario, parameters, birthrates)      model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.ConstantPopVitalDynamics(model, birthrates, mortality),         SI.Transmission(model),         ]      model.run()      outbreak = np.any(model.nodes.I[200] &gt; 0) <pre>\r1000000 agents in f1 nodes:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\r1000000 agents in f1 nodes:   0%|          | 1/730 [00:00&lt;06:30,  1.87it/s]</pre> <pre>\r1000000 agents in f1 nodes:   2%|\u258f         | 14/730 [00:00&lt;00:24, 28.73it/s]</pre> <pre>\r1000000 agents in f1 nodes:   4%|\u258d         | 28/730 [00:00&lt;00:13, 53.79it/s]</pre> <pre>\r1000000 agents in f1 nodes:   6%|\u258c         | 42/730 [00:00&lt;00:09, 74.15it/s]</pre> <pre>\r1000000 agents in f1 nodes:   8%|\u258a         | 56/730 [00:00&lt;00:07, 90.01it/s]</pre> <pre>\r1000000 agents in f1 nodes:  10%|\u2589         | 70/730 [00:01&lt;00:06, 102.02it/s]</pre> <pre>\r1000000 agents in f1 nodes:  12%|\u2588\u258f        | 84/730 [00:01&lt;00:05, 111.02it/s]</pre> <pre>\r1000000 agents in f1 nodes:  13%|\u2588\u258e        | 98/730 [00:01&lt;00:05, 117.48it/s]</pre> <pre>\r1000000 agents in f1 nodes:  15%|\u2588\u258c        | 112/730 [00:01&lt;00:05, 122.08it/s]</pre> <pre>\r1000000 agents in f1 nodes:  17%|\u2588\u258b        | 126/730 [00:01&lt;00:04, 125.20it/s]</pre> <pre>\r1000000 agents in f1 nodes:  19%|\u2588\u2589        | 140/730 [00:01&lt;00:04, 127.88it/s]</pre> <pre>\r1000000 agents in f1 nodes:  21%|\u2588\u2588        | 154/730 [00:01&lt;00:04, 129.66it/s]</pre> <pre>\r1000000 agents in f1 nodes:  23%|\u2588\u2588\u258e       | 168/730 [00:01&lt;00:04, 130.44it/s]</pre> <pre>\r1000000 agents in f1 nodes:  25%|\u2588\u2588\u258d       | 182/730 [00:01&lt;00:04, 131.38it/s]</pre> <pre>\r1000000 agents in f1 nodes:  27%|\u2588\u2588\u258b       | 196/730 [00:02&lt;00:04, 131.89it/s]</pre> <pre>\r1000000 agents in f1 nodes:  29%|\u2588\u2588\u2589       | 210/730 [00:02&lt;00:03, 132.41it/s]</pre> <pre>\r1000000 agents in f1 nodes:  31%|\u2588\u2588\u2588       | 224/730 [00:02&lt;00:03, 132.87it/s]</pre> <pre>\r1000000 agents in f1 nodes:  33%|\u2588\u2588\u2588\u258e      | 238/730 [00:02&lt;00:03, 133.04it/s]</pre> <pre>\r1000000 agents in f1 nodes:  35%|\u2588\u2588\u2588\u258d      | 252/730 [00:02&lt;00:03, 133.47it/s]</pre> <pre>\r1000000 agents in f1 nodes:  36%|\u2588\u2588\u2588\u258b      | 266/730 [00:02&lt;00:03, 133.75it/s]</pre> <pre>\r1000000 agents in f1 nodes:  38%|\u2588\u2588\u2588\u258a      | 280/730 [00:02&lt;00:03, 134.20it/s]</pre> <pre>\r1000000 agents in f1 nodes:  40%|\u2588\u2588\u2588\u2588      | 294/730 [00:02&lt;00:03, 134.66it/s]</pre> <pre>\r1000000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 308/730 [00:02&lt;00:03, 135.37it/s]</pre> <pre>\r1000000 agents in f1 nodes:  44%|\u2588\u2588\u2588\u2588\u258d     | 322/730 [00:02&lt;00:02, 136.50it/s]</pre> <pre>\r1000000 agents in f1 nodes:  46%|\u2588\u2588\u2588\u2588\u258c     | 337/730 [00:03&lt;00:02, 138.31it/s]</pre> <pre>\r1000000 agents in f1 nodes:  48%|\u2588\u2588\u2588\u2588\u258a     | 352/730 [00:03&lt;00:02, 139.85it/s]</pre> <pre>\r1000000 agents in f1 nodes:  50%|\u2588\u2588\u2588\u2588\u2588     | 368/730 [00:03&lt;00:02, 144.23it/s]</pre> <pre>\r1000000 agents in f1 nodes:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 385/730 [00:03&lt;00:02, 149.70it/s]</pre> <pre>\r1000000 agents in f1 nodes:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 404/730 [00:03&lt;00:02, 159.88it/s]</pre> <pre>\r1000000 agents in f1 nodes:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 427/730 [00:03&lt;00:01, 179.87it/s]</pre> <pre>\r1000000 agents in f1 nodes:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 455/730 [00:03&lt;00:01, 208.57it/s]</pre> <pre>\r1000000 agents in f1 nodes:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 488/730 [00:03&lt;00:00, 242.92it/s]</pre> <pre>\r1000000 agents in f1 nodes:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 522/730 [00:03&lt;00:00, 271.14it/s]</pre> <pre>\r1000000 agents in f1 nodes:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 557/730 [00:03&lt;00:00, 292.40it/s]</pre> <pre>\r1000000 agents in f1 nodes:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 592/730 [00:04&lt;00:00, 307.66it/s]</pre> <pre>\r1000000 agents in f1 nodes:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 627/730 [00:04&lt;00:00, 318.41it/s]</pre> <pre>\r1000000 agents in f1 nodes:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 662/730 [00:04&lt;00:00, 324.92it/s]</pre> <pre>\r1000000 agents in f1 nodes:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 696/730 [00:04&lt;00:00, 327.78it/s]</pre> <pre>\r1000000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:04&lt;00:00, 163.33it/s]</pre> <pre>\n</pre> In\u00a0[3]: Copied! <pre>plt.plot(model.nodes.I.astype(\"int\"), lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S, \"--\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\n\nprint(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all()))\n</pre> plt.plot(model.nodes.I.astype(\"int\"), lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S, \"--\", lw=3) plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])  print(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all())) <pre>S = N-I:  True\n</pre> <p>The below plot shows the model output, the expected logistic growth curve, and the expected logistic growth curve fit to the model with a free offset $t_0$ to account for stochasticity in when the outbreak takes off.  The resulting plot should show good concordance between the model output and the expected logistic equation with the known model inputs $\\beta$ and population. The goodness of this fit could be turned into a strict pass/fail test down the line.</p> In\u00a0[4]: Copied! <pre>def SI_logistic(t, beta, popsize, cbr, t0):\n    mu = (1 + cbr / 1000) ** (1 / 365) - 1\n    x = 1 - mu / beta\n    return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))\n\n\nt = np.arange(model.params.nticks)\n\n\ndef objective(t0):\n    return np.sum((1 - SI_logistic(t, model.params.beta, pop, model.params.cbr, t0) / np.squeeze(model.nodes.I[1:,:])) ** 2)\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(model.nodes.I, lw=4)\nplt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, 0), lw=3)\nplt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, t0_opt), \"r:\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\n</pre> def SI_logistic(t, beta, popsize, cbr, t0):     mu = (1 + cbr / 1000) ** (1 / 365) - 1     x = 1 - mu / beta     return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))   t = np.arange(model.params.nticks)   def objective(t0):     return np.sum((1 - SI_logistic(t, model.params.beta, pop, model.params.cbr, t0) / np.squeeze(model.nodes.I[1:,:])) ** 2)   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(model.nodes.I, lw=4) plt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, 0), lw=3) plt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, t0_opt), \"r:\", lw=3) plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7fde90a89100&gt;</pre> In\u00a0[5]: Copied! <pre># %%capture\nNTESTS = 10\nseeds = [42 + i for i in range(NTESTS)]\npop = 1e5\nnticks = 3650\nbetas = [0.05 + 0.005 * i for i in range(1, NTESTS+1)]\ncbrs = np.random.randint(15, 50, NTESTS)\n\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\ninit_inf = 5\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\n\nrows = []\nfor i, (seed, beta, cbr) in enumerate(zip(seeds, betas, cbrs)):\n\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"cbr\": cbr})\n    birthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)\n    mortality  = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)\n    model = Model(scenario, parameters, birthrates=birthrates.values)\n\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.ConstantPopVitalDynamics(model, birthrates.values, mortality.values),\n        SI.Transmission(model),\n        ]\n    model.run(label=f\"SI Model {i+1:2} of {NTESTS} (beta={beta:0.05f}, cbr={cbr:3})\")\n    cases = model.nodes.I[:-1, 0]\n    popt, pcov = curve_fit(\n        SI_logistic,\n        np.arange(nticks),\n        cases,\n        p0=[beta * (1 + 0.1 * np.random.normal()), pop, cbr * (1 + 0.1 * np.random.normal()), 1],\n        bounds=([0, pop - 1, 0, -100], [1, pop + 1, 600, 100]),\n    )\n    # Pandas complains about concatenating rows to an empty DataFrame, so build a list of dicts and convert at the end\n    rows.append({\n        \"seed\": seed,\n        \"beta\": beta,\n        \"cbr\": cbr,\n        \"cases\": np.array(cases),\n        \"fitted_beta\": popt[0],\n        \"fitted_size\": popt[1],\n        \"fitted_cbr\": popt[2],\n        \"fitted_t0\": popt[3],\n    })\n\noutput = pd.DataFrame(rows)\n</pre> # %%capture NTESTS = 10 seeds = [42 + i for i in range(NTESTS)] pop = 1e5 nticks = 3650 betas = [0.05 + 0.005 * i for i in range(1, NTESTS+1)] cbrs = np.random.randint(15, 50, NTESTS)  scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) init_inf = 5 scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf  rows = [] for i, (seed, beta, cbr) in enumerate(zip(seeds, betas, cbrs)):      parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"cbr\": cbr})     birthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)     mortality  = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)     model = Model(scenario, parameters, birthrates=birthrates.values)      model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.ConstantPopVitalDynamics(model, birthrates.values, mortality.values),         SI.Transmission(model),         ]     model.run(label=f\"SI Model {i+1:2} of {NTESTS} (beta={beta:0.05f}, cbr={cbr:3})\")     cases = model.nodes.I[:-1, 0]     popt, pcov = curve_fit(         SI_logistic,         np.arange(nticks),         cases,         p0=[beta * (1 + 0.1 * np.random.normal()), pop, cbr * (1 + 0.1 * np.random.normal()), 1],         bounds=([0, pop - 1, 0, -100], [1, pop + 1, 600, 100]),     )     # Pandas complains about concatenating rows to an empty DataFrame, so build a list of dicts and convert at the end     rows.append({         \"seed\": seed,         \"beta\": beta,         \"cbr\": cbr,         \"cases\": np.array(cases),         \"fitted_beta\": popt[0],         \"fitted_size\": popt[1],         \"fitted_cbr\": popt[2],         \"fitted_t0\": popt[3],     })  output = pd.DataFrame(rows)  <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):   3%|\u258e         | 118/3650 [00:00&lt;00:03, 1171.60it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):   8%|\u258a         | 291/3650 [00:00&lt;00:02, 1497.49it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  15%|\u2588\u258d        | 545/3650 [00:00&lt;00:01, 1971.22it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  22%|\u2588\u2588\u258f       | 799/3650 [00:00&lt;00:01, 2192.14it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  28%|\u2588\u2588\u258a       | 1032/3650 [00:00&lt;00:01, 2239.55it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  35%|\u2588\u2588\u2588\u258d      | 1277/3650 [00:00&lt;00:01, 2308.40it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  42%|\u2588\u2588\u2588\u2588\u258f     | 1531/3650 [00:00&lt;00:00, 2381.63it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  49%|\u2588\u2588\u2588\u2588\u2589     | 1783/3650 [00:00&lt;00:00, 2422.26it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 2037/3650 [00:00&lt;00:00, 2458.41it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 2291/3650 [00:01&lt;00:00, 2481.56it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2544/3650 [00:01&lt;00:00, 2494.54it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2798/3650 [00:01&lt;00:00, 2507.15it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 3049/3650 [00:01&lt;00:00, 2465.15it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 3302/3650 [00:01&lt;00:00, 2483.49it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29):  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 3556/3650 [00:01&lt;00:00, 2498.98it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 29): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2356.66it/s]</pre> <pre>\n</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):   3%|\u258e         | 119/3650 [00:00&lt;00:02, 1181.07it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):   9%|\u258a         | 312/3650 [00:00&lt;00:02, 1617.78it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  16%|\u2588\u258c        | 566/3650 [00:00&lt;00:01, 2035.83it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  22%|\u2588\u2588\u258f       | 819/3650 [00:00&lt;00:01, 2230.11it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  29%|\u2588\u2588\u2589       | 1071/3650 [00:00&lt;00:01, 2333.36it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  36%|\u2588\u2588\u2588\u258b      | 1325/3650 [00:00&lt;00:00, 2401.92it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  43%|\u2588\u2588\u2588\u2588\u258e     | 1580/3650 [00:00&lt;00:00, 2447.37it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  50%|\u2588\u2588\u2588\u2588\u2588     | 1835/3650 [00:00&lt;00:00, 2477.49it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 2089/3650 [00:00&lt;00:00, 2496.61it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 2344/3650 [00:01&lt;00:00, 2510.54it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2598/3650 [00:01&lt;00:00, 2517.12it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2852/3650 [00:01&lt;00:00, 2523.46it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3105/3650 [00:01&lt;00:00, 2491.48it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 3359/3650 [00:01&lt;00:00, 2503.75it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33):  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 3610/3650 [00:01&lt;00:00, 2496.79it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 33): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2391.13it/s]</pre> <pre>\n</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):   3%|\u258e         | 118/3650 [00:00&lt;00:03, 1175.35it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):   8%|\u258a         | 308/3650 [00:00&lt;00:02, 1598.90it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  15%|\u2588\u258c        | 562/3650 [00:00&lt;00:01, 2024.43it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  22%|\u2588\u2588\u258f       | 816/3650 [00:00&lt;00:01, 2226.53it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  29%|\u2588\u2588\u2589       | 1068/3650 [00:00&lt;00:01, 2331.67it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  36%|\u2588\u2588\u2588\u258c      | 1322/3650 [00:00&lt;00:00, 2400.73it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  43%|\u2588\u2588\u2588\u2588\u258e     | 1576/3650 [00:00&lt;00:00, 2444.94it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  50%|\u2588\u2588\u2588\u2588\u2588     | 1830/3650 [00:00&lt;00:00, 2473.58it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 2084/3650 [00:00&lt;00:00, 2493.91it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 2338/3650 [00:01&lt;00:00, 2507.29it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2593/3650 [00:01&lt;00:00, 2517.71it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2846/3650 [00:01&lt;00:00, 2521.30it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 3100/3650 [00:01&lt;00:00, 2525.31it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 3354/3650 [00:01&lt;00:00, 2527.68it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41):  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 3607/3650 [00:01&lt;00:00, 2522.63it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 41): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2398.18it/s]</pre> <pre>\n</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):   3%|\u258e         | 118/3650 [00:00&lt;00:02, 1178.04it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):   9%|\u2589         | 326/3650 [00:00&lt;00:01, 1706.62it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  16%|\u2588\u258c        | 580/3650 [00:00&lt;00:01, 2083.74it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  23%|\u2588\u2588\u258e       | 833/3650 [00:00&lt;00:01, 2256.90it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  30%|\u2588\u2588\u2589       | 1088/3650 [00:00&lt;00:01, 2359.27it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  37%|\u2588\u2588\u2588\u258b      | 1342/3650 [00:00&lt;00:00, 2418.16it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  44%|\u2588\u2588\u2588\u2588\u258e     | 1595/3650 [00:00&lt;00:00, 2453.22it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  50%|\u2588\u2588\u2588\u2588\u2588     | 1841/3650 [00:00&lt;00:00, 2452.16it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 2094/3650 [00:00&lt;00:00, 2474.18it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 2348/3650 [00:01&lt;00:00, 2494.35it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2601/3650 [00:01&lt;00:00, 2504.83it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2854/3650 [00:01&lt;00:00, 2509.47it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3108/3650 [00:01&lt;00:00, 2517.92it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 3361/3650 [00:01&lt;00:00, 2521.43it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31):  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 3616/3650 [00:01&lt;00:00, 2527.55it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 31): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2403.48it/s]</pre> <pre>\n</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):   3%|\u258e         | 118/3650 [00:00&lt;00:02, 1179.33it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):   9%|\u2589         | 333/3650 [00:00&lt;00:01, 1749.13it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  16%|\u2588\u258c        | 583/3650 [00:00&lt;00:01, 2090.82it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  23%|\u2588\u2588\u258e       | 837/3650 [00:00&lt;00:01, 2266.98it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  30%|\u2588\u2588\u2589       | 1092/3650 [00:00&lt;00:01, 2367.65it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  37%|\u2588\u2588\u2588\u258b      | 1348/3650 [00:00&lt;00:00, 2430.18it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  44%|\u2588\u2588\u2588\u2588\u258e     | 1592/3650 [00:00&lt;00:00, 2353.98it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  51%|\u2588\u2588\u2588\u2588\u2588     | 1847/3650 [00:00&lt;00:00, 2412.81it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 2101/3650 [00:00&lt;00:00, 2451.33it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 2356/3650 [00:01&lt;00:00, 2478.92it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2610/3650 [00:01&lt;00:00, 2496.24it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2860/3650 [00:01&lt;00:00, 2486.35it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3112/3650 [00:01&lt;00:00, 2496.15it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 3366/3650 [00:01&lt;00:00, 2509.10it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36):  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 3621/3650 [00:01&lt;00:00, 2520.46it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 36): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2390.66it/s]</pre> <pre>\n</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):   3%|\u258e         | 119/3650 [00:00&lt;00:02, 1182.38it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):   9%|\u2589         | 339/3650 [00:00&lt;00:01, 1777.43it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  16%|\u2588\u258c        | 591/3650 [00:00&lt;00:01, 2115.47it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  23%|\u2588\u2588\u258e       | 845/3650 [00:00&lt;00:01, 2281.83it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  30%|\u2588\u2588\u2588       | 1097/3650 [00:00&lt;00:01, 2365.27it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  37%|\u2588\u2588\u2588\u258b      | 1353/3650 [00:00&lt;00:00, 2428.55it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  44%|\u2588\u2588\u2588\u2588\u258d     | 1608/3650 [00:00&lt;00:00, 2466.74it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  51%|\u2588\u2588\u2588\u2588\u2588     | 1863/3650 [00:00&lt;00:00, 2490.14it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 2118/3650 [00:00&lt;00:00, 2508.41it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 2372/3650 [00:01&lt;00:00, 2518.04it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2626/3650 [00:01&lt;00:00, 2524.13it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2880/3650 [00:01&lt;00:00, 2528.28it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3133/3650 [00:01&lt;00:00, 2481.76it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21):  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 3388/3650 [00:01&lt;00:00, 2499.71it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 3643/3650 [00:01&lt;00:00, 2512.14it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 21): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2412.44it/s]</pre> <pre>\n</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):   3%|\u258e         | 122/3650 [00:00&lt;00:02, 1212.20it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  10%|\u2588         | 365/3650 [00:00&lt;00:01, 1922.67it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  17%|\u2588\u258b        | 619/3650 [00:00&lt;00:01, 2202.66it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  24%|\u2588\u2588\u258d       | 873/3650 [00:00&lt;00:01, 2334.82it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  31%|\u2588\u2588\u2588       | 1127/3650 [00:00&lt;00:01, 2408.00it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  38%|\u2588\u2588\u2588\u258a      | 1381/3650 [00:00&lt;00:00, 2449.96it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  45%|\u2588\u2588\u2588\u2588\u258d     | 1636/3650 [00:00&lt;00:00, 2480.69it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1890/3650 [00:00&lt;00:00, 2497.36it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 2145/3650 [00:00&lt;00:00, 2512.02it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 2398/3650 [00:01&lt;00:00, 2517.39it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2650/3650 [00:01&lt;00:00, 2518.01it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2902/3650 [00:01&lt;00:00, 2501.69it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3155/3650 [00:01&lt;00:00, 2509.39it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24):  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 3409/3650 [00:01&lt;00:00, 2516.18it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 24): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2432.43it/s]</pre> <pre>\n</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):   3%|\u258e         | 120/3650 [00:00&lt;00:02, 1193.25it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  10%|\u2589         | 355/3650 [00:00&lt;00:01, 1869.79it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  17%|\u2588\u258b        | 609/3650 [00:00&lt;00:01, 2173.51it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  24%|\u2588\u2588\u258e       | 863/3650 [00:00&lt;00:01, 2314.62it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  31%|\u2588\u2588\u2588       | 1118/3650 [00:00&lt;00:01, 2396.15it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  38%|\u2588\u2588\u2588\u258a      | 1372/3650 [00:00&lt;00:00, 2444.00it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  44%|\u2588\u2588\u2588\u2588\u258d     | 1621/3650 [00:00&lt;00:00, 2457.09it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  51%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1876/3650 [00:00&lt;00:00, 2484.44it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 2131/3650 [00:00&lt;00:00, 2501.92it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 2382/3650 [00:01&lt;00:00, 2482.72it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2636/3650 [00:01&lt;00:00, 2499.74it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2888/3650 [00:01&lt;00:00, 2504.81it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3143/3650 [00:01&lt;00:00, 2515.81it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45):  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 3398/3650 [00:01&lt;00:00, 2523.34it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 45): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2423.69it/s]</pre> <pre>\n</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):   3%|\u258e         | 125/3650 [00:00&lt;00:02, 1244.04it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  10%|\u2588         | 373/3650 [00:00&lt;00:01, 1967.80it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  17%|\u2588\u258b        | 628/3650 [00:00&lt;00:01, 2231.55it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  24%|\u2588\u2588\u258d       | 883/3650 [00:00&lt;00:01, 2356.42it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  31%|\u2588\u2588\u2588       | 1137/3650 [00:00&lt;00:01, 2421.18it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  38%|\u2588\u2588\u2588\u258a      | 1392/3650 [00:00&lt;00:00, 2463.28it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  45%|\u2588\u2588\u2588\u2588\u258c     | 1647/3650 [00:00&lt;00:00, 2488.75it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1902/3650 [00:00&lt;00:00, 2506.80it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 2156/3650 [00:00&lt;00:00, 2514.82it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 2410/3650 [00:01&lt;00:00, 2522.54it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2665/3650 [00:01&lt;00:00, 2528.87it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2918/3650 [00:01&lt;00:00, 2524.76it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3172/3650 [00:01&lt;00:00, 2528.28it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17):  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 3427/3650 [00:01&lt;00:00, 2533.12it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 17): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2447.09it/s]</pre> <pre>\n</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):   3%|\u258e         | 125/3650 [00:00&lt;00:02, 1247.90it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  10%|\u2588         | 376/3650 [00:00&lt;00:01, 1989.72it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  17%|\u2588\u258b        | 630/3650 [00:00&lt;00:01, 2238.94it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  24%|\u2588\u2588\u258d       | 884/3650 [00:00&lt;00:01, 2355.41it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  31%|\u2588\u2588\u2588       | 1138/3650 [00:00&lt;00:01, 2421.50it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  38%|\u2588\u2588\u2588\u258a      | 1393/3650 [00:00&lt;00:00, 2462.66it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  45%|\u2588\u2588\u2588\u2588\u258c     | 1648/3650 [00:00&lt;00:00, 2488.14it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1903/3650 [00:00&lt;00:00, 2505.60it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 2156/3650 [00:00&lt;00:00, 2512.48it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 2410/3650 [00:01&lt;00:00, 2519.68it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2663/3650 [00:01&lt;00:00, 2521.71it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2917/3650 [00:01&lt;00:00, 2526.63it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3171/3650 [00:01&lt;00:00, 2530.55it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28):  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 3425/3650 [00:01&lt;00:00, 2532.10it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 28): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2446.85it/s]</pre> <pre>\n</pre> In\u00a0[6]: Copied! <pre>plt.figure()\nplt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlim(0.04, 0.12)\nplt.ylim(0.04, 0.12)\nplt.figure()\nplt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"fitted_beta\"], \"o\")\nplt.xlim(0.04, 0.12)\nplt.ylim(-0.1, 0.12)\nplt.figure()\nplt.plot(output[\"cbr\"], output[\"fitted_cbr\"], \"o\")\nplt.xlim(15, 50)\nplt.ylim(15, 50)\nplt.figure()\nplt.plot(output[\"cbr\"], (output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"fitted_cbr\"], \"o\")\nplt.xlim(15, 50)\nplt.ylim(-0.2, 0.2)\n</pre> plt.figure() plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlim(0.04, 0.12) plt.ylim(0.04, 0.12) plt.figure() plt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"fitted_beta\"], \"o\") plt.xlim(0.04, 0.12) plt.ylim(-0.1, 0.12) plt.figure() plt.plot(output[\"cbr\"], output[\"fitted_cbr\"], \"o\") plt.xlim(15, 50) plt.ylim(15, 50) plt.figure() plt.plot(output[\"cbr\"], (output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"fitted_cbr\"], \"o\") plt.xlim(15, 50) plt.ylim(-0.2, 0.2) Out[6]: <pre>(-0.2, 0.2)</pre> In\u00a0[7]: Copied! <pre>print(\n    \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05))\n)\nprint(\"All fitted CBR are within 5% of known CBR: \" + str(np.all(np.abs((output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"cbr\"]) &lt; 0.05)))\n</pre> print(     \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05)) ) print(\"All fitted CBR are within 5% of known CBR: \" + str(np.all(np.abs((output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"cbr\"]) &lt; 0.05))) <pre>All fitted beta are within 5% of known beta: True\nAll fitted CBR are within 5% of known CBR: False\n</pre> In\u00a0[8]: Copied! <pre>output\n</pre> output Out[8]: seed beta cbr cases fitted_beta fitted_size fitted_cbr fitted_t0 0 42 0.055 29 [5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 8, 10, 10, 10, ... 0.053871 100000.607704 27.124347 -37.910779 1 43 0.060 33 [5, 6, 7, 8, 8, 9, 9, 9, 12, 12, 12, 13, 15, 1... 0.059073 100000.291319 31.216200 -34.885214 2 44 0.065 41 [5, 5, 5, 5, 5, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, ... 0.064017 100000.753042 38.680603 -17.712505 3 45 0.070 31 [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 8, 8, 10,... 0.068679 100000.574072 29.079893 -21.271110 4 46 0.075 36 [5, 6, 7, 7, 7, 7, 7, 7, 7, 8, 9, 10, 10, 11, ... 0.073805 99999.347866 33.519763 -14.760422 5 47 0.080 21 [5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 9, 10,... 0.078380 100000.462825 19.551529 -9.184310 6 48 0.085 24 [5, 6, 6, 6, 6, 6, 6, 7, 9, 11, 13, 14, 16, 18... 0.083535 100000.144548 22.466402 -22.730920 7 49 0.090 45 [5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, ... 0.087576 99999.365785 42.002680 -8.751750 8 50 0.095 17 [5, 6, 8, 10, 11, 11, 12, 14, 15, 18, 19, 19, ... 0.092658 100000.998454 15.905025 -15.648846 9 51 0.100 28 [5, 6, 7, 7, 8, 11, 11, 13, 15, 16, 17, 19, 21... 0.097970 100000.660180 26.135666 -16.995729 In\u00a0[9]: Copied! <pre>row = output.iloc[9]\ncases_row = row[\"cases\"]\nfitted_beta = row[\"fitted_beta\"]\nfitted_size = row[\"fitted_size\"]\nfitted_cbr = row[\"fitted_cbr\"]\nfitted_t0 = row[\"fitted_t0\"]\n\nplt.figure()\nplt.plot(cases_row, label=\"Case Trace\")\nplt.plot(SI_logistic(np.arange(nticks), fitted_beta, fitted_size, fitted_cbr, fitted_t0), label=\"Logistic Fit\", ls=\"--\")\nplt.legend()\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Cases\")\nplt.title(\"Case Trace and Logistic Fit for Row 0\")\n# plt.ylim(9.8e5, 1e6)\nplt.show()\n</pre> row = output.iloc[9] cases_row = row[\"cases\"] fitted_beta = row[\"fitted_beta\"] fitted_size = row[\"fitted_size\"] fitted_cbr = row[\"fitted_cbr\"] fitted_t0 = row[\"fitted_t0\"]  plt.figure() plt.plot(cases_row, label=\"Case Trace\") plt.plot(SI_logistic(np.arange(nticks), fitted_beta, fitted_size, fitted_cbr, fitted_t0), label=\"Logistic Fit\", ls=\"--\") plt.legend() plt.xlabel(\"Time (days)\") plt.ylabel(\"Cases\") plt.title(\"Case Trace and Logistic Fit for Row 0\") # plt.ylim(9.8e5, 1e6) plt.show() <p>Just an interesting note - because I kicked the simulations off with 3 infections rather than 1 (to ensure that the initial infection doesn't die before infecting someone), we consistently get a negative fit value for t0, and one that is a larger negative value for the lowest $\\beta$ values.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#si-model-with-constant-population-demographics","title":"SI Model with constant-population demographics\u00b6","text":"<p>Building up from the SI model without demography, we next explore the addition of basic demographics - adding a birth rate &amp; an equivalent, age-independent mortality rate $\\mu$ to keep constant total population.  The disease model remains the SI model.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\mu I $$</p> <p>With a bit of manipulation as in the previous example, this can be worked back into the form of a generalized logistic growth differential equation $$ \\dot{I} = \\beta I (1-\\frac{\\mu}{\\beta}-\\frac{I}{N})$$</p> <p>With solution $$ \\frac{Nx}{1+(\\frac{Nx}{I_0}-1)e^{-\\beta x t}} \\\\ x = (1-\\frac{\\mu}{\\beta}) $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with four components: the <code>Susceptible</code> and <code>Infected</code> states, and the <code>Transmission</code>, and <code>ConstantPopVitalDynamics</code> \"flows\" between states.  Finally, we initialize with a single infection and run.  The <code>Susceptible</code>, <code>Infected</code> and <code>Transmission</code> components are described in the the model with no births.  <code>ConstantPopVitalDynamics</code> enables births and deaths while strictly enforcing constant population rather than having separate stochastic birth and death processes that induce population variance over time.  To do this, births are implemented by randomly choosing an existing agent and re-initializing them as a newborn; in this way, each birth of a new agent is exactly offset by the death of an existing one.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  First, we run a basic test on a single model, and show the result matches expectation with known inputs.  Then, as before, we select a few values of $\\beta$ and $\\mu$, run the model, fit the outputs to the logistic equation, and compare the fitted values of the parameters to the known value.  The equation above makes it clear that attempting to fit $\\beta, \\mu$ and N all together will be degenerate - the logistic equation has two parameters, not three; in this case those two are the products $N x$ and $\\beta x$.  Thus, we fix the total population size $N$ in the fit to focus on the more interesting $\\beta$ and $\\mu$ parameters.  And as before, because we are approximating continuously compounding growth, in the logistic equation, with a discrete time-step approximation, we expect the fitted values of $\\beta$ to be biased slightly downward - that is, the modeled trajectory is slightly slower than the continuous-time counterpart.  This error grows as $\\beta$ gets larger; the test fails if any of the fitted $\\beta$ values are more than 5% away from the known values.  Furthermore, if the outbreak is seeded by only one infection, it is possible that that one infection dies prior to infecting anyone else; we therefore seed with a few infections rather than one.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the relationships between susceptible, infected, and total population hold.  In the version with no births, we could also test that the infected = the sum of past incidence, but with births now playing a role that no longer holds.</p>"},{"location":"tutorials/notebooks/02_SI_wbirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of $\\beta$ &amp; birth rate  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>Because we are approximating continuously compounding growth by discrete-time compounding growth, we should expect the fitted $\\beta$  to consistently be slightly underestimated relative to the true $\\beta$ , with the relative difference growing as $\\beta$  gets larger.</p> <p>In the future, we could probably compute the expected error from this approximation.  But for now, to make this a pass-fail test, we will raise a flag if the fitted parameters are more than 5% different than the known ones.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/","title":"SIS Model with no demographics","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numba as nb\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numba as nb import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.5'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>from laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nimport laser.core.distributions as dists\nimport laser.generic.models.SIS as SIS\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import grid\n</pre> from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator import laser.core.distributions as dists import laser.generic.models.SIS as SIS from laser.generic.models.model import Model from laser.generic.newutils import grid <p>To make sure we don't accumulate lots of finite time-step error, make inf mean quite long in units of timestep</p> In\u00a0[3]: Copied! <pre>pop = 3e5\n\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 1\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\nparameters = PropertySet({\"seed\": 42, \"nticks\": 3000, \"beta\": 0.1, \"inf_mean\": 32})\n\ninfdurdist = dists.exponential(scale=parameters.inf_mean)\n\n# Sampling this pyramid will return indices in [0, 88] with equal probability.\npyramid = AliasedDistribution(np.full(89, 1_000))\n# The survival function will return the probability of surviving past each age.\nsurvival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\n</pre> pop = 3e5  scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 1 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected parameters = PropertySet({\"seed\": 42, \"nticks\": 3000, \"beta\": 0.1, \"inf_mean\": 32})  infdurdist = dists.exponential(scale=parameters.inf_mean)  # Sampling this pyramid will return indices in [0, 88] with equal probability. pyramid = AliasedDistribution(np.full(89, 1_000)) # The survival function will return the probability of surviving past each age. survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())  In\u00a0[4]: Copied! <pre># Run until we get an outbreak\noutbreak = False\nwhile not outbreak:\n    parameters.seed += 1\n    model = Model(scenario, parameters)\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run()\n    outbreak = np.any(model.nodes.I[200] &gt; 0)\n</pre> # Run until we get an outbreak outbreak = False while not outbreak:     parameters.seed += 1     model = Model(scenario, parameters)      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run()     outbreak = np.any(model.nodes.I[200] &gt; 0)  <pre>\r300000 agents in f1 nodes:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\r300000 agents in f1 nodes:   0%|          | 1/3000 [00:01&lt;1:06:08,  1.32s/it]</pre> <pre>\r300000 agents in f1 nodes:   2%|\u258f         | 57/3000 [00:01&lt;00:53, 55.22it/s] </pre> <pre>\r300000 agents in f1 nodes:   4%|\u258d         | 117/3000 [00:01&lt;00:23, 121.72it/s]</pre> <pre>\r300000 agents in f1 nodes:   6%|\u258c         | 177/3000 [00:01&lt;00:14, 192.60it/s]</pre> <pre>\r300000 agents in f1 nodes:   8%|\u258a         | 240/3000 [00:01&lt;00:10, 268.63it/s]</pre> <pre>\r300000 agents in f1 nodes:  10%|\u2588         | 313/3000 [00:01&lt;00:07, 360.55it/s]</pre> <pre>\r300000 agents in f1 nodes:  13%|\u2588\u258e        | 387/3000 [00:01&lt;00:05, 443.62it/s]</pre> <pre>\r300000 agents in f1 nodes:  15%|\u2588\u258c        | 461/3000 [00:02&lt;00:04, 513.71it/s]</pre> <pre>\r300000 agents in f1 nodes:  18%|\u2588\u258a        | 534/3000 [00:02&lt;00:04, 568.32it/s]</pre> <pre>\r300000 agents in f1 nodes:  20%|\u2588\u2588        | 608/3000 [00:02&lt;00:03, 612.20it/s]</pre> <pre>\r300000 agents in f1 nodes:  23%|\u2588\u2588\u258e       | 682/3000 [00:02&lt;00:03, 646.24it/s]</pre> <pre>\r300000 agents in f1 nodes:  25%|\u2588\u2588\u258c       | 755/3000 [00:02&lt;00:03, 668.77it/s]</pre> <pre>\r300000 agents in f1 nodes:  28%|\u2588\u2588\u258a       | 829/3000 [00:02&lt;00:03, 687.45it/s]</pre> <pre>\r300000 agents in f1 nodes:  30%|\u2588\u2588\u2588       | 903/3000 [00:02&lt;00:02, 701.26it/s]</pre> <pre>\r300000 agents in f1 nodes:  33%|\u2588\u2588\u2588\u258e      | 977/3000 [00:02&lt;00:02, 710.33it/s]</pre> <pre>\r300000 agents in f1 nodes:  35%|\u2588\u2588\u2588\u258c      | 1050/3000 [00:02&lt;00:02, 714.64it/s]</pre> <pre>\r300000 agents in f1 nodes:  37%|\u2588\u2588\u2588\u258b      | 1123/3000 [00:02&lt;00:02, 719.17it/s]</pre> <pre>\r300000 agents in f1 nodes:  40%|\u2588\u2588\u2588\u2589      | 1196/3000 [00:03&lt;00:02, 721.37it/s]</pre> <pre>\r300000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 1269/3000 [00:03&lt;00:02, 723.87it/s]</pre> <pre>\r300000 agents in f1 nodes:  45%|\u2588\u2588\u2588\u2588\u258d     | 1343/3000 [00:03&lt;00:02, 726.53it/s]</pre> <pre>\r300000 agents in f1 nodes:  47%|\u2588\u2588\u2588\u2588\u258b     | 1417/3000 [00:03&lt;00:02, 729.64it/s]</pre> <pre>\r300000 agents in f1 nodes:  50%|\u2588\u2588\u2588\u2588\u2589     | 1491/3000 [00:03&lt;00:02, 729.23it/s]</pre> <pre>\r300000 agents in f1 nodes:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1565/3000 [00:03&lt;00:01, 730.20it/s]</pre> <pre>\r300000 agents in f1 nodes:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1639/3000 [00:03&lt;00:01, 730.86it/s]</pre> <pre>\r300000 agents in f1 nodes:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1713/3000 [00:03&lt;00:01, 729.46it/s]</pre> <pre>\r300000 agents in f1 nodes:  60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1786/3000 [00:03&lt;00:01, 726.69it/s]</pre> <pre>\r300000 agents in f1 nodes:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1860/3000 [00:03&lt;00:01, 728.08it/s]</pre> <pre>\r300000 agents in f1 nodes:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1933/3000 [00:04&lt;00:01, 728.55it/s]</pre> <pre>\r300000 agents in f1 nodes:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2007/3000 [00:04&lt;00:01, 729.76it/s]</pre> <pre>\r300000 agents in f1 nodes:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2081/3000 [00:04&lt;00:01, 730.14it/s]</pre> <pre>\r300000 agents in f1 nodes:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2155/3000 [00:04&lt;00:01, 731.18it/s]</pre> <pre>\r300000 agents in f1 nodes:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2229/3000 [00:04&lt;00:01, 729.68it/s]</pre> <pre>\r300000 agents in f1 nodes:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2303/3000 [00:04&lt;00:00, 730.14it/s]</pre> <pre>\r300000 agents in f1 nodes:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2377/3000 [00:04&lt;00:00, 731.16it/s]</pre> <pre>\r300000 agents in f1 nodes:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2451/3000 [00:04&lt;00:00, 730.77it/s]</pre> <pre>\r300000 agents in f1 nodes:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2525/3000 [00:04&lt;00:00, 731.95it/s]</pre> <pre>\r300000 agents in f1 nodes:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2599/3000 [00:04&lt;00:00, 731.33it/s]</pre> <pre>\r300000 agents in f1 nodes:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2673/3000 [00:05&lt;00:00, 730.70it/s]</pre> <pre>\r300000 agents in f1 nodes:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2747/3000 [00:05&lt;00:00, 730.91it/s]</pre> <pre>\r300000 agents in f1 nodes:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2821/3000 [00:05&lt;00:00, 730.68it/s]</pre> <pre>\r300000 agents in f1 nodes:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2895/3000 [00:05&lt;00:00, 731.07it/s]</pre> <pre>\r300000 agents in f1 nodes:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2969/3000 [00:05&lt;00:00, 728.95it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:05&lt;00:00, 544.89it/s]</pre> <pre>\n</pre> In\u00a0[5]: Copied! <pre>plt.plot(model.nodes.I, lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S.astype(\"int\"), \"--\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\nprint(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all()))\n</pre> plt.plot(model.nodes.I, lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S.astype(\"int\"), \"--\", lw=3) plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"]) print(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all())) <pre>S = N-I:  True\n</pre> In\u00a0[6]: Copied! <pre>def SIS_logistic(t, beta, popsize, gamma, t0):\n    x = 1 - gamma / beta\n    return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))\n\n\nt = np.arange(model.params.nticks+1)\n\n\ndef objective(t0):\n    return np.sum(\n        (1 - SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0) / np.squeeze(model.nodes.I)) ** 2\n    )\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(model.nodes.I, lw=4)\nplt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, 0), lw=3)\nplt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0_opt), \"r:\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\n</pre> def SIS_logistic(t, beta, popsize, gamma, t0):     x = 1 - gamma / beta     return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))   t = np.arange(model.params.nticks+1)   def objective(t0):     return np.sum(         (1 - SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0) / np.squeeze(model.nodes.I)) ** 2     )   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(model.nodes.I, lw=4) plt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, 0), lw=3) plt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0_opt), \"r:\", lw=3) plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) Out[6]: <pre>&lt;matplotlib.legend.Legend at 0x7f1034982f60&gt;</pre> In\u00a0[7]: Copied! <pre># %%capture\n\nNTESTS = 10\nnticks = 730\nt = np.arange(nticks)\nbetarange = [0.05, 0.2]\ngammarange = [1 / 300, 1 / 100]\nseeds = list(range(NTESTS))\npop = 1e5\nbetas = np.random.uniform(betarange[0], betarange[1], NTESTS)\ngammas = np.random.uniform(gammarange[0], gammarange[1], NTESTS)\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 3\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\n\nrows = []\nfor i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})\n\n    model = Model(scenario, parameters)\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n\n    # Sampling this pyramid will return indices in [0, 88] with equal probability.\n    _pyramid = AliasedDistribution(np.full(89, 1_000))\n    # The survival function will return the probability of surviving past each age.\n    _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed}, beta={beta:.3f}, gamma={gamma:.5f}\")\n    cases = model.nodes.I[1:,0]\n    popt, pcov = curve_fit(\n        SIS_logistic,\n        t,\n        cases,\n        p0=[np.mean(betarange), pop, np.mean(gammarange), 1],\n        bounds=([betarange[0] / 2, pop - 1, gammarange[0] / 2, -300], [betarange[1] * 2, pop + 1, gammarange[1] * 2, 300]),\n    )\n\n    rows.append(\n        {\n            \"seed\": seed,\n            \"beta\": beta,\n            \"gamma\": gamma,\n            \"cases\": [np.array(cases)],\n            \"fitted_beta\": popt[0],\n            \"fitted_gamma\": popt[2],\n            \"fitted_t0\": popt[3],\n        }\n    )\n\noutput = pd.DataFrame(rows)\n</pre> # %%capture  NTESTS = 10 nticks = 730 t = np.arange(nticks) betarange = [0.05, 0.2] gammarange = [1 / 300, 1 / 100] seeds = list(range(NTESTS)) pop = 1e5 betas = np.random.uniform(betarange[0], betarange[1], NTESTS) gammas = np.random.uniform(gammarange[0], gammarange[1], NTESTS) scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 3 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected  rows = [] for i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):     parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})      model = Model(scenario, parameters)      infdurdist = dists.exponential(scale=parameters.inf_mean)      # Sampling this pyramid will return indices in [0, 88] with equal probability.     _pyramid = AliasedDistribution(np.full(89, 1_000))     # The survival function will return the probability of surviving past each age.     _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed}, beta={beta:.3f}, gamma={gamma:.5f}\")     cases = model.nodes.I[1:,0]     popt, pcov = curve_fit(         SIS_logistic,         t,         cases,         p0=[np.mean(betarange), pop, np.mean(gammarange), 1],         bounds=([betarange[0] / 2, pop - 1, gammarange[0] / 2, -300], [betarange[1] * 2, pop + 1, gammarange[1] * 2, 300]),     )      rows.append(         {             \"seed\": seed,             \"beta\": beta,             \"gamma\": gamma,             \"cases\": [np.array(cases)],             \"fitted_beta\": popt[0],             \"fitted_gamma\": popt[2],             \"fitted_t0\": popt[3],         }     )  output = pd.DataFrame(rows)  <pre>\rSIS  1 of 10, seed=0, beta=0.114, gamma=0.00745:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.114, gamma=0.00745:   0%|          | 1/730 [00:00&lt;05:36,  2.17it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.114, gamma=0.00745:  28%|\u2588\u2588\u258a       | 203/730 [00:00&lt;00:01, 478.86it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.114, gamma=0.00745:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 601/730 [00:00&lt;00:00, 1361.93it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.114, gamma=0.00745: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1049.00it/s]</pre> <pre>\n</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.149, gamma=0.00616:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.149, gamma=0.00616:   0%|          | 1/730 [00:00&lt;05:38,  2.16it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.149, gamma=0.00616:  35%|\u2588\u2588\u2588\u258c      | 259/730 [00:00&lt;00:00, 608.75it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.149, gamma=0.00616:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 700/730 [00:00&lt;00:00, 1564.61it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.149, gamma=0.00616: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1084.97it/s]</pre> <pre>\n</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.107, gamma=0.00422:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.107, gamma=0.00422:   0%|          | 1/730 [00:00&lt;07:18,  1.66it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.107, gamma=0.00422:  30%|\u2588\u2588\u2588       | 219/730 [00:00&lt;00:01, 419.59it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.107, gamma=0.00422:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 655/730 [00:00&lt;00:00, 1267.05it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.107, gamma=0.00422: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 890.21it/s] </pre> <pre>\n</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.084, gamma=0.00874:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.084, gamma=0.00874:   0%|          | 1/730 [00:00&lt;05:37,  2.16it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.084, gamma=0.00874:  22%|\u2588\u2588\u258f       | 157/730 [00:00&lt;00:01, 369.58it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.084, gamma=0.00874:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 486/730 [00:00&lt;00:00, 1104.98it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.084, gamma=0.00874: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 993.97it/s] </pre> <pre>\n</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.116, gamma=0.00582:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.116, gamma=0.00582:   0%|          | 1/730 [00:00&lt;05:35,  2.17it/s]</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.116, gamma=0.00582:  31%|\u2588\u2588\u2588       | 224/730 [00:00&lt;00:00, 529.24it/s]</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.116, gamma=0.00582:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 647/730 [00:00&lt;00:00, 1463.27it/s]</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.116, gamma=0.00582: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1069.79it/s]</pre> <pre>\n</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.180, gamma=0.00350:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.180, gamma=0.00350:   0%|          | 1/730 [00:00&lt;05:35,  2.17it/s]</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.180, gamma=0.00350:  43%|\u2588\u2588\u2588\u2588\u258e     | 315/730 [00:00&lt;00:00, 745.45it/s]</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.180, gamma=0.00350: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1129.56it/s]</pre> <pre>\n</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.134, gamma=0.00615:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.134, gamma=0.00615:   0%|          | 1/730 [00:00&lt;07:19,  1.66it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.134, gamma=0.00615:  32%|\u2588\u2588\u2588\u258f      | 233/730 [00:00&lt;00:01, 445.35it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.134, gamma=0.00615:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 666/730 [00:00&lt;00:00, 1278.92it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.134, gamma=0.00615: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 890.00it/s] </pre> <pre>\n</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.136, gamma=0.00398:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.136, gamma=0.00398:   0%|          | 1/730 [00:00&lt;05:35,  2.17it/s]</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.136, gamma=0.00398:  35%|\u2588\u2588\u2588\u258c      | 257/730 [00:00&lt;00:00, 607.35it/s]</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.136, gamma=0.00398:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 724/730 [00:00&lt;00:00, 1633.25it/s]</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.136, gamma=0.00398: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1100.51it/s]</pre> <pre>\n</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00676:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00676:   0%|          | 1/730 [00:00&lt;05:39,  2.15it/s]</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00676:  42%|\u2588\u2588\u2588\u2588\u258f     | 309/730 [00:00&lt;00:00, 724.76it/s]</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00676: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1103.18it/s]</pre> <pre>\n</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.058, gamma=0.00374:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.058, gamma=0.00374:   0%|          | 1/730 [00:00&lt;05:38,  2.15it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.058, gamma=0.00374:  22%|\u2588\u2588\u258f       | 158/730 [00:00&lt;00:01, 370.95it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.058, gamma=0.00374:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 486/730 [00:00&lt;00:00, 1102.51it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.058, gamma=0.00374: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1006.57it/s]</pre> <pre>\n</pre> In\u00a0[8]: Copied! <pre>plt.figure()\nplt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlim(betarange[0], betarange[1])\nplt.ylim(betarange[0], betarange[1])\nplt.figure()\nplt.plot(output[\"beta\"], 1 - output[\"beta\"] / output[\"fitted_beta\"], \"o\")\nplt.xlim(betarange[0], betarange[1])\nplt.ylim(-0.25, 0.25)\nplt.figure()\nplt.plot(output[\"gamma\"], output[\"fitted_gamma\"], \"o\")\nplt.xlim(gammarange[0], gammarange[1])\nplt.ylim(gammarange[0], gammarange[1])\nplt.figure()\nplt.plot(output[\"gamma\"], 1 - output[\"gamma\"] / output[\"fitted_gamma\"], \"o\")\nplt.xlim(gammarange[0], gammarange[1])\nplt.ylim(-0.25, 0.25)\n</pre> plt.figure() plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlim(betarange[0], betarange[1]) plt.ylim(betarange[0], betarange[1]) plt.figure() plt.plot(output[\"beta\"], 1 - output[\"beta\"] / output[\"fitted_beta\"], \"o\") plt.xlim(betarange[0], betarange[1]) plt.ylim(-0.25, 0.25) plt.figure() plt.plot(output[\"gamma\"], output[\"fitted_gamma\"], \"o\") plt.xlim(gammarange[0], gammarange[1]) plt.ylim(gammarange[0], gammarange[1]) plt.figure() plt.plot(output[\"gamma\"], 1 - output[\"gamma\"] / output[\"fitted_gamma\"], \"o\") plt.xlim(gammarange[0], gammarange[1]) plt.ylim(-0.25, 0.25) Out[8]: <pre>(-0.25, 0.25)</pre> In\u00a0[9]: Copied! <pre>print(\n    \"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10))\n)\nprint(\n    \"All fitted gamma are within 20% of known gamma: \"\n    + str(np.all(np.abs((output[\"gamma\"] - output[\"fitted_gamma\"]) / output[\"gamma\"]) &lt; 0.20))\n)\n</pre> print(     \"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10)) ) print(     \"All fitted gamma are within 20% of known gamma: \"     + str(np.all(np.abs((output[\"gamma\"] - output[\"fitted_gamma\"]) / output[\"gamma\"]) &lt; 0.20)) ) <pre>All fitted beta are within 10% of known beta: True\nAll fitted gamma are within 20% of known gamma: True\n</pre> In\u00a0[10]: Copied! <pre>output\n</pre> output Out[10]: seed beta gamma cases fitted_beta fitted_gamma fitted_t0 0 0 0.114330 0.007453 [[3, 3, 3, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 7,... 0.110691 0.006847 -4.453796 1 1 0.149481 0.006164 [[3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6,... 0.143326 0.005480 3.364991 2 2 0.106821 0.004220 [[3, 4, 5, 5, 5, 6, 8, 9, 9, 10, 12, 12, 15, 1... 0.104449 0.003953 -14.102878 3 3 0.084352 0.008739 [[3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 8, 8,... 0.081782 0.008162 -10.696914 4 4 0.116070 0.005817 [[3, 4, 4, 4, 4, 4, 5, 6, 7, 8, 8, 10, 11, 13,... 0.112665 0.005324 -6.269266 5 5 0.179859 0.003499 [[3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 7, 11... 0.171572 0.003058 1.818230 6 6 0.133793 0.006152 [[3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3,... 0.128914 0.005550 7.236894 7 7 0.136010 0.003980 [[3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 7, 9,... 0.130967 0.003576 2.627080 8 8 0.183453 0.006758 [[4, 4, 4, 6, 6, 7, 8, 11, 12, 16, 18, 24, 28,... 0.174274 0.005882 -6.948238 9 9 0.058456 0.003736 [[3, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,... 0.057478 0.003590 -32.622107 In\u00a0[11]: Copied! <pre># %%capture\n\ngammas = [1 / infmean for infmean in [1, 1.5, 2, 2.5, 3, 6, 12, 18, 30, 45, 60, 90, 120, 180, 240, 300]]\nbetas = [3 * gamma for gamma in gammas]\n\nNTESTS = len(gammas)\nnticks = 3000\nseeds = list(range(NTESTS))\npop = 1e5\nfinal_expected = np.array([])\nfinal_observed = np.array([])\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 20\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\n\nfor i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})\n\n    model = Model(scenario, parameters)\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n\n    # Sampling this pyramid will return indices in [0, 88] with equal probability.\n    _pyramid = AliasedDistribution(np.full(89, 1_000))\n    # The survival function will return the probability of surviving past each age.\n    _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed:2}, beta={beta:.3f}, gamma={gamma:.5f}\")\n    final_observed = np.append(final_observed, model.nodes.I[-1,0])\n    final_expected = np.append(final_expected, pop * (1 - gamma / beta))\n</pre> # %%capture  gammas = [1 / infmean for infmean in [1, 1.5, 2, 2.5, 3, 6, 12, 18, 30, 45, 60, 90, 120, 180, 240, 300]] betas = [3 * gamma for gamma in gammas]  NTESTS = len(gammas) nticks = 3000 seeds = list(range(NTESTS)) pop = 1e5 final_expected = np.array([]) final_observed = np.array([]) scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 20 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected  for i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):     parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})      model = Model(scenario, parameters)      infdurdist = dists.exponential(scale=parameters.inf_mean)      # Sampling this pyramid will return indices in [0, 88] with equal probability.     _pyramid = AliasedDistribution(np.full(89, 1_000))     # The survival function will return the probability of surviving past each age.     _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed:2}, beta={beta:.3f}, gamma={gamma:.5f}\")     final_observed = np.append(final_observed, model.nodes.I[-1,0])     final_expected = np.append(final_expected, pop * (1 - gamma / beta)) <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   0%|          | 1/3000 [00:00&lt;23:01,  2.17it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   1%|\u258f         | 42/3000 [00:00&lt;00:29, 98.62it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   3%|\u258e         | 78/3000 [00:00&lt;00:17, 164.41it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   4%|\u258d         | 116/3000 [00:00&lt;00:13, 220.11it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   5%|\u258c         | 154/3000 [00:00&lt;00:10, 262.17it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   6%|\u258b         | 192/3000 [00:00&lt;00:09, 292.97it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   8%|\u258a         | 229/3000 [00:01&lt;00:08, 312.86it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   9%|\u2589         | 266/3000 [00:01&lt;00:08, 327.06it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  10%|\u2588         | 303/3000 [00:01&lt;00:07, 339.36it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  11%|\u2588\u258f        | 341/3000 [00:01&lt;00:07, 348.80it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  13%|\u2588\u258e        | 379/3000 [00:01&lt;00:07, 355.20it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  14%|\u2588\u258d        | 417/3000 [00:01&lt;00:07, 359.67it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  15%|\u2588\u258c        | 455/3000 [00:01&lt;00:07, 362.92it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  16%|\u2588\u258b        | 493/3000 [00:01&lt;00:06, 365.20it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  18%|\u2588\u258a        | 530/3000 [00:01&lt;00:06, 366.58it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  19%|\u2588\u2589        | 568/3000 [00:01&lt;00:06, 368.17it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  20%|\u2588\u2588        | 606/3000 [00:02&lt;00:06, 366.92it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  21%|\u2588\u2588\u258f       | 644/3000 [00:02&lt;00:06, 368.36it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  23%|\u2588\u2588\u258e       | 681/3000 [00:02&lt;00:06, 368.10it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  24%|\u2588\u2588\u258d       | 719/3000 [00:02&lt;00:06, 369.31it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  25%|\u2588\u2588\u258c       | 757/3000 [00:02&lt;00:06, 370.00it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  26%|\u2588\u2588\u258b       | 795/3000 [00:02&lt;00:05, 370.37it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  28%|\u2588\u2588\u258a       | 833/3000 [00:02&lt;00:05, 370.48it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  29%|\u2588\u2588\u2589       | 871/3000 [00:02&lt;00:05, 370.59it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  30%|\u2588\u2588\u2588       | 909/3000 [00:02&lt;00:05, 370.40it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  32%|\u2588\u2588\u2588\u258f      | 947/3000 [00:03&lt;00:05, 371.09it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  33%|\u2588\u2588\u2588\u258e      | 985/3000 [00:03&lt;00:05, 371.28it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  34%|\u2588\u2588\u2588\u258d      | 1023/3000 [00:03&lt;00:05, 371.52it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  35%|\u2588\u2588\u2588\u258c      | 1061/3000 [00:03&lt;00:05, 365.48it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  37%|\u2588\u2588\u2588\u258b      | 1099/3000 [00:03&lt;00:05, 367.14it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  38%|\u2588\u2588\u2588\u258a      | 1136/3000 [00:03&lt;00:05, 367.83it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  39%|\u2588\u2588\u2588\u2589      | 1174/3000 [00:03&lt;00:04, 369.12it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  40%|\u2588\u2588\u2588\u2588      | 1211/3000 [00:03&lt;00:04, 369.18it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  42%|\u2588\u2588\u2588\u2588\u258f     | 1249/3000 [00:03&lt;00:04, 369.86it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  43%|\u2588\u2588\u2588\u2588\u258e     | 1287/3000 [00:03&lt;00:04, 370.02it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  44%|\u2588\u2588\u2588\u2588\u258d     | 1325/3000 [00:04&lt;00:04, 370.66it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  45%|\u2588\u2588\u2588\u2588\u258c     | 1363/3000 [00:04&lt;00:04, 371.03it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  47%|\u2588\u2588\u2588\u2588\u258b     | 1401/3000 [00:04&lt;00:04, 370.90it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  48%|\u2588\u2588\u2588\u2588\u258a     | 1439/3000 [00:04&lt;00:04, 371.22it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  49%|\u2588\u2588\u2588\u2588\u2589     | 1477/3000 [00:04&lt;00:04, 371.25it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  50%|\u2588\u2588\u2588\u2588\u2588     | 1515/3000 [00:04&lt;00:03, 371.26it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1553/3000 [00:04&lt;00:03, 370.90it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1591/3000 [00:04&lt;00:03, 370.88it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1629/3000 [00:04&lt;00:03, 371.35it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1667/3000 [00:04&lt;00:03, 370.59it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1705/3000 [00:05&lt;00:03, 370.46it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1743/3000 [00:05&lt;00:03, 370.23it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1781/3000 [00:05&lt;00:03, 369.40it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1819/3000 [00:05&lt;00:03, 369.52it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1856/3000 [00:05&lt;00:03, 369.00it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1893/3000 [00:05&lt;00:03, 368.86it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1930/3000 [00:05&lt;00:02, 368.90it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1967/3000 [00:05&lt;00:02, 368.53it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2004/3000 [00:05&lt;00:02, 368.74it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2041/3000 [00:05&lt;00:02, 368.60it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2079/3000 [00:06&lt;00:02, 369.22it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2116/3000 [00:06&lt;00:02, 366.82it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2153/3000 [00:06&lt;00:02, 367.03it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2191/3000 [00:06&lt;00:02, 367.99it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2228/3000 [00:06&lt;00:02, 368.52it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2265/3000 [00:06&lt;00:01, 368.89it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2303/3000 [00:06&lt;00:01, 369.31it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2340/3000 [00:06&lt;00:01, 369.24it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2377/3000 [00:06&lt;00:01, 368.88it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2414/3000 [00:06&lt;00:01, 368.75it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2451/3000 [00:07&lt;00:01, 368.81it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2488/3000 [00:07&lt;00:01, 369.10it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2525/3000 [00:07&lt;00:01, 368.30it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2562/3000 [00:07&lt;00:01, 368.49it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2599/3000 [00:07&lt;00:01, 368.65it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2636/3000 [00:07&lt;00:00, 368.94it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2673/3000 [00:07&lt;00:00, 344.55it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2710/3000 [00:07&lt;00:00, 351.48it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2747/3000 [00:07&lt;00:00, 356.13it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 2785/3000 [00:08&lt;00:00, 360.36it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2822/3000 [00:08&lt;00:00, 363.10it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2859/3000 [00:08&lt;00:00, 364.39it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2896/3000 [00:08&lt;00:00, 364.76it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2933/3000 [00:08&lt;00:00, 365.97it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2970/3000 [00:08&lt;00:00, 366.87it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:08&lt;00:00, 348.86it/s]</pre> <pre>\n</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   0%|          | 1/3000 [00:00&lt;23:09,  2.16it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   2%|\u258f         | 55/3000 [00:00&lt;00:22, 128.44it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   4%|\u258e         | 105/3000 [00:00&lt;00:13, 220.91it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   5%|\u258c         | 155/3000 [00:00&lt;00:09, 292.88it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   7%|\u258b         | 204/3000 [00:00&lt;00:08, 345.64it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   8%|\u258a         | 253/3000 [00:00&lt;00:07, 385.95it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  10%|\u2588         | 303/3000 [00:01&lt;00:06, 416.25it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  12%|\u2588\u258f        | 352/3000 [00:01&lt;00:06, 437.47it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  13%|\u2588\u258e        | 401/3000 [00:01&lt;00:05, 452.78it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  15%|\u2588\u258c        | 451/3000 [00:01&lt;00:05, 463.97it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  17%|\u2588\u258b        | 500/3000 [00:01&lt;00:05, 471.44it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  18%|\u2588\u258a        | 550/3000 [00:01&lt;00:05, 477.14it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  20%|\u2588\u2589        | 599/3000 [00:01&lt;00:04, 480.64it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  22%|\u2588\u2588\u258f       | 649/3000 [00:01&lt;00:04, 484.52it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  23%|\u2588\u2588\u258e       | 698/3000 [00:01&lt;00:04, 480.58it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  25%|\u2588\u2588\u258d       | 747/3000 [00:01&lt;00:04, 479.18it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  27%|\u2588\u2588\u258b       | 796/3000 [00:02&lt;00:04, 480.77it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  28%|\u2588\u2588\u258a       | 845/3000 [00:02&lt;00:04, 482.74it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  30%|\u2588\u2588\u2589       | 894/3000 [00:02&lt;00:04, 483.33it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  31%|\u2588\u2588\u2588\u258f      | 943/3000 [00:02&lt;00:04, 484.34it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  33%|\u2588\u2588\u2588\u258e      | 992/3000 [00:02&lt;00:04, 484.48it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  35%|\u2588\u2588\u2588\u258d      | 1041/3000 [00:02&lt;00:04, 484.48it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  36%|\u2588\u2588\u2588\u258b      | 1090/3000 [00:02&lt;00:03, 481.74it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  38%|\u2588\u2588\u2588\u258a      | 1139/3000 [00:02&lt;00:03, 481.98it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  40%|\u2588\u2588\u2588\u2589      | 1188/3000 [00:02&lt;00:03, 482.61it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  41%|\u2588\u2588\u2588\u2588      | 1237/3000 [00:02&lt;00:03, 482.34it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  43%|\u2588\u2588\u2588\u2588\u258e     | 1286/3000 [00:03&lt;00:03, 482.70it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  44%|\u2588\u2588\u2588\u2588\u258d     | 1335/3000 [00:03&lt;00:03, 482.76it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  46%|\u2588\u2588\u2588\u2588\u258c     | 1384/3000 [00:03&lt;00:03, 483.07it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  48%|\u2588\u2588\u2588\u2588\u258a     | 1433/3000 [00:03&lt;00:03, 483.60it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  49%|\u2588\u2588\u2588\u2588\u2589     | 1482/3000 [00:03&lt;00:03, 483.15it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  51%|\u2588\u2588\u2588\u2588\u2588     | 1531/3000 [00:03&lt;00:03, 483.36it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1580/3000 [00:03&lt;00:02, 484.02it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1629/3000 [00:03&lt;00:02, 483.64it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1678/3000 [00:03&lt;00:02, 484.41it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1727/3000 [00:04&lt;00:02, 483.43it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1776/3000 [00:04&lt;00:02, 483.61it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1825/3000 [00:04&lt;00:02, 483.39it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1874/3000 [00:04&lt;00:02, 483.86it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1923/3000 [00:04&lt;00:02, 484.36it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1972/3000 [00:04&lt;00:02, 483.61it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2021/3000 [00:04&lt;00:02, 484.44it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2070/3000 [00:04&lt;00:01, 484.71it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2119/3000 [00:04&lt;00:01, 480.47it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2168/3000 [00:04&lt;00:01, 481.04it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2217/3000 [00:05&lt;00:01, 482.21it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2266/3000 [00:05&lt;00:01, 484.20it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2315/3000 [00:05&lt;00:01, 483.83it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2364/3000 [00:05&lt;00:01, 484.24it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2413/3000 [00:05&lt;00:01, 484.64it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2462/3000 [00:05&lt;00:01, 484.85it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2511/3000 [00:05&lt;00:01, 484.75it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2560/3000 [00:05&lt;00:00, 484.38it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2609/3000 [00:05&lt;00:00, 482.68it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2658/3000 [00:05&lt;00:00, 483.17it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2707/3000 [00:06&lt;00:00, 483.87it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2756/3000 [00:06&lt;00:00, 484.22it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 2805/3000 [00:06&lt;00:00, 485.33it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2854/3000 [00:06&lt;00:00, 485.75it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2903/3000 [00:06&lt;00:00, 485.40it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2952/3000 [00:06&lt;00:00, 485.33it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:06&lt;00:00, 451.86it/s]</pre> <pre>\n</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   0%|          | 1/3000 [00:00&lt;23:23,  2.14it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   2%|\u258f         | 64/3000 [00:00&lt;00:19, 148.46it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   4%|\u258d         | 123/3000 [00:00&lt;00:11, 257.78it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   6%|\u258c         | 182/3000 [00:00&lt;00:08, 343.57it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   8%|\u258a         | 241/3000 [00:00&lt;00:06, 409.16it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  10%|\u2588         | 300/3000 [00:00&lt;00:05, 457.50it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  12%|\u2588\u258f        | 359/3000 [00:01&lt;00:05, 492.92it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  14%|\u2588\u258d        | 417/3000 [00:01&lt;00:04, 516.85it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  16%|\u2588\u258c        | 476/3000 [00:01&lt;00:04, 535.85it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  18%|\u2588\u258a        | 534/3000 [00:01&lt;00:04, 546.19it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  20%|\u2588\u2589        | 592/3000 [00:01&lt;00:04, 555.17it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  22%|\u2588\u2588\u258f       | 651/3000 [00:01&lt;00:04, 562.93it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  24%|\u2588\u2588\u258e       | 710/3000 [00:01&lt;00:04, 568.99it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  26%|\u2588\u2588\u258c       | 769/3000 [00:01&lt;00:03, 572.94it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  28%|\u2588\u2588\u258a       | 828/3000 [00:01&lt;00:03, 575.89it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  30%|\u2588\u2588\u2589       | 887/3000 [00:01&lt;00:03, 577.27it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  32%|\u2588\u2588\u2588\u258f      | 946/3000 [00:02&lt;00:03, 578.78it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  34%|\u2588\u2588\u2588\u258e      | 1005/3000 [00:02&lt;00:03, 579.54it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  35%|\u2588\u2588\u2588\u258c      | 1064/3000 [00:02&lt;00:03, 580.77it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  37%|\u2588\u2588\u2588\u258b      | 1123/3000 [00:02&lt;00:03, 581.67it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  39%|\u2588\u2588\u2588\u2589      | 1182/3000 [00:02&lt;00:03, 580.99it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  41%|\u2588\u2588\u2588\u2588\u258f     | 1241/3000 [00:02&lt;00:03, 581.18it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  43%|\u2588\u2588\u2588\u2588\u258e     | 1300/3000 [00:02&lt;00:02, 581.25it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  45%|\u2588\u2588\u2588\u2588\u258c     | 1359/3000 [00:02&lt;00:02, 581.79it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  47%|\u2588\u2588\u2588\u2588\u258b     | 1418/3000 [00:02&lt;00:02, 581.75it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  49%|\u2588\u2588\u2588\u2588\u2589     | 1477/3000 [00:03&lt;00:02, 581.58it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  51%|\u2588\u2588\u2588\u2588\u2588     | 1536/3000 [00:03&lt;00:02, 579.64it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1595/3000 [00:03&lt;00:02, 580.44it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1654/3000 [00:03&lt;00:02, 581.25it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1713/3000 [00:03&lt;00:02, 581.57it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1772/3000 [00:03&lt;00:02, 580.18it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1831/3000 [00:03&lt;00:02, 581.18it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1890/3000 [00:03&lt;00:01, 581.69it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1949/3000 [00:03&lt;00:01, 582.01it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2008/3000 [00:03&lt;00:01, 582.32it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2067/3000 [00:04&lt;00:01, 581.55it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2126/3000 [00:04&lt;00:01, 580.99it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2185/3000 [00:04&lt;00:01, 581.75it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2244/3000 [00:04&lt;00:01, 582.08it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2303/3000 [00:04&lt;00:01, 582.51it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2362/3000 [00:04&lt;00:01, 581.56it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2421/3000 [00:04&lt;00:00, 582.13it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2480/3000 [00:04&lt;00:00, 582.57it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2539/3000 [00:04&lt;00:00, 573.18it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2598/3000 [00:04&lt;00:00, 575.74it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2657/3000 [00:05&lt;00:00, 578.17it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2716/3000 [00:05&lt;00:00, 579.34it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 2775/3000 [00:05&lt;00:00, 580.34it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2834/3000 [00:05&lt;00:00, 581.65it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2893/3000 [00:05&lt;00:00, 581.57it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2952/3000 [00:05&lt;00:00, 581.49it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:05&lt;00:00, 533.31it/s]</pre> <pre>\n</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   0%|          | 1/3000 [00:00&lt;23:17,  2.15it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   3%|\u258e         | 78/3000 [00:00&lt;00:16, 182.06it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   5%|\u258d         | 148/3000 [00:00&lt;00:09, 311.94it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   7%|\u258b         | 219/3000 [00:00&lt;00:06, 415.53it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  10%|\u2589         | 289/3000 [00:00&lt;00:05, 493.11it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  12%|\u2588\u258f        | 360/3000 [00:00&lt;00:04, 552.07it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  14%|\u2588\u258d        | 429/3000 [00:01&lt;00:04, 589.81it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  17%|\u2588\u258b        | 499/3000 [00:01&lt;00:04, 621.31it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  19%|\u2588\u2589        | 570/3000 [00:01&lt;00:03, 644.75it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  21%|\u2588\u2588\u258f       | 641/3000 [00:01&lt;00:03, 662.30it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  24%|\u2588\u2588\u258e       | 711/3000 [00:01&lt;00:03, 671.09it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  26%|\u2588\u2588\u258c       | 781/3000 [00:01&lt;00:03, 679.40it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  28%|\u2588\u2588\u258a       | 852/3000 [00:01&lt;00:03, 686.24it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  31%|\u2588\u2588\u2588       | 922/3000 [00:01&lt;00:03, 682.32it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  33%|\u2588\u2588\u2588\u258e      | 992/3000 [00:01&lt;00:02, 687.52it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  35%|\u2588\u2588\u2588\u258c      | 1063/3000 [00:01&lt;00:02, 690.43it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  38%|\u2588\u2588\u2588\u258a      | 1133/3000 [00:02&lt;00:02, 692.50it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  40%|\u2588\u2588\u2588\u2588      | 1203/3000 [00:02&lt;00:02, 693.76it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  42%|\u2588\u2588\u2588\u2588\u258f     | 1274/3000 [00:02&lt;00:02, 696.17it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  45%|\u2588\u2588\u2588\u2588\u258d     | 1345/3000 [00:02&lt;00:02, 697.79it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  47%|\u2588\u2588\u2588\u2588\u258b     | 1415/3000 [00:02&lt;00:02, 697.82it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  50%|\u2588\u2588\u2588\u2588\u2589     | 1486/3000 [00:02&lt;00:02, 699.24it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1557/3000 [00:02&lt;00:02, 699.56it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1627/3000 [00:02&lt;00:01, 699.28it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1698/3000 [00:02&lt;00:01, 699.86it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1769/3000 [00:02&lt;00:01, 696.59it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  61%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1840/3000 [00:03&lt;00:01, 698.38it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1910/3000 [00:03&lt;00:01, 697.98it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1981/3000 [00:03&lt;00:01, 699.14it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2052/3000 [00:03&lt;00:01, 692.80it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2123/3000 [00:03&lt;00:01, 695.83it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2194/3000 [00:03&lt;00:01, 697.97it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2264/3000 [00:03&lt;00:01, 697.88it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2334/3000 [00:03&lt;00:00, 698.06it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2405/3000 [00:03&lt;00:00, 698.89it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2476/3000 [00:04&lt;00:00, 700.08it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2547/3000 [00:04&lt;00:00, 701.03it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2618/3000 [00:04&lt;00:00, 698.39it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2688/3000 [00:04&lt;00:00, 698.73it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2758/3000 [00:04&lt;00:00, 698.81it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2829/3000 [00:04&lt;00:00, 699.53it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2900/3000 [00:04&lt;00:00, 700.16it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2971/3000 [00:04&lt;00:00, 699.76it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:04&lt;00:00, 631.09it/s]</pre> <pre>\n</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   0%|          | 1/3000 [00:00&lt;23:21,  2.14it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   3%|\u258e         | 80/3000 [00:00&lt;00:15, 186.06it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   5%|\u258c         | 156/3000 [00:00&lt;00:08, 329.24it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   8%|\u258a         | 232/3000 [00:00&lt;00:06, 441.06it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  10%|\u2588         | 308/3000 [00:00&lt;00:05, 527.46it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  13%|\u2588\u258e        | 384/3000 [00:00&lt;00:04, 592.03it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  15%|\u2588\u258c        | 460/3000 [00:01&lt;00:03, 638.79it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  18%|\u2588\u258a        | 536/3000 [00:01&lt;00:03, 671.82it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  20%|\u2588\u2588        | 612/3000 [00:01&lt;00:03, 696.22it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  23%|\u2588\u2588\u258e       | 688/3000 [00:01&lt;00:03, 712.84it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  25%|\u2588\u2588\u258c       | 764/3000 [00:01&lt;00:03, 725.94it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  28%|\u2588\u2588\u258a       | 840/3000 [00:01&lt;00:02, 735.72it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  31%|\u2588\u2588\u2588       | 916/3000 [00:01&lt;00:02, 735.53it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  33%|\u2588\u2588\u2588\u258e      | 992/3000 [00:01&lt;00:02, 740.53it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  36%|\u2588\u2588\u2588\u258c      | 1069/3000 [00:01&lt;00:02, 746.47it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  38%|\u2588\u2588\u2588\u258a      | 1145/3000 [00:01&lt;00:02, 750.41it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  41%|\u2588\u2588\u2588\u2588      | 1221/3000 [00:02&lt;00:02, 743.94it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  43%|\u2588\u2588\u2588\u2588\u258e     | 1297/3000 [00:02&lt;00:02, 747.41it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  46%|\u2588\u2588\u2588\u2588\u258c     | 1374/3000 [00:02&lt;00:02, 751.68it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  48%|\u2588\u2588\u2588\u2588\u258a     | 1450/3000 [00:02&lt;00:02, 753.44it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  51%|\u2588\u2588\u2588\u2588\u2588     | 1526/3000 [00:02&lt;00:01, 754.66it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1602/3000 [00:02&lt;00:01, 754.65it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1678/3000 [00:02&lt;00:01, 755.74it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1754/3000 [00:02&lt;00:01, 755.28it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1830/3000 [00:02&lt;00:01, 756.18it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1906/3000 [00:02&lt;00:01, 756.34it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1983/3000 [00:03&lt;00:01, 757.88it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2059/3000 [00:03&lt;00:01, 757.77it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2135/3000 [00:03&lt;00:01, 745.38it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2211/3000 [00:03&lt;00:01, 747.32it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2288/3000 [00:03&lt;00:00, 751.56it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2364/3000 [00:03&lt;00:00, 753.35it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2440/3000 [00:03&lt;00:00, 753.28it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2516/3000 [00:03&lt;00:00, 753.71it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2592/3000 [00:03&lt;00:00, 754.20it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2668/3000 [00:04&lt;00:00, 754.74it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2744/3000 [00:04&lt;00:00, 755.98it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2820/3000 [00:04&lt;00:00, 756.95it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2896/3000 [00:04&lt;00:00, 757.24it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2972/3000 [00:04&lt;00:00, 757.57it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:04&lt;00:00, 675.55it/s]</pre> <pre>\n</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:   0%|          | 1/3000 [00:00&lt;31:33,  1.58it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:   4%|\u258d         | 113/3000 [00:00&lt;00:13, 207.89it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:   8%|\u258a         | 228/3000 [00:00&lt;00:06, 403.69it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  11%|\u2588\u258f        | 341/3000 [00:00&lt;00:04, 569.86it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  15%|\u2588\u258c        | 455/3000 [00:01&lt;00:03, 710.42it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  19%|\u2588\u2589        | 569/3000 [00:01&lt;00:02, 821.33it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  23%|\u2588\u2588\u258e       | 683/3000 [00:01&lt;00:02, 906.73it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  27%|\u2588\u2588\u258b       | 797/3000 [00:01&lt;00:02, 971.60it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  30%|\u2588\u2588\u2588       | 912/3000 [00:01&lt;00:02, 1020.50it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  34%|\u2588\u2588\u2588\u258d      | 1027/3000 [00:01&lt;00:01, 1055.27it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  38%|\u2588\u2588\u2588\u258a      | 1140/3000 [00:01&lt;00:01, 1062.06it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  42%|\u2588\u2588\u2588\u2588\u258f     | 1254/3000 [00:01&lt;00:01, 1084.24it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  46%|\u2588\u2588\u2588\u2588\u258c     | 1368/3000 [00:01&lt;00:01, 1100.49it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  49%|\u2588\u2588\u2588\u2588\u2589     | 1483/3000 [00:01&lt;00:01, 1112.31it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1597/3000 [00:02&lt;00:01, 1120.07it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1711/3000 [00:02&lt;00:01, 1125.68it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1825/3000 [00:02&lt;00:01, 1126.62it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1939/3000 [00:02&lt;00:00, 1130.16it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2054/3000 [00:02&lt;00:00, 1133.20it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2168/3000 [00:02&lt;00:00, 1122.50it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2281/3000 [00:02&lt;00:00, 1124.60it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2395/3000 [00:02&lt;00:00, 1128.00it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2509/3000 [00:02&lt;00:00, 1131.28it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2623/3000 [00:02&lt;00:00, 1132.97it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2737/3000 [00:03&lt;00:00, 1132.88it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2851/3000 [00:03&lt;00:00, 1134.25it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2965/3000 [00:03&lt;00:00, 1132.80it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:03&lt;00:00, 914.15it/s] </pre> <pre>\n</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:   0%|          | 1/3000 [00:00&lt;23:31,  2.12it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:   5%|\u258c         | 150/3000 [00:00&lt;00:08, 348.11it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  10%|\u2588         | 301/3000 [00:00&lt;00:04, 637.72it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  15%|\u2588\u258c        | 453/3000 [00:00&lt;00:02, 868.88it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  20%|\u2588\u2588        | 605/3000 [00:00&lt;00:02, 1046.10it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  25%|\u2588\u2588\u258c       | 757/3000 [00:00&lt;00:01, 1177.99it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  30%|\u2588\u2588\u2588       | 908/3000 [00:01&lt;00:01, 1272.56it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  35%|\u2588\u2588\u2588\u258c      | 1060/3000 [00:01&lt;00:01, 1343.46it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  40%|\u2588\u2588\u2588\u2588      | 1211/3000 [00:01&lt;00:01, 1389.98it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  45%|\u2588\u2588\u2588\u2588\u258c     | 1363/3000 [00:01&lt;00:01, 1426.25it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  50%|\u2588\u2588\u2588\u2588\u2588     | 1515/3000 [00:01&lt;00:01, 1453.45it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1665/3000 [00:01&lt;00:00, 1466.56it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1815/3000 [00:01&lt;00:00, 1472.59it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1966/3000 [00:01&lt;00:00, 1483.22it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2117/3000 [00:01&lt;00:00, 1490.81it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2269/3000 [00:01&lt;00:00, 1497.77it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2420/3000 [00:02&lt;00:00, 1500.90it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2572/3000 [00:02&lt;00:00, 1504.98it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2723/3000 [00:02&lt;00:00, 1503.44it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2875/3000 [00:02&lt;00:00, 1505.93it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1219.47it/s]</pre> <pre>\n</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:   0%|          | 1/3000 [00:00&lt;23:29,  2.13it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:   5%|\u258c         | 158/3000 [00:00&lt;00:07, 367.41it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  11%|\u2588         | 326/3000 [00:00&lt;00:03, 694.08it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  16%|\u2588\u258b        | 493/3000 [00:00&lt;00:02, 950.36it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  22%|\u2588\u2588\u258f       | 660/3000 [00:00&lt;00:02, 1146.34it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  28%|\u2588\u2588\u258a       | 828/3000 [00:00&lt;00:01, 1294.07it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  33%|\u2588\u2588\u2588\u258e      | 994/3000 [00:01&lt;00:01, 1398.49it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  39%|\u2588\u2588\u2588\u258a      | 1156/3000 [00:01&lt;00:01, 1462.17it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  44%|\u2588\u2588\u2588\u2588\u258d     | 1319/3000 [00:01&lt;00:01, 1511.09it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  49%|\u2588\u2588\u2588\u2588\u2589     | 1481/3000 [00:01&lt;00:00, 1534.18it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1648/3000 [00:01&lt;00:00, 1572.83it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1816/3000 [00:01&lt;00:00, 1601.83it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1984/3000 [00:01&lt;00:00, 1623.21it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2151/3000 [00:01&lt;00:00, 1635.66it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2318/3000 [00:01&lt;00:00, 1645.15it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2485/3000 [00:01&lt;00:00, 1652.20it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2652/3000 [00:02&lt;00:00, 1654.50it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2819/3000 [00:02&lt;00:00, 1658.16it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2987/3000 [00:02&lt;00:00, 1662.43it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1311.99it/s]</pre> <pre>\n</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:   0%|          | 1/3000 [00:00&lt;23:45,  2.10it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:   5%|\u258c         | 158/3000 [00:00&lt;00:07, 364.08it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  11%|\u2588\u258f        | 338/3000 [00:00&lt;00:03, 719.94it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  17%|\u2588\u258b        | 519/3000 [00:00&lt;00:02, 1004.07it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  23%|\u2588\u2588\u258e       | 701/3000 [00:00&lt;00:01, 1224.44it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  29%|\u2588\u2588\u2589       | 863/3000 [00:01&lt;00:01, 1181.08it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  34%|\u2588\u2588\u2588\u258e      | 1008/3000 [00:01&lt;00:01, 1232.48it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  40%|\u2588\u2588\u2588\u2589      | 1190/3000 [00:01&lt;00:01, 1389.78it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  46%|\u2588\u2588\u2588\u2588\u258c     | 1373/3000 [00:01&lt;00:01, 1509.75it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1554/3000 [00:01&lt;00:00, 1592.61it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1735/3000 [00:01&lt;00:00, 1655.09it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1916/3000 [00:01&lt;00:00, 1698.14it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2097/3000 [00:01&lt;00:00, 1730.53it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2279/3000 [00:01&lt;00:00, 1756.38it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2461/3000 [00:01&lt;00:00, 1772.51it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2642/3000 [00:02&lt;00:00, 1783.63it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2824/3000 [00:02&lt;00:00, 1794.21it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1346.15it/s]</pre> <pre>\n</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:   0%|          | 1/3000 [00:00&lt;23:39,  2.11it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:   5%|\u258c         | 160/3000 [00:00&lt;00:07, 369.85it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  11%|\u2588         | 332/3000 [00:00&lt;00:03, 705.47it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  17%|\u2588\u258b        | 516/3000 [00:00&lt;00:02, 1002.15it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  23%|\u2588\u2588\u258e       | 703/3000 [00:00&lt;00:01, 1236.96it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  29%|\u2588\u2588\u2589       | 867/3000 [00:00&lt;00:01, 1330.08it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  35%|\u2588\u2588\u2588\u258c      | 1056/3000 [00:01&lt;00:01, 1487.12it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  41%|\u2588\u2588\u2588\u2588\u258f     | 1241/3000 [00:01&lt;00:01, 1590.78it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  48%|\u2588\u2588\u2588\u2588\u258a     | 1429/3000 [00:01&lt;00:00, 1674.74it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1618/3000 [00:01&lt;00:00, 1735.97it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1800/3000 [00:01&lt;00:00, 1749.08it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 1988/3000 [00:01&lt;00:00, 1787.00it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2176/3000 [00:01&lt;00:00, 1814.03it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2365/3000 [00:01&lt;00:00, 1833.98it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2553/3000 [00:01&lt;00:00, 1847.46it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2741/3000 [00:01&lt;00:00, 1854.78it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2929/3000 [00:02&lt;00:00, 1861.41it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1412.02it/s]</pre> <pre>\n</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:   0%|          | 1/3000 [00:00&lt;32:18,  1.55it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:   5%|\u258c         | 157/3000 [00:00&lt;00:10, 283.59it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  11%|\u2588         | 318/3000 [00:00&lt;00:04, 555.86it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  17%|\u2588\u258b        | 508/3000 [00:00&lt;00:02, 859.77it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  23%|\u2588\u2588\u258e       | 701/3000 [00:01&lt;00:02, 1120.03it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  30%|\u2588\u2588\u2589       | 893/3000 [00:01&lt;00:01, 1325.44it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  36%|\u2588\u2588\u2588\u258c      | 1087/3000 [00:01&lt;00:01, 1489.52it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  43%|\u2588\u2588\u2588\u2588\u258e     | 1279/3000 [00:01&lt;00:01, 1608.50it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  49%|\u2588\u2588\u2588\u2588\u2589     | 1472/3000 [00:01&lt;00:00, 1699.01it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1665/3000 [00:01&lt;00:00, 1763.37it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1858/3000 [00:01&lt;00:00, 1809.85it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2049/3000 [00:01&lt;00:00, 1837.99it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2242/3000 [00:01&lt;00:00, 1863.57it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2435/3000 [00:01&lt;00:00, 1881.82it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2628/3000 [00:02&lt;00:00, 1895.92it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2821/3000 [00:02&lt;00:00, 1904.24it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1336.72it/s]</pre> <pre>\n</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:   0%|          | 1/3000 [00:00&lt;23:32,  2.12it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:   5%|\u258c         | 159/3000 [00:00&lt;00:07, 368.93it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  11%|\u2588         | 319/3000 [00:00&lt;00:03, 675.37it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  16%|\u2588\u258c        | 482/3000 [00:00&lt;00:02, 925.77it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  22%|\u2588\u2588\u258f       | 674/3000 [00:00&lt;00:01, 1196.09it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  29%|\u2588\u2588\u2589       | 871/3000 [00:00&lt;00:01, 1411.88it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  36%|\u2588\u2588\u2588\u258c      | 1067/3000 [00:01&lt;00:01, 1567.81it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  42%|\u2588\u2588\u2588\u2588\u258f     | 1263/3000 [00:01&lt;00:01, 1680.14it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  49%|\u2588\u2588\u2588\u2588\u258a     | 1459/3000 [00:01&lt;00:00, 1760.20it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1654/3000 [00:01&lt;00:00, 1814.99it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1850/3000 [00:01&lt;00:00, 1857.37it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2047/3000 [00:01&lt;00:00, 1889.91it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2244/3000 [00:01&lt;00:00, 1912.76it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2439/3000 [00:01&lt;00:00, 1902.01it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2635/3000 [00:01&lt;00:00, 1916.59it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2832/3000 [00:01&lt;00:00, 1930.83it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1452.21it/s]</pre> <pre>\n</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:   0%|          | 1/3000 [00:00&lt;23:49,  2.10it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:   5%|\u258c         | 159/3000 [00:00&lt;00:07, 365.77it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  11%|\u2588         | 317/3000 [00:00&lt;00:04, 666.16it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  16%|\u2588\u258c        | 478/3000 [00:00&lt;00:02, 912.41it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  22%|\u2588\u2588\u258f       | 650/3000 [00:00&lt;00:02, 1131.56it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  28%|\u2588\u2588\u258a       | 840/3000 [00:00&lt;00:01, 1344.86it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  35%|\u2588\u2588\u2588\u258d      | 1037/3000 [00:01&lt;00:01, 1523.03it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  41%|\u2588\u2588\u2588\u2588      | 1234/3000 [00:01&lt;00:01, 1651.90it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  48%|\u2588\u2588\u2588\u2588\u258a     | 1432/3000 [00:01&lt;00:00, 1745.59it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1631/3000 [00:01&lt;00:00, 1815.47it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1828/3000 [00:01&lt;00:00, 1860.35it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2026/3000 [00:01&lt;00:00, 1893.44it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2223/3000 [00:01&lt;00:00, 1915.25it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2420/3000 [00:01&lt;00:00, 1928.70it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2618/3000 [00:01&lt;00:00, 1941.62it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2814/3000 [00:01&lt;00:00, 1946.62it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1445.56it/s]</pre> <pre>\n</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:   0%|          | 1/3000 [00:00&lt;23:37,  2.12it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:   5%|\u258c         | 159/3000 [00:00&lt;00:07, 368.06it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  11%|\u2588         | 317/3000 [00:00&lt;00:04, 668.86it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  16%|\u2588\u258c        | 477/3000 [00:00&lt;00:02, 911.95it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  21%|\u2588\u2588\u258f       | 638/3000 [00:00&lt;00:02, 1101.68it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  27%|\u2588\u2588\u258b       | 802/3000 [00:00&lt;00:01, 1250.31it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  33%|\u2588\u2588\u2588\u258e      | 981/3000 [00:01&lt;00:01, 1403.47it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  39%|\u2588\u2588\u2588\u2589      | 1178/3000 [00:01&lt;00:01, 1565.48it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  46%|\u2588\u2588\u2588\u2588\u258c     | 1374/3000 [00:01&lt;00:00, 1679.34it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1574/3000 [00:01&lt;00:00, 1773.23it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1776/3000 [00:01&lt;00:00, 1843.60it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1976/3000 [00:01&lt;00:00, 1889.77it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2177/3000 [00:01&lt;00:00, 1923.23it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2378/3000 [00:01&lt;00:00, 1947.22it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2578/3000 [00:01&lt;00:00, 1961.83it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 2779/3000 [00:01&lt;00:00, 1973.90it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2980/3000 [00:02&lt;00:00, 1981.96it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1435.57it/s]</pre> <pre>\n</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:   0%|          | 1/3000 [00:00&lt;23:33,  2.12it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:   5%|\u258c         | 159/3000 [00:00&lt;00:07, 368.82it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  11%|\u2588         | 317/3000 [00:00&lt;00:04, 670.53it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  16%|\u2588\u258c        | 476/3000 [00:00&lt;00:02, 911.09it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  21%|\u2588\u2588        | 636/3000 [00:00&lt;00:02, 1097.23it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  27%|\u2588\u2588\u258b       | 798/3000 [00:00&lt;00:01, 1241.96it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  32%|\u2588\u2588\u2588\u258f      | 960/3000 [00:01&lt;00:01, 1349.10it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  38%|\u2588\u2588\u2588\u258a      | 1125/3000 [00:01&lt;00:01, 1434.32it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  43%|\u2588\u2588\u2588\u2588\u258e     | 1302/3000 [00:01&lt;00:01, 1532.23it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  50%|\u2588\u2588\u2588\u2588\u2589     | 1497/3000 [00:01&lt;00:00, 1652.90it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1696/3000 [00:01&lt;00:00, 1750.02it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1896/3000 [00:01&lt;00:00, 1823.31it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2087/3000 [00:01&lt;00:00, 1847.88it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2290/3000 [00:01&lt;00:00, 1901.28it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2491/3000 [00:01&lt;00:00, 1931.91it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2692/3000 [00:01&lt;00:00, 1953.42it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2893/3000 [00:02&lt;00:00, 1968.07it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1408.17it/s]</pre> <pre>\n</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:   0%|          | 1/3000 [00:00&lt;23:32,  2.12it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:   5%|\u258c         | 154/3000 [00:00&lt;00:07, 357.24it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  10%|\u2588         | 310/3000 [00:00&lt;00:04, 656.84it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  16%|\u2588\u258c        | 468/3000 [00:00&lt;00:02, 898.23it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  21%|\u2588\u2588        | 624/3000 [00:00&lt;00:02, 1078.00it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  26%|\u2588\u2588\u258c       | 784/3000 [00:00&lt;00:01, 1223.09it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  32%|\u2588\u2588\u2588\u258f      | 945/3000 [00:01&lt;00:01, 1333.01it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  37%|\u2588\u2588\u2588\u258b      | 1107/3000 [00:01&lt;00:01, 1415.05it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  42%|\u2588\u2588\u2588\u2588\u258f     | 1271/3000 [00:01&lt;00:01, 1478.34it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  48%|\u2588\u2588\u2588\u2588\u258a     | 1439/3000 [00:01&lt;00:01, 1534.99it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1620/3000 [00:01&lt;00:00, 1615.47it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1813/3000 [00:01&lt;00:00, 1708.45it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2010/3000 [00:01&lt;00:00, 1785.27it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2210/3000 [00:01&lt;00:00, 1848.47it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2411/3000 [00:01&lt;00:00, 1896.33it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2614/3000 [00:01&lt;00:00, 1935.31it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2815/3000 [00:02&lt;00:00, 1956.99it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1384.35it/s]</pre> <pre>\n</pre> In\u00a0[12]: Copied! <pre>plt.plot(gammas, np.abs(1 - final_observed / final_expected), \"o\")\nplt.xlabel(r\"$\\gamma$\")\nplt.ylabel(\"$| 1 - \\\\frac{I(\\\\infty)_{obs}}{I(\\\\infty)_{exp}} |$\")\nplt.title(r\"Error in equilibrium infected fraction increases roughly linearly in $\\gamma \\Delta t$\")\n</pre> plt.plot(gammas, np.abs(1 - final_observed / final_expected), \"o\") plt.xlabel(r\"$\\gamma$\") plt.ylabel(\"$| 1 - \\\\frac{I(\\\\infty)_{obs}}{I(\\\\infty)_{exp}} |$\") plt.title(r\"Error in equilibrium infected fraction increases roughly linearly in $\\gamma \\Delta t$\") Out[12]: <pre>Text(0.5, 1.0, 'Error in equilibrium infected fraction increases roughly linearly in $\\\\gamma \\\\Delta t$')</pre>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#sis-model-with-no-demographics","title":"SIS Model with no demographics\u00b6","text":"<p>Moving on from the SI model to something slighlty more complex, we will add a state transition from infected back to susceptible, with no period of immunity - this is the SIS model.  It turns out that the equations governing this will be analogous to the SI model with demography - rather than births &amp; mortality providing routes to add susceptibles and subtract infectives, this transition from infective -&gt; susceptible will provide essentially the same mechanism.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\gamma I\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I $$</p> <p>As before, subbing $S = N-I$ into the second equation gives us</p> <p>$$ \\dot{I} = \\beta I ( 1-\\frac{\\gamma}{\\beta}-\\frac{I}{N})$$</p> <p>And comparing against the SI model with births, it is clear this equation is of the same form, with solution $$ \\frac{Nx}{1+(\\frac{Nx}{I_0}-1)e^{-\\beta x t}} \\\\ x = (1-\\frac{\\gamma}{\\beta}) $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with three components: <code>Susceptibility</code>, <code>Transmission</code>, and <code>Infection_SIS</code> - this component will require a new agent property <code>itimer</code>, and upon expiration of <code>itimer</code> agents will return to the susceptible state.  Finally, we initialize with a single infection and run.  The <code>Susceptibility</code> and <code>Transmission</code> components are previously described.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  As before, we first test on a single instance of the model and show that the expected output is recovered.  Then, we select a few values of $\\beta$ and $\\gamma$, run the model, fit the outputs to the logistic equation, and compare the fitted value of $\\beta$ and $\\gamma$ to the known values; all of the considerations noted in the SI with births model, in terms of how to approach this fit, are echoed again here.  Of particular concern is the approximation of an exponential transition from infected back to susceptible - as we are doing a first-order finite timestep integration here, that approximation will probably produce an error linear in $\\gamma \\Delta t$ between the analytic result and the modeled result.  In fact, in a lot of real disease models, we have compartment dwell times in the exposed and infective states that are only a handful of $\\Delta t$ long, but when doing real epi modeling and calibrating model parameters to uncertain data, this is generally not likely to be a dominant source of bias, uncertainty, etc.  But when comparing specifically against an analytic result, it can become significant.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the relationships between susceptible, infected, and total population hold.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#this-calculation-isnt-informative-we-should-look-at-s-i-and-incidence-to-check-consistency","title":"This calculation isn't informative. We should look at S, I, and incidence to check consistency.\u00b6","text":""},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#single-simulation-check","title":"Single-simulation check\u00b6","text":"<p>As before, starting with a single infection induces some stochasticity in terms of when the outbreak really starts to take off, and so we fit the expected behavior with a free offset parameter below.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of $\\beta$ &amp; $\\gamma$  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>We will use only relatively large values of $\\gamma$ for this procedure.  The reason why will become clear in a second test, where we demonstrate that there is an error between the expected final size and the modeled final size, and that this error shrinks with $\\gamma \\Delta t$, as we would expect a first-order approximation error to.</p> <p>To make this a pass-fail test, we will raise a flag if the fitted parameters are more than 5% different than the known ones.</p>"},{"location":"tutorials/notebooks/03_SIS_nobirths_logistic_growth/#quick-demonstration-of-first-order-error-accumulation","title":"Quick demonstration of first-order error accumulation\u00b6","text":"<p>As noted before, for $\\gamma \\Delta t$ large, first-order integration like we are doing here can accumulate substantial error.  Calculating exactly how error will accumulate in an integrator for a dynamic process like this is beyond the scope here, and probably depends on a lot of details.  E.g., the ordering of steps - in a given step, does the <code>transmission</code> update from S-&gt;I state occur before or after the <code>infection</code> update that sends agents from I-&gt;S?  Do we use midpoint methods, timer countdowns, or take advantage of the unique memorylessness of the exponential distribution to simply remove a random fraction each time?  All that is beyond scope here, but just want to demonstrate that the error in the equilibrium value $I(t \\rightarrow \\infty)$ becomes large when the mean infectious period $\\frac{1}{\\gamma}$ is on the same order as $\\Delta t$</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/","title":"Outbreak size in the SIR model (Kermack-McKendrick relation)","text":"In\u00a0[1]: Copied! <pre>import itertools\n\nimport matplotlib.pyplot as plt\nimport numba as nb\nimport numpy as np\nimport pandas as pd\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import fsolve\nfrom scipy.special import lambertw\n\nimport laser.core\nimport laser.generic\nimport laser.core.distributions as dists\nfrom laser.generic.models import SIR\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import ValuesMap\nfrom laser.generic.newutils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import itertools  import matplotlib.pyplot as plt import numba as nb import numpy as np import pandas as pd from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.core.propertyset import PropertySet from scipy.optimize import fsolve from scipy.special import lambertw  import laser.core import laser.generic import laser.core.distributions as dists from laser.generic.models import SIR from laser.generic.models.model import Model from laser.generic.newutils import ValuesMap from laser.generic.newutils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.5'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>def create_single_node_model(population: int, init_inf: int = 0, init_rec: int = 0, parameters: PropertySet = None) -&gt; Model:\n\n    scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: population, origin_x=0, origin_y=0)\n    scenario[\"S\"] = scenario.population - (init_inf + init_rec)\n    assert np.all(scenario[\"S\"] &gt;= 0), \"Initial susceptible population cannot be negative.\"\n    scenario[\"I\"] = init_inf\n    scenario[\"R\"] = init_rec\n\n    params = parameters or PropertySet({\"seed\": 20251017, \"nticks\": 365, \"beta\": 4.0/3.0, \"inf_mean\": 7.0, \"cbr\": 0.0, \"cdr\": 0.0})\n    for key in [\"beta\", \"inf_mean\"]:\n        assert key in params, f\"Parameter '{key}' must be specified.\"\n\n    model = Model(scenario, params)\n\n    infdurdist = dists.exponential(scale=params.inf_mean)\n\n    model.components = [SIR.Susceptible(model), SIR.Recovered(model), SIR.Infectious(model, infdurdist), SIR.Transmission(model, infdurdist)]\n\n    return model\n</pre> def create_single_node_model(population: int, init_inf: int = 0, init_rec: int = 0, parameters: PropertySet = None) -&gt; Model:      scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: population, origin_x=0, origin_y=0)     scenario[\"S\"] = scenario.population - (init_inf + init_rec)     assert np.all(scenario[\"S\"] &gt;= 0), \"Initial susceptible population cannot be negative.\"     scenario[\"I\"] = init_inf     scenario[\"R\"] = init_rec      params = parameters or PropertySet({\"seed\": 20251017, \"nticks\": 365, \"beta\": 4.0/3.0, \"inf_mean\": 7.0, \"cbr\": 0.0, \"cdr\": 0.0})     for key in [\"beta\", \"inf_mean\"]:         assert key in params, f\"Parameter '{key}' must be specified.\"      model = Model(scenario, params)      infdurdist = dists.exponential(scale=params.inf_mean)      model.components = [SIR.Susceptible(model), SIR.Recovered(model), SIR.Infectious(model, infdurdist), SIR.Transmission(model, infdurdist)]      return model In\u00a0[3]: Copied! <pre>pop = 1e5\ninitial_infected = 3\n# R0 = beta * inf_mean = 0.2 * 15 = 3.0 - expected attack fraction is just under 80%\nparameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.2, \"inf_mean\": 15})\n\n# Run simulations until we get an outbreak\noutbreak = False\nwhile not outbreak:\n\n    parameters.seed += 1\n    model = create_single_node_model(\n        population=pop,\n        init_inf=initial_infected,\n        init_rec=0,\n        parameters=parameters,\n    )\n\n    model.run()\n    outbreak = np.any(model.nodes.R[200] &gt;= 10)\n\nplt.plot(model.nodes.I)\n</pre> pop = 1e5 initial_infected = 3 # R0 = beta * inf_mean = 0.2 * 15 = 3.0 - expected attack fraction is just under 80% parameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.2, \"inf_mean\": 15})  # Run simulations until we get an outbreak outbreak = False while not outbreak:      parameters.seed += 1     model = create_single_node_model(         population=pop,         init_inf=initial_infected,         init_rec=0,         parameters=parameters,     )      model.run()     outbreak = np.any(model.nodes.R[200] &gt;= 10)  plt.plot(model.nodes.I) <pre>\r100000 agents in f1 nodes:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\r100000 agents in f1 nodes:   0%|          | 1/730 [00:01&lt;15:44,  1.30s/it]</pre> <pre>\r100000 agents in f1 nodes:  33%|\u2588\u2588\u2588\u258e      | 238/730 [00:01&lt;00:02, 236.03it/s]</pre> <pre>\r100000 agents in f1 nodes:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 714/730 [00:01&lt;00:00, 797.96it/s]</pre> <pre>\r100000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:01&lt;00:00, 486.34it/s]</pre> <pre>\n</pre> Out[3]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f108df8d010&gt;]</pre> In\u00a0[4]: Copied! <pre># Estimate the outbreak size (attack fraction) using the final size equation\nR0 = parameters.beta * parameters.inf_mean\nS0 = (pop - initial_infected) / pop\nS_inf = -1 / R0 * lambertw(-R0 * S0 * np.exp(-R0)).real\nA = 1 - S_inf  # Attack fraction\nfinal_R = A * pop + initial_infected\n\nplt.plot(model.nodes.S, color=\"blue\")\nplt.plot(model.nodes.I, color=\"red\")\nplt.plot(model.nodes.R, color=\"green\")\nplt.plot(model.nodes.recovered, color=\"orange\", linestyle=\"dashed\")\nplt.axhline(final_R, color=\"darkgray\", linestyle=\"dashed\")\nplt.legend([\"S\", \"I\", \"R\", \"recoveries\", \"Est. R(\u221e)\"])\nplt.xlabel(\"Days\")\nplt.ylabel(\"Number of People\")\nplt.title(\"SIR Model with No Births or Deaths\")\nplt.show()\n</pre> # Estimate the outbreak size (attack fraction) using the final size equation R0 = parameters.beta * parameters.inf_mean S0 = (pop - initial_infected) / pop S_inf = -1 / R0 * lambertw(-R0 * S0 * np.exp(-R0)).real A = 1 - S_inf  # Attack fraction final_R = A * pop + initial_infected  plt.plot(model.nodes.S, color=\"blue\") plt.plot(model.nodes.I, color=\"red\") plt.plot(model.nodes.R, color=\"green\") plt.plot(model.nodes.recovered, color=\"orange\", linestyle=\"dashed\") plt.axhline(final_R, color=\"darkgray\", linestyle=\"dashed\") plt.legend([\"S\", \"I\", \"R\", \"recoveries\", \"Est. R(\u221e)\"]) plt.xlabel(\"Days\") plt.ylabel(\"Number of People\") plt.title(\"SIR Model with No Births or Deaths\") plt.show()  In\u00a0[5]: Copied! <pre>print(\"S+I+R = N:  \" + str(np.isclose(model.nodes.S + model.nodes.I + model.nodes.R, pop).all()))\nprint(\"S = N - sum(deltaI): \" + str(np.isclose(pop - np.squeeze(model.nodes.S)[1:], initial_infected+np.cumsum(model.nodes.incidence)[:-1]).all()))  # Account for 1 timestep offset here\nprint(\"R = sum(deltaR): \" + str(np.isclose(np.squeeze(model.nodes.R)[1:], np.cumsum(model.nodes.recovered)[:-1]).all()))  # Account for 1 timestep offset here\n</pre> print(\"S+I+R = N:  \" + str(np.isclose(model.nodes.S + model.nodes.I + model.nodes.R, pop).all())) print(\"S = N - sum(deltaI): \" + str(np.isclose(pop - np.squeeze(model.nodes.S)[1:], initial_infected+np.cumsum(model.nodes.incidence)[:-1]).all()))  # Account for 1 timestep offset here print(\"R = sum(deltaR): \" + str(np.isclose(np.squeeze(model.nodes.R)[1:], np.cumsum(model.nodes.recovered)[:-1]).all()))  # Account for 1 timestep offset here  <pre>S+I+R = N:  True\nS = N - sum(deltaI): True\nR = sum(deltaR): True\n</pre> In\u00a0[6]: Copied! <pre>def KM_limit(z, R0, S0, I0):\n    if R0 * S0 &lt; 1:\n        return 0\n    else:\n        return z - S0 * (1 - np.exp(-R0 * (z + I0)))\n</pre> def KM_limit(z, R0, S0, I0):     if R0 * S0 &lt; 1:         return 0     else:         return z - S0 * (1 - np.exp(-R0 * (z + I0))) In\u00a0[7]: Copied! <pre># %%capture\n\npopulation = 1e5\ninf_mean = 20\ninit_inf = 20\n\nR0s = np.concatenate((np.linspace(0.2, 1.0, 5), np.linspace(1.5, 10.0, 18)))\nS0s = [1.0, 0.8, 0.6, 0.4, 0.2]\noutput = pd.DataFrame(list(itertools.product(R0s, S0s)), columns=[\"R0\", \"S0\"])\noutput[\"I_inf_exp\"] = [\n    fsolve(KM_limit, 0.5 * (R0 * S0 &gt;= 1), args=(R0, S0, init_inf / population))[0] for R0, S0 in zip(output[\"R0\"], output[\"S0\"])\n]\noutput[\"S_inf_exp\"] = output[\"S0\"] - output[\"I_inf_exp\"]\noutput[\"I_inf_obs\"] = np.nan\noutput[\"S_inf_obs\"] = np.nan\n\n\nfor index, row in output.iterrows():\n\n    parameters = PropertySet({\"seed\": 2, \"nticks\": 1460, \"verbose\": True, \"inf_mean\": inf_mean, \"beta\": row[\"R0\"] / inf_mean})\n    model = create_single_node_model(\n        population=population,\n        init_inf=init_inf,\n        init_rec=int((1 - row[\"S0\"]) * population),\n        parameters=parameters,\n    )\n\n    model.run(f\"SIR Model {index+1:3}/{len(output)}\")\n\n    output.loc[index, \"I_inf_obs\"] = (\n        np.sum(model.nodes.incidence) + init_inf\n    ) / population  # incidence doesn't count the imported infections\n    output.loc[index, \"S_inf_obs\"] = model.nodes.S[-1] / population\n</pre> # %%capture  population = 1e5 inf_mean = 20 init_inf = 20  R0s = np.concatenate((np.linspace(0.2, 1.0, 5), np.linspace(1.5, 10.0, 18))) S0s = [1.0, 0.8, 0.6, 0.4, 0.2] output = pd.DataFrame(list(itertools.product(R0s, S0s)), columns=[\"R0\", \"S0\"]) output[\"I_inf_exp\"] = [     fsolve(KM_limit, 0.5 * (R0 * S0 &gt;= 1), args=(R0, S0, init_inf / population))[0] for R0, S0 in zip(output[\"R0\"], output[\"S0\"]) ] output[\"S_inf_exp\"] = output[\"S0\"] - output[\"I_inf_exp\"] output[\"I_inf_obs\"] = np.nan output[\"S_inf_obs\"] = np.nan   for index, row in output.iterrows():      parameters = PropertySet({\"seed\": 2, \"nticks\": 1460, \"verbose\": True, \"inf_mean\": inf_mean, \"beta\": row[\"R0\"] / inf_mean})     model = create_single_node_model(         population=population,         init_inf=init_inf,         init_rec=int((1 - row[\"S0\"]) * population),         parameters=parameters,     )      model.run(f\"SIR Model {index+1:3}/{len(output)}\")      output.loc[index, \"I_inf_obs\"] = (         np.sum(model.nodes.incidence) + init_inf     ) / population  # incidence doesn't count the imported infections     output.loc[index, \"S_inf_obs\"] = model.nodes.S[-1] / population <pre>\rSIR Model   1/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   1/115:   0%|          | 1/1460 [00:00&lt;11:07,  2.18it/s]</pre> <pre>\rSIR Model   1/115:  10%|\u2589         | 144/1460 [00:00&lt;00:03, 341.68it/s]</pre> <pre>\rSIR Model   1/115:  21%|\u2588\u2588        | 300/1460 [00:00&lt;00:01, 650.20it/s]</pre> <pre>\rSIR Model   1/115:  31%|\u2588\u2588\u2588       | 456/1460 [00:00&lt;00:01, 890.52it/s]</pre> <pre>\rSIR Model   1/115:  42%|\u2588\u2588\u2588\u2588\u258f     | 610/1460 [00:00&lt;00:00, 1068.03it/s]</pre> <pre>\rSIR Model   1/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 766/1460 [00:00&lt;00:00, 1205.32it/s]</pre> <pre>\rSIR Model   1/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 922/1460 [00:01&lt;00:00, 1305.91it/s]</pre> <pre>\rSIR Model   1/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1078/1460 [00:01&lt;00:00, 1379.66it/s]</pre> <pre>\rSIR Model   1/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1233/1460 [00:01&lt;00:00, 1429.59it/s]</pre> <pre>\rSIR Model   1/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1389/1460 [00:01&lt;00:00, 1466.84it/s]</pre> <pre>\rSIR Model   1/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:01&lt;00:00, 1035.47it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   2/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   2/115:  12%|\u2588\u258f        | 181/1460 [00:00&lt;00:00, 1801.59it/s]</pre> <pre>\rSIR Model   2/115:  25%|\u2588\u2588\u258d       | 362/1460 [00:00&lt;00:00, 1785.50it/s]</pre> <pre>\rSIR Model   2/115:  37%|\u2588\u2588\u2588\u258b      | 542/1460 [00:00&lt;00:00, 1787.60it/s]</pre> <pre>\rSIR Model   2/115:  49%|\u2588\u2588\u2588\u2588\u2589     | 722/1460 [00:00&lt;00:00, 1789.37it/s]</pre> <pre>\rSIR Model   2/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 902/1460 [00:00&lt;00:00, 1790.65it/s]</pre> <pre>\rSIR Model   2/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1082/1460 [00:00&lt;00:00, 1788.14it/s]</pre> <pre>\rSIR Model   2/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1262/1460 [00:00&lt;00:00, 1789.56it/s]</pre> <pre>\rSIR Model   2/115:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1442/1460 [00:00&lt;00:00, 1790.04it/s]</pre> <pre>\rSIR Model   2/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1786.12it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   3/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   3/115:  13%|\u2588\u258e        | 192/1460 [00:00&lt;00:00, 1913.56it/s]</pre> <pre>\rSIR Model   3/115:  27%|\u2588\u2588\u258b       | 392/1460 [00:00&lt;00:00, 1959.99it/s]</pre> <pre>\rSIR Model   3/115:  41%|\u2588\u2588\u2588\u2588      | 592/1460 [00:00&lt;00:00, 1976.40it/s]</pre> <pre>\rSIR Model   3/115:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 790/1460 [00:00&lt;00:00, 1975.72it/s]</pre> <pre>\rSIR Model   3/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 990/1460 [00:00&lt;00:00, 1981.49it/s]</pre> <pre>\rSIR Model   3/115:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1189/1460 [00:00&lt;00:00, 1643.10it/s]</pre> <pre>\rSIR Model   3/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1362/1460 [00:00&lt;00:00, 1553.69it/s]</pre> <pre>\rSIR Model   3/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1740.24it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   4/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   4/115:  16%|\u2588\u258c        | 230/1460 [00:00&lt;00:00, 2296.14it/s]</pre> <pre>\rSIR Model   4/115:  32%|\u2588\u2588\u2588\u258f      | 460/1460 [00:00&lt;00:00, 2296.18it/s]</pre> <pre>\rSIR Model   4/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 690/1460 [00:00&lt;00:00, 2297.07it/s]</pre> <pre>\rSIR Model   4/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 921/1460 [00:00&lt;00:00, 2299.80it/s]</pre> <pre>\rSIR Model   4/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1151/1460 [00:00&lt;00:00, 2295.35it/s]</pre> <pre>\rSIR Model   4/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1382/1460 [00:00&lt;00:00, 2297.62it/s]</pre> <pre>\rSIR Model   4/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2292.44it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   5/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   5/115:  23%|\u2588\u2588\u258e       | 334/1460 [00:00&lt;00:00, 3337.15it/s]</pre> <pre>\rSIR Model   5/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 668/1460 [00:00&lt;00:00, 3306.29it/s]</pre> <pre>\rSIR Model   5/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 999/1460 [00:00&lt;00:00, 3305.73it/s]</pre> <pre>\rSIR Model   5/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1330/1460 [00:00&lt;00:00, 3279.32it/s]</pre> <pre>\rSIR Model   5/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3283.75it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   6/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   6/115:  10%|\u2588         | 153/1460 [00:00&lt;00:00, 1525.54it/s]</pre> <pre>\rSIR Model   6/115:  21%|\u2588\u2588        | 309/1460 [00:00&lt;00:00, 1545.49it/s]</pre> <pre>\rSIR Model   6/115:  32%|\u2588\u2588\u2588\u258f      | 465/1460 [00:00&lt;00:00, 1551.80it/s]</pre> <pre>\rSIR Model   6/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 622/1460 [00:00&lt;00:00, 1555.67it/s]</pre> <pre>\rSIR Model   6/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 778/1460 [00:00&lt;00:00, 1555.23it/s]</pre> <pre>\rSIR Model   6/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 934/1460 [00:00&lt;00:00, 1555.42it/s]</pre> <pre>\rSIR Model   6/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1090/1460 [00:00&lt;00:00, 1556.13it/s]</pre> <pre>\rSIR Model   6/115:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1247/1460 [00:00&lt;00:00, 1558.03it/s]</pre> <pre>\rSIR Model   6/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1404/1460 [00:00&lt;00:00, 1558.89it/s]</pre> <pre>\rSIR Model   6/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1553.23it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   7/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   7/115:  12%|\u2588\u258f        | 181/1460 [00:00&lt;00:00, 1807.00it/s]</pre> <pre>\rSIR Model   7/115:  25%|\u2588\u2588\u258d       | 362/1460 [00:00&lt;00:00, 1795.99it/s]</pre> <pre>\rSIR Model   7/115:  37%|\u2588\u2588\u2588\u258b      | 542/1460 [00:00&lt;00:00, 1794.57it/s]</pre> <pre>\rSIR Model   7/115:  49%|\u2588\u2588\u2588\u2588\u2589     | 722/1460 [00:00&lt;00:00, 1789.19it/s]</pre> <pre>\rSIR Model   7/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 901/1460 [00:00&lt;00:00, 1789.24it/s]</pre> <pre>\rSIR Model   7/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1081/1460 [00:00&lt;00:00, 1792.00it/s]</pre> <pre>\rSIR Model   7/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1261/1460 [00:00&lt;00:00, 1792.22it/s]</pre> <pre>\rSIR Model   7/115:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1441/1460 [00:00&lt;00:00, 1789.28it/s]</pre> <pre>\rSIR Model   7/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1787.77it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   8/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   8/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2002.70it/s]</pre> <pre>\rSIR Model   8/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 1996.22it/s]</pre> <pre>\rSIR Model   8/115:  41%|\u2588\u2588\u2588\u2588      | 602/1460 [00:00&lt;00:00, 1992.99it/s]</pre> <pre>\rSIR Model   8/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 802/1460 [00:00&lt;00:00, 1983.87it/s]</pre> <pre>\rSIR Model   8/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 1002/1460 [00:00&lt;00:00, 1986.39it/s]</pre> <pre>\rSIR Model   8/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1202/1460 [00:00&lt;00:00, 1990.54it/s]</pre> <pre>\rSIR Model   8/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1402/1460 [00:00&lt;00:00, 1990.90it/s]</pre> <pre>\rSIR Model   8/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1987.09it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   9/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   9/115:  16%|\u2588\u258c        | 232/1460 [00:00&lt;00:00, 2318.80it/s]</pre> <pre>\rSIR Model   9/115:  32%|\u2588\u2588\u2588\u258f      | 464/1460 [00:00&lt;00:00, 2298.06it/s]</pre> <pre>\rSIR Model   9/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 694/1460 [00:00&lt;00:00, 2297.64it/s]</pre> <pre>\rSIR Model   9/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 924/1460 [00:00&lt;00:00, 2259.56it/s]</pre> <pre>\rSIR Model   9/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1154/1460 [00:00&lt;00:00, 2272.79it/s]</pre> <pre>\rSIR Model   9/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1385/1460 [00:00&lt;00:00, 2284.76it/s]</pre> <pre>\rSIR Model   9/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2279.38it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  10/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  10/115:  23%|\u2588\u2588\u258e       | 336/1460 [00:00&lt;00:00, 3354.82it/s]</pre> <pre>\rSIR Model  10/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 672/1460 [00:00&lt;00:00, 3345.80it/s]</pre> <pre>\rSIR Model  10/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1007/1460 [00:00&lt;00:00, 3337.71it/s]</pre> <pre>\rSIR Model  10/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1342/1460 [00:00&lt;00:00, 3339.35it/s]</pre> <pre>\rSIR Model  10/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3330.41it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  11/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  11/115:  11%|\u2588         | 157/1460 [00:00&lt;00:00, 1569.81it/s]</pre> <pre>\rSIR Model  11/115:  22%|\u2588\u2588\u258f       | 314/1460 [00:00&lt;00:00, 1560.50it/s]</pre> <pre>\rSIR Model  11/115:  32%|\u2588\u2588\u2588\u258f      | 471/1460 [00:00&lt;00:00, 1558.13it/s]</pre> <pre>\rSIR Model  11/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 628/1460 [00:00&lt;00:00, 1559.35it/s]</pre> <pre>\rSIR Model  11/115:  54%|\u2588\u2588\u2588\u2588\u2588\u258e    | 784/1460 [00:00&lt;00:00, 1557.88it/s]</pre> <pre>\rSIR Model  11/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 941/1460 [00:00&lt;00:00, 1559.32it/s]</pre> <pre>\rSIR Model  11/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 1097/1460 [00:00&lt;00:00, 1558.09it/s]</pre> <pre>\rSIR Model  11/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1254/1460 [00:00&lt;00:00, 1558.98it/s]</pre> <pre>\rSIR Model  11/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1410/1460 [00:00&lt;00:00, 1555.10it/s]</pre> <pre>\rSIR Model  11/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1555.68it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  12/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  12/115:  12%|\u2588\u258f        | 180/1460 [00:00&lt;00:00, 1798.02it/s]</pre> <pre>\rSIR Model  12/115:  25%|\u2588\u2588\u258d       | 360/1460 [00:00&lt;00:00, 1787.75it/s]</pre> <pre>\rSIR Model  12/115:  37%|\u2588\u2588\u2588\u258b      | 539/1460 [00:00&lt;00:00, 1788.53it/s]</pre> <pre>\rSIR Model  12/115:  49%|\u2588\u2588\u2588\u2588\u2589     | 718/1460 [00:00&lt;00:00, 1788.42it/s]</pre> <pre>\rSIR Model  12/115:  61%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 897/1460 [00:00&lt;00:00, 1787.26it/s]</pre> <pre>\rSIR Model  12/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1076/1460 [00:00&lt;00:00, 1769.67it/s]</pre> <pre>\rSIR Model  12/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1253/1460 [00:00&lt;00:00, 1748.71it/s]</pre> <pre>\rSIR Model  12/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1431/1460 [00:00&lt;00:00, 1756.46it/s]</pre> <pre>\rSIR Model  12/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1765.96it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  13/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  13/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2001.41it/s]</pre> <pre>\rSIR Model  13/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 1987.59it/s]</pre> <pre>\rSIR Model  13/115:  41%|\u2588\u2588\u2588\u2588      | 602/1460 [00:00&lt;00:00, 1988.90it/s]</pre> <pre>\rSIR Model  13/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 802/1460 [00:00&lt;00:00, 1989.80it/s]</pre> <pre>\rSIR Model  13/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 1002/1460 [00:00&lt;00:00, 1990.12it/s]</pre> <pre>\rSIR Model  13/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1202/1460 [00:00&lt;00:00, 1991.55it/s]</pre> <pre>\rSIR Model  13/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1402/1460 [00:00&lt;00:00, 1987.01it/s]</pre> <pre>\rSIR Model  13/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1984.95it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  14/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  14/115:  15%|\u2588\u258c        | 226/1460 [00:00&lt;00:00, 2252.11it/s]</pre> <pre>\rSIR Model  14/115:  31%|\u2588\u2588\u2588       | 453/1460 [00:00&lt;00:00, 2257.41it/s]</pre> <pre>\rSIR Model  14/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 681/1460 [00:00&lt;00:00, 2265.54it/s]</pre> <pre>\rSIR Model  14/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 910/1460 [00:00&lt;00:00, 2271.61it/s]</pre> <pre>\rSIR Model  14/115:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 1139/1460 [00:00&lt;00:00, 2275.35it/s]</pre> <pre>\rSIR Model  14/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1369/1460 [00:00&lt;00:00, 2281.46it/s]</pre> <pre>\rSIR Model  14/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2271.00it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  15/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  15/115:  22%|\u2588\u2588\u258f       | 327/1460 [00:00&lt;00:00, 3263.50it/s]</pre> <pre>\rSIR Model  15/115:  45%|\u2588\u2588\u2588\u2588\u258c     | 660/1460 [00:00&lt;00:00, 3299.97it/s]</pre> <pre>\rSIR Model  15/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 993/1460 [00:00&lt;00:00, 3310.62it/s]</pre> <pre>\rSIR Model  15/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1326/1460 [00:00&lt;00:00, 3315.41it/s]</pre> <pre>\rSIR Model  15/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3300.66it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  16/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  16/115:  11%|\u2588         | 158/1460 [00:00&lt;00:00, 1574.74it/s]</pre> <pre>\rSIR Model  16/115:  22%|\u2588\u2588\u258f       | 316/1460 [00:00&lt;00:00, 1565.10it/s]</pre> <pre>\rSIR Model  16/115:  32%|\u2588\u2588\u2588\u258f      | 473/1460 [00:00&lt;00:00, 1541.89it/s]</pre> <pre>\rSIR Model  16/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 630/1460 [00:00&lt;00:00, 1549.44it/s]</pre> <pre>\rSIR Model  16/115:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 787/1460 [00:00&lt;00:00, 1554.98it/s]</pre> <pre>\rSIR Model  16/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 944/1460 [00:00&lt;00:00, 1558.29it/s]</pre> <pre>\rSIR Model  16/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 1100/1460 [00:00&lt;00:00, 1557.75it/s]</pre> <pre>\rSIR Model  16/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1256/1460 [00:00&lt;00:00, 1557.99it/s]</pre> <pre>\rSIR Model  16/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1413/1460 [00:00&lt;00:00, 1559.59it/s]</pre> <pre>\rSIR Model  16/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1555.38it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  17/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  17/115:  12%|\u2588\u258f        | 169/1460 [00:00&lt;00:00, 1689.93it/s]</pre> <pre>\rSIR Model  17/115:  23%|\u2588\u2588\u258e       | 339/1460 [00:00&lt;00:00, 1692.23it/s]</pre> <pre>\rSIR Model  17/115:  35%|\u2588\u2588\u2588\u258d      | 510/1460 [00:00&lt;00:00, 1698.57it/s]</pre> <pre>\rSIR Model  17/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 680/1460 [00:00&lt;00:00, 1696.23it/s]</pre> <pre>\rSIR Model  17/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 850/1460 [00:00&lt;00:00, 1692.26it/s]</pre> <pre>\rSIR Model  17/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1020/1460 [00:00&lt;00:00, 1693.40it/s]</pre> <pre>\rSIR Model  17/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1190/1460 [00:00&lt;00:00, 1666.09it/s]</pre> <pre>\rSIR Model  17/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1360/1460 [00:00&lt;00:00, 1675.91it/s]</pre> <pre>\rSIR Model  17/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1679.56it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  18/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  18/115:  13%|\u2588\u258e        | 189/1460 [00:00&lt;00:00, 1889.83it/s]</pre> <pre>\rSIR Model  18/115:  26%|\u2588\u2588\u258c       | 378/1460 [00:00&lt;00:00, 1888.06it/s]</pre> <pre>\rSIR Model  18/115:  39%|\u2588\u2588\u2588\u2589      | 567/1460 [00:00&lt;00:00, 1887.61it/s]</pre> <pre>\rSIR Model  18/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 756/1460 [00:00&lt;00:00, 1885.74it/s]</pre> <pre>\rSIR Model  18/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 945/1460 [00:00&lt;00:00, 1883.04it/s]</pre> <pre>\rSIR Model  18/115:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 1134/1460 [00:00&lt;00:00, 1882.75it/s]</pre> <pre>\rSIR Model  18/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1324/1460 [00:00&lt;00:00, 1885.41it/s]</pre> <pre>\rSIR Model  18/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1880.07it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  19/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  19/115:  15%|\u2588\u258d        | 217/1460 [00:00&lt;00:00, 2166.37it/s]</pre> <pre>\rSIR Model  19/115:  30%|\u2588\u2588\u2589       | 435/1460 [00:00&lt;00:00, 2173.01it/s]</pre> <pre>\rSIR Model  19/115:  45%|\u2588\u2588\u2588\u2588\u258d     | 653/1460 [00:00&lt;00:00, 2175.01it/s]</pre> <pre>\rSIR Model  19/115:  60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 871/1460 [00:00&lt;00:00, 2175.47it/s]</pre> <pre>\rSIR Model  19/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1089/1460 [00:00&lt;00:00, 2173.60it/s]</pre> <pre>\rSIR Model  19/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1307/1460 [00:00&lt;00:00, 2172.05it/s]</pre> <pre>\rSIR Model  19/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2165.87it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  20/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  20/115:  20%|\u2588\u2589        | 285/1460 [00:00&lt;00:00, 2847.10it/s]</pre> <pre>\rSIR Model  20/115:  41%|\u2588\u2588\u2588\u2588      | 595/1460 [00:00&lt;00:00, 2995.22it/s]</pre> <pre>\rSIR Model  20/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 909/1460 [00:00&lt;00:00, 3057.66it/s]</pre> <pre>\rSIR Model  20/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1223/1460 [00:00&lt;00:00, 3087.19it/s]</pre> <pre>\rSIR Model  20/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3054.11it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  21/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  21/115:  10%|\u2588         | 150/1460 [00:00&lt;00:00, 1494.95it/s]</pre> <pre>\rSIR Model  21/115:  21%|\u2588\u2588        | 300/1460 [00:00&lt;00:00, 1484.08it/s]</pre> <pre>\rSIR Model  21/115:  31%|\u2588\u2588\u2588       | 449/1460 [00:00&lt;00:00, 1484.15it/s]</pre> <pre>\rSIR Model  21/115:  41%|\u2588\u2588\u2588\u2588      | 598/1460 [00:00&lt;00:00, 1479.33it/s]</pre> <pre>\rSIR Model  21/115:  51%|\u2588\u2588\u2588\u2588\u2588     | 747/1460 [00:00&lt;00:00, 1479.70it/s]</pre> <pre>\rSIR Model  21/115:  61%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 896/1460 [00:00&lt;00:00, 1481.93it/s]</pre> <pre>\rSIR Model  21/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1045/1460 [00:00&lt;00:00, 1484.28it/s]</pre> <pre>\rSIR Model  21/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1194/1460 [00:00&lt;00:00, 1482.92it/s]</pre> <pre>\rSIR Model  21/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1343/1460 [00:00&lt;00:00, 1482.03it/s]</pre> <pre>\rSIR Model  21/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1479.28it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  22/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  22/115:  11%|\u2588\u258f        | 165/1460 [00:00&lt;00:00, 1622.59it/s]</pre> <pre>\rSIR Model  22/115:  22%|\u2588\u2588\u258f       | 328/1460 [00:00&lt;00:00, 1624.80it/s]</pre> <pre>\rSIR Model  22/115:  34%|\u2588\u2588\u2588\u258d      | 498/1460 [00:00&lt;00:00, 1656.66it/s]</pre> <pre>\rSIR Model  22/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 669/1460 [00:00&lt;00:00, 1675.40it/s]</pre> <pre>\rSIR Model  22/115:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 839/1460 [00:00&lt;00:00, 1683.30it/s]</pre> <pre>\rSIR Model  22/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1009/1460 [00:00&lt;00:00, 1686.25it/s]</pre> <pre>\rSIR Model  22/115:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 1179/1460 [00:00&lt;00:00, 1689.64it/s]</pre> <pre>\rSIR Model  22/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1349/1460 [00:00&lt;00:00, 1690.35it/s]</pre> <pre>\rSIR Model  22/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1684.83it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  23/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  23/115:  13%|\u2588\u258e        | 189/1460 [00:00&lt;00:00, 1887.58it/s]</pre> <pre>\rSIR Model  23/115:  26%|\u2588\u2588\u258c       | 378/1460 [00:00&lt;00:00, 1885.42it/s]</pre> <pre>\rSIR Model  23/115:  39%|\u2588\u2588\u2588\u2589      | 567/1460 [00:00&lt;00:00, 1844.94it/s]</pre> <pre>\rSIR Model  23/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 756/1460 [00:00&lt;00:00, 1862.06it/s]</pre> <pre>\rSIR Model  23/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 944/1460 [00:00&lt;00:00, 1867.93it/s]</pre> <pre>\rSIR Model  23/115:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 1133/1460 [00:00&lt;00:00, 1874.20it/s]</pre> <pre>\rSIR Model  23/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1322/1460 [00:00&lt;00:00, 1877.11it/s]</pre> <pre>\rSIR Model  23/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1868.81it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  24/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  24/115:  15%|\u2588\u258d        | 217/1460 [00:00&lt;00:00, 2164.56it/s]</pre> <pre>\rSIR Model  24/115:  30%|\u2588\u2588\u2589       | 435/1460 [00:00&lt;00:00, 2171.27it/s]</pre> <pre>\rSIR Model  24/115:  45%|\u2588\u2588\u2588\u2588\u258d     | 655/1460 [00:00&lt;00:00, 2180.44it/s]</pre> <pre>\rSIR Model  24/115:  60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 874/1460 [00:00&lt;00:00, 2152.04it/s]</pre> <pre>\rSIR Model  24/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1091/1460 [00:00&lt;00:00, 2157.86it/s]</pre> <pre>\rSIR Model  24/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1308/1460 [00:00&lt;00:00, 2160.77it/s]</pre> <pre>\rSIR Model  24/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2156.26it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  25/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  25/115:  22%|\u2588\u2588\u258f       | 316/1460 [00:00&lt;00:00, 3156.68it/s]</pre> <pre>\rSIR Model  25/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 632/1460 [00:00&lt;00:00, 3118.62it/s]</pre> <pre>\rSIR Model  25/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 944/1460 [00:00&lt;00:00, 3117.87it/s]</pre> <pre>\rSIR Model  25/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1256/1460 [00:00&lt;00:00, 3116.06it/s]</pre> <pre>\rSIR Model  25/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3101.67it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  26/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  26/115:  10%|\u2588         | 150/1460 [00:00&lt;00:00, 1491.18it/s]</pre> <pre>\rSIR Model  26/115:  21%|\u2588\u2588\u258f       | 312/1460 [00:00&lt;00:00, 1565.81it/s]</pre> <pre>\rSIR Model  26/115:  35%|\u2588\u2588\u2588\u258c      | 512/1460 [00:00&lt;00:00, 1761.09it/s]</pre> <pre>\rSIR Model  26/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 730/1460 [00:00&lt;00:00, 1925.53it/s]</pre> <pre>\rSIR Model  26/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 945/1460 [00:00&lt;00:00, 2004.10it/s]</pre> <pre>\rSIR Model  26/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1157/1460 [00:00&lt;00:00, 2040.28it/s]</pre> <pre>\rSIR Model  26/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1373/1460 [00:00&lt;00:00, 2077.06it/s]</pre> <pre>\rSIR Model  26/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1953.25it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  27/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  27/115:  12%|\u2588\u258f        | 174/1460 [00:00&lt;00:00, 1737.54it/s]</pre> <pre>\rSIR Model  27/115:  24%|\u2588\u2588\u258d       | 354/1460 [00:00&lt;00:00, 1769.49it/s]</pre> <pre>\rSIR Model  27/115:  37%|\u2588\u2588\u2588\u258b      | 534/1460 [00:00&lt;00:00, 1780.54it/s]</pre> <pre>\rSIR Model  27/115:  49%|\u2588\u2588\u2588\u2588\u2589     | 721/1460 [00:00&lt;00:00, 1814.98it/s]</pre> <pre>\rSIR Model  27/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 917/1460 [00:00&lt;00:00, 1865.12it/s]</pre> <pre>\rSIR Model  27/115:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 1117/1460 [00:00&lt;00:00, 1910.66it/s]</pre> <pre>\rSIR Model  27/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1320/1460 [00:00&lt;00:00, 1947.21it/s]</pre> <pre>\rSIR Model  27/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1892.43it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  28/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  28/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2006.83it/s]</pre> <pre>\rSIR Model  28/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 1495.51it/s]</pre> <pre>\rSIR Model  28/115:  41%|\u2588\u2588\u2588\u2588      | 601/1460 [00:00&lt;00:00, 1683.19it/s]</pre> <pre>\rSIR Model  28/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 801/1460 [00:00&lt;00:00, 1793.87it/s]</pre> <pre>\rSIR Model  28/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 987/1460 [00:00&lt;00:00, 1810.81it/s]</pre> <pre>\rSIR Model  28/115:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 1173/1460 [00:00&lt;00:00, 1826.12it/s]</pre> <pre>\rSIR Model  28/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1362/1460 [00:00&lt;00:00, 1845.72it/s]</pre> <pre>\rSIR Model  28/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1789.88it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  29/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  29/115:  16%|\u2588\u258c        | 231/1460 [00:00&lt;00:00, 2307.30it/s]</pre> <pre>\rSIR Model  29/115:  32%|\u2588\u2588\u2588\u258f      | 462/1460 [00:00&lt;00:00, 2298.62it/s]</pre> <pre>\rSIR Model  29/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 692/1460 [00:00&lt;00:00, 2295.76it/s]</pre> <pre>\rSIR Model  29/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 922/1460 [00:00&lt;00:00, 2297.14it/s]</pre> <pre>\rSIR Model  29/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1152/1460 [00:00&lt;00:00, 2295.71it/s]</pre> <pre>\rSIR Model  29/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1382/1460 [00:00&lt;00:00, 2252.99it/s]</pre> <pre>\rSIR Model  29/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2271.10it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  30/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  30/115:  23%|\u2588\u2588\u258e       | 331/1460 [00:00&lt;00:00, 3303.48it/s]</pre> <pre>\rSIR Model  30/115:  45%|\u2588\u2588\u2588\u2588\u258c     | 662/1460 [00:00&lt;00:00, 3298.78it/s]</pre> <pre>\rSIR Model  30/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 992/1460 [00:00&lt;00:00, 3297.49it/s]</pre> <pre>\rSIR Model  30/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1323/1460 [00:00&lt;00:00, 3302.20it/s]</pre> <pre>\rSIR Model  30/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3290.50it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  31/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  31/115:  11%|\u2588         | 162/1460 [00:00&lt;00:00, 1614.35it/s]</pre> <pre>\rSIR Model  31/115:  31%|\u2588\u2588\u2588       | 448/1460 [00:00&lt;00:00, 2342.97it/s]</pre> <pre>\rSIR Model  31/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 777/1460 [00:00&lt;00:00, 2771.20it/s]</pre> <pre>\rSIR Model  31/115:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 1106/1460 [00:00&lt;00:00, 2973.89it/s]</pre> <pre>\rSIR Model  31/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1431/1460 [00:00&lt;00:00, 3070.31it/s]</pre> <pre>\rSIR Model  31/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2852.12it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  32/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  32/115:  12%|\u2588\u258f        | 182/1460 [00:00&lt;00:00, 1815.91it/s]</pre> <pre>\rSIR Model  32/115:  28%|\u2588\u2588\u258a       | 405/1460 [00:00&lt;00:00, 2057.65it/s]</pre> <pre>\rSIR Model  32/115:  46%|\u2588\u2588\u2588\u2588\u258b     | 677/1460 [00:00&lt;00:00, 2358.72it/s]</pre> <pre>\rSIR Model  32/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 952/1460 [00:00&lt;00:00, 2510.66it/s]</pre> <pre>\rSIR Model  32/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1227/1460 [00:00&lt;00:00, 2596.20it/s]</pre> <pre>\rSIR Model  32/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2491.29it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  33/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  33/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2001.96it/s]</pre> <pre>\rSIR Model  33/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 1999.49it/s]</pre> <pre>\rSIR Model  33/115:  42%|\u2588\u2588\u2588\u2588\u258f     | 606/1460 [00:00&lt;00:00, 2017.48it/s]</pre> <pre>\rSIR Model  33/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258b    | 822/1460 [00:00&lt;00:00, 2070.87it/s]</pre> <pre>\rSIR Model  33/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1041/1460 [00:00&lt;00:00, 2112.48it/s]</pre> <pre>\rSIR Model  33/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1264/1460 [00:00&lt;00:00, 2152.01it/s]</pre> <pre>\rSIR Model  33/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2116.90it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  34/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  34/115:  16%|\u2588\u258c        | 232/1460 [00:00&lt;00:00, 2316.58it/s]</pre> <pre>\rSIR Model  34/115:  32%|\u2588\u2588\u2588\u258f      | 464/1460 [00:00&lt;00:00, 2301.33it/s]</pre> <pre>\rSIR Model  34/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 695/1460 [00:00&lt;00:00, 2304.19it/s]</pre> <pre>\rSIR Model  34/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 926/1460 [00:00&lt;00:00, 2303.07it/s]</pre> <pre>\rSIR Model  34/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1157/1460 [00:00&lt;00:00, 2304.66it/s]</pre> <pre>\rSIR Model  34/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1388/1460 [00:00&lt;00:00, 2298.10it/s]</pre> <pre>\rSIR Model  34/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2296.66it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  35/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  35/115:  22%|\u2588\u2588\u258f       | 323/1460 [00:00&lt;00:00, 3229.82it/s]</pre> <pre>\rSIR Model  35/115:  44%|\u2588\u2588\u2588\u2588\u258d     | 646/1460 [00:00&lt;00:00, 3212.63it/s]</pre> <pre>\rSIR Model  35/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 978/1460 [00:00&lt;00:00, 3259.78it/s]</pre> <pre>\rSIR Model  35/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1309/1460 [00:00&lt;00:00, 3279.34it/s]</pre> <pre>\rSIR Model  35/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3261.30it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  36/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  36/115:  13%|\u2588\u258e        | 186/1460 [00:00&lt;00:00, 1855.41it/s]</pre> <pre>\rSIR Model  36/115:  41%|\u2588\u2588\u2588\u2588      | 595/1460 [00:00&lt;00:00, 3164.46it/s]</pre> <pre>\rSIR Model  36/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1023/1460 [00:00&lt;00:00, 3670.54it/s]</pre> <pre>\rSIR Model  36/115:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1448/1460 [00:00&lt;00:00, 3895.46it/s]</pre> <pre>\rSIR Model  36/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3601.56it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  37/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  37/115:  13%|\u2588\u258e        | 187/1460 [00:00&lt;00:00, 1866.77it/s]</pre> <pre>\rSIR Model  37/115:  37%|\u2588\u2588\u2588\u258b      | 534/1460 [00:00&lt;00:00, 2806.53it/s]</pre> <pre>\rSIR Model  37/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 902/1460 [00:00&lt;00:00, 3203.79it/s]</pre> <pre>\rSIR Model  37/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1269/1460 [00:00&lt;00:00, 3387.44it/s]</pre> <pre>\rSIR Model  37/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3219.15it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  38/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  38/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2008.74it/s]</pre> <pre>\rSIR Model  38/115:  30%|\u2588\u2588\u2588       | 440/1460 [00:00&lt;00:00, 2229.59it/s]</pre> <pre>\rSIR Model  38/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 731/1460 [00:00&lt;00:00, 2539.85it/s]</pre> <pre>\rSIR Model  38/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1025/1460 [00:00&lt;00:00, 2694.60it/s]</pre> <pre>\rSIR Model  38/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1320/1460 [00:00&lt;00:00, 2785.24it/s]</pre> <pre>\rSIR Model  38/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2656.52it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  39/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  39/115:  16%|\u2588\u258c        | 231/1460 [00:00&lt;00:00, 2304.93it/s]</pre> <pre>\rSIR Model  39/115:  32%|\u2588\u2588\u2588\u258f      | 462/1460 [00:00&lt;00:00, 2306.43it/s]</pre> <pre>\rSIR Model  39/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 693/1460 [00:00&lt;00:00, 2307.60it/s]</pre> <pre>\rSIR Model  39/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 925/1460 [00:00&lt;00:00, 2309.20it/s]</pre> <pre>\rSIR Model  39/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1156/1460 [00:00&lt;00:00, 2307.36it/s]</pre> <pre>\rSIR Model  39/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1388/1460 [00:00&lt;00:00, 2309.58it/s]</pre> <pre>\rSIR Model  39/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2302.82it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  40/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  40/115:  23%|\u2588\u2588\u258e       | 333/1460 [00:00&lt;00:00, 3321.09it/s]</pre> <pre>\rSIR Model  40/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 666/1460 [00:00&lt;00:00, 3305.44it/s]</pre> <pre>\rSIR Model  40/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 997/1460 [00:00&lt;00:00, 3288.41it/s]</pre> <pre>\rSIR Model  40/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1328/1460 [00:00&lt;00:00, 3295.08it/s]</pre> <pre>\rSIR Model  40/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3288.25it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  41/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  41/115:  17%|\u2588\u258b        | 250/1460 [00:00&lt;00:00, 2495.94it/s]</pre> <pre>\rSIR Model  41/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 734/1460 [00:00&lt;00:00, 3871.05it/s]</pre> <pre>\rSIR Model  41/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1222/1460 [00:00&lt;00:00, 4327.24it/s]</pre> <pre>\rSIR Model  41/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4164.09it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  42/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  42/115:  15%|\u2588\u258c        | 221/1460 [00:00&lt;00:00, 2209.28it/s]</pre> <pre>\rSIR Model  42/115:  45%|\u2588\u2588\u2588\u2588\u258c     | 658/1460 [00:00&lt;00:00, 3477.53it/s]</pre> <pre>\rSIR Model  42/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 1098/1460 [00:00&lt;00:00, 3896.72it/s]</pre> <pre>\rSIR Model  42/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3808.35it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  43/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  43/115:  14%|\u2588\u258d        | 208/1460 [00:00&lt;00:00, 2075.05it/s]</pre> <pre>\rSIR Model  43/115:  38%|\u2588\u2588\u2588\u258a      | 553/1460 [00:00&lt;00:00, 2880.46it/s]</pre> <pre>\rSIR Model  43/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 918/1460 [00:00&lt;00:00, 3227.55it/s]</pre> <pre>\rSIR Model  43/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1273/1460 [00:00&lt;00:00, 3352.18it/s]</pre> <pre>\rSIR Model  43/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3218.59it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  44/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  44/115:  16%|\u2588\u258c        | 232/1460 [00:00&lt;00:00, 2311.67it/s]</pre> <pre>\rSIR Model  44/115:  32%|\u2588\u2588\u2588\u258f      | 472/1460 [00:00&lt;00:00, 2362.82it/s]</pre> <pre>\rSIR Model  44/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 732/1460 [00:00&lt;00:00, 2467.70it/s]</pre> <pre>\rSIR Model  44/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1005/1460 [00:00&lt;00:00, 2568.53it/s]</pre> <pre>\rSIR Model  44/115:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 1279/1460 [00:00&lt;00:00, 2629.82it/s]</pre> <pre>\rSIR Model  44/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2573.26it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  45/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  45/115:  23%|\u2588\u2588\u258e       | 333/1460 [00:00&lt;00:00, 3329.59it/s]</pre> <pre>\rSIR Model  45/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 666/1460 [00:00&lt;00:00, 3308.69it/s]</pre> <pre>\rSIR Model  45/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 998/1460 [00:00&lt;00:00, 3309.51it/s]</pre> <pre>\rSIR Model  45/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1329/1460 [00:00&lt;00:00, 3303.70it/s]</pre> <pre>\rSIR Model  45/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3298.51it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  46/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  46/115:  21%|\u2588\u2588        | 301/1460 [00:00&lt;00:00, 3009.36it/s]</pre> <pre>\rSIR Model  46/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 821/1460 [00:00&lt;00:00, 4294.19it/s]</pre> <pre>\rSIR Model  46/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1341/1460 [00:00&lt;00:00, 4704.06it/s]</pre> <pre>\rSIR Model  46/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4494.95it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  47/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  47/115:  19%|\u2588\u2589        | 282/1460 [00:00&lt;00:00, 2815.87it/s]</pre> <pre>\rSIR Model  47/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 764/1460 [00:00&lt;00:00, 3991.76it/s]</pre> <pre>\rSIR Model  47/115:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1247/1460 [00:00&lt;00:00, 4372.28it/s]</pre> <pre>\rSIR Model  47/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4225.06it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  48/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  48/115:  17%|\u2588\u258b        | 248/1460 [00:00&lt;00:00, 2477.43it/s]</pre> <pre>\rSIR Model  48/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 665/1460 [00:00&lt;00:00, 3471.89it/s]</pre> <pre>\rSIR Model  48/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1087/1460 [00:00&lt;00:00, 3810.44it/s]</pre> <pre>\rSIR Model  48/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3753.58it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  49/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  49/115:  16%|\u2588\u258c        | 233/1460 [00:00&lt;00:00, 2322.12it/s]</pre> <pre>\rSIR Model  49/115:  36%|\u2588\u2588\u2588\u258c      | 523/1460 [00:00&lt;00:00, 2660.26it/s]</pre> <pre>\rSIR Model  49/115:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 860/1460 [00:00&lt;00:00, 2980.86it/s]</pre> <pre>\rSIR Model  49/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1199/1460 [00:00&lt;00:00, 3139.57it/s]</pre> <pre>\rSIR Model  49/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3048.45it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  50/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  50/115:  22%|\u2588\u2588\u258f       | 324/1460 [00:00&lt;00:00, 3232.74it/s]</pre> <pre>\rSIR Model  50/115:  44%|\u2588\u2588\u2588\u2588\u258d     | 648/1460 [00:00&lt;00:00, 3129.70it/s]</pre> <pre>\rSIR Model  50/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 979/1460 [00:00&lt;00:00, 3208.31it/s]</pre> <pre>\rSIR Model  50/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1307/1460 [00:00&lt;00:00, 3214.33it/s]</pre> <pre>\rSIR Model  50/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3205.54it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  51/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  51/115:  23%|\u2588\u2588\u258e       | 343/1460 [00:00&lt;00:00, 3426.75it/s]</pre> <pre>\rSIR Model  51/115:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 879/1460 [00:00&lt;00:00, 4562.25it/s]</pre> <pre>\rSIR Model  51/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1420/1460 [00:00&lt;00:00, 4947.82it/s]</pre> <pre>\rSIR Model  51/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4721.67it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  52/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  52/115:  22%|\u2588\u2588\u258f       | 323/1460 [00:00&lt;00:00, 3224.71it/s]</pre> <pre>\rSIR Model  52/115:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 836/1460 [00:00&lt;00:00, 4344.41it/s]</pre> <pre>\rSIR Model  52/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1351/1460 [00:00&lt;00:00, 4711.78it/s]</pre> <pre>\rSIR Model  52/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4521.92it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  53/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  53/115:  19%|\u2588\u258a        | 272/1460 [00:00&lt;00:00, 2715.35it/s]</pre> <pre>\rSIR Model  53/115:  51%|\u2588\u2588\u2588\u2588\u2588     | 738/1460 [00:00&lt;00:00, 3853.91it/s]</pre> <pre>\rSIR Model  53/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1207/1460 [00:00&lt;00:00, 4233.61it/s]</pre> <pre>\rSIR Model  53/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4103.62it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  54/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  54/115:  16%|\u2588\u258c        | 231/1460 [00:00&lt;00:00, 2302.72it/s]</pre> <pre>\rSIR Model  54/115:  40%|\u2588\u2588\u2588\u2588      | 587/1460 [00:00&lt;00:00, 3040.37it/s]</pre> <pre>\rSIR Model  54/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 969/1460 [00:00&lt;00:00, 3394.20it/s]</pre> <pre>\rSIR Model  54/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1352/1460 [00:00&lt;00:00, 3565.04it/s]</pre> <pre>\rSIR Model  54/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3392.62it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  55/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  55/115:  23%|\u2588\u2588\u258e       | 333/1460 [00:00&lt;00:00, 3326.45it/s]</pre> <pre>\rSIR Model  55/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 666/1460 [00:00&lt;00:00, 3312.90it/s]</pre> <pre>\rSIR Model  55/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 998/1460 [00:00&lt;00:00, 3314.71it/s]</pre> <pre>\rSIR Model  55/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1330/1460 [00:00&lt;00:00, 3306.41it/s]</pre> <pre>\rSIR Model  55/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3300.99it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  56/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  56/115:  25%|\u2588\u2588\u258c       | 370/1460 [00:00&lt;00:00, 3695.99it/s]</pre> <pre>\rSIR Model  56/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 921/1460 [00:00&lt;00:00, 4759.48it/s]</pre> <pre>\rSIR Model  56/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4888.64it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  57/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  57/115:  25%|\u2588\u2588\u258c       | 365/1460 [00:00&lt;00:00, 3642.99it/s]</pre> <pre>\rSIR Model  57/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 898/1460 [00:00&lt;00:00, 4634.07it/s]</pre> <pre>\rSIR Model  57/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1436/1460 [00:00&lt;00:00, 4972.29it/s]</pre> <pre>\rSIR Model  57/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4763.56it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  58/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  58/115:  22%|\u2588\u2588\u258f       | 323/1460 [00:00&lt;00:00, 3229.80it/s]</pre> <pre>\rSIR Model  58/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 821/1460 [00:00&lt;00:00, 4256.47it/s]</pre> <pre>\rSIR Model  58/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1317/1460 [00:00&lt;00:00, 4575.00it/s]</pre> <pre>\rSIR Model  58/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4420.77it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  59/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  59/115:  19%|\u2588\u2589        | 276/1460 [00:00&lt;00:00, 2758.68it/s]</pre> <pre>\rSIR Model  59/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 701/1460 [00:00&lt;00:00, 3630.11it/s]</pre> <pre>\rSIR Model  59/115:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 1131/1460 [00:00&lt;00:00, 3932.79it/s]</pre> <pre>\rSIR Model  59/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3778.61it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  60/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  60/115:  22%|\u2588\u2588\u258f       | 316/1460 [00:00&lt;00:00, 3159.31it/s]</pre> <pre>\rSIR Model  60/115:  44%|\u2588\u2588\u2588\u2588\u258d     | 648/1460 [00:00&lt;00:00, 3251.98it/s]</pre> <pre>\rSIR Model  60/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 981/1460 [00:00&lt;00:00, 3286.50it/s]</pre> <pre>\rSIR Model  60/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1316/1460 [00:00&lt;00:00, 3307.88it/s]</pre> <pre>\rSIR Model  60/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3281.98it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  61/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  61/115:  27%|\u2588\u2588\u258b       | 396/1460 [00:00&lt;00:00, 3958.49it/s]</pre> <pre>\rSIR Model  61/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 955/1460 [00:00&lt;00:00, 4917.41it/s]</pre> <pre>\rSIR Model  61/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5029.43it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  62/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  62/115:  26%|\u2588\u2588\u258c       | 383/1460 [00:00&lt;00:00, 3827.19it/s]</pre> <pre>\rSIR Model  62/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 925/1460 [00:00&lt;00:00, 4762.17it/s]</pre> <pre>\rSIR Model  62/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4880.71it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  63/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  63/115:  25%|\u2588\u2588\u258d       | 361/1460 [00:00&lt;00:00, 3603.35it/s]</pre> <pre>\rSIR Model  63/115:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 878/1460 [00:00&lt;00:00, 4522.00it/s]</pre> <pre>\rSIR Model  63/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1396/1460 [00:00&lt;00:00, 4821.05it/s]</pre> <pre>\rSIR Model  63/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4644.16it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  64/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  64/115:  22%|\u2588\u2588\u258f       | 314/1460 [00:00&lt;00:00, 3139.17it/s]</pre> <pre>\rSIR Model  64/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 774/1460 [00:00&lt;00:00, 3992.46it/s]</pre> <pre>\rSIR Model  64/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1232/1460 [00:00&lt;00:00, 4258.41it/s]</pre> <pre>\rSIR Model  64/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4159.27it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  65/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  65/115:  23%|\u2588\u2588\u258e       | 335/1460 [00:00&lt;00:00, 3341.07it/s]</pre> <pre>\rSIR Model  65/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 673/1460 [00:00&lt;00:00, 3362.45it/s]</pre> <pre>\rSIR Model  65/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1010/1460 [00:00&lt;00:00, 3338.95it/s]</pre> <pre>\rSIR Model  65/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1344/1460 [00:00&lt;00:00, 3323.39it/s]</pre> <pre>\rSIR Model  65/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3328.89it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  66/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  66/115:  28%|\u2588\u2588\u258a       | 405/1460 [00:00&lt;00:00, 4049.04it/s]</pre> <pre>\rSIR Model  66/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 970/1460 [00:00&lt;00:00, 4987.24it/s]</pre> <pre>\rSIR Model  66/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5083.08it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  67/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  67/115:  28%|\u2588\u2588\u258a       | 403/1460 [00:00&lt;00:00, 4025.93it/s]</pre> <pre>\rSIR Model  67/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 956/1460 [00:00&lt;00:00, 4906.35it/s]</pre> <pre>\rSIR Model  67/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5001.07it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  68/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  68/115:  26%|\u2588\u2588\u258b       | 386/1460 [00:00&lt;00:00, 3856.22it/s]</pre> <pre>\rSIR Model  68/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 921/1460 [00:00&lt;00:00, 4730.61it/s]</pre> <pre>\rSIR Model  68/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1459/1460 [00:00&lt;00:00, 5024.56it/s]</pre> <pre>\rSIR Model  68/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4832.32it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  69/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  69/115:  23%|\u2588\u2588\u258e       | 332/1460 [00:00&lt;00:00, 3318.60it/s]</pre> <pre>\rSIR Model  69/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 812/1460 [00:00&lt;00:00, 4185.76it/s]</pre> <pre>\rSIR Model  69/115:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 1293/1460 [00:00&lt;00:00, 4470.07it/s]</pre> <pre>\rSIR Model  69/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4328.03it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  70/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  70/115:  23%|\u2588\u2588\u258e       | 336/1460 [00:00&lt;00:00, 3350.88it/s]</pre> <pre>\rSIR Model  70/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 690/1460 [00:00&lt;00:00, 3456.23it/s]</pre> <pre>\rSIR Model  70/115:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1062/1460 [00:00&lt;00:00, 3572.33it/s]</pre> <pre>\rSIR Model  70/115:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1441/1460 [00:00&lt;00:00, 3656.95it/s]</pre> <pre>\rSIR Model  70/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3581.53it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  71/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  71/115:  29%|\u2588\u2588\u2589       | 425/1460 [00:00&lt;00:00, 4243.96it/s]</pre> <pre>\rSIR Model  71/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 992/1460 [00:00&lt;00:00, 5080.10it/s]</pre> <pre>\rSIR Model  71/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5162.73it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  72/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  72/115:  29%|\u2588\u2588\u258a       | 419/1460 [00:00&lt;00:00, 4184.77it/s]</pre> <pre>\rSIR Model  72/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 978/1460 [00:00&lt;00:00, 5008.73it/s]</pre> <pre>\rSIR Model  72/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5092.85it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  73/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  73/115:  27%|\u2588\u2588\u258b       | 398/1460 [00:00&lt;00:00, 3973.60it/s]</pre> <pre>\rSIR Model  73/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 942/1460 [00:00&lt;00:00, 4834.56it/s]</pre> <pre>\rSIR Model  73/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4923.16it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  74/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  74/115:  24%|\u2588\u2588\u258e       | 344/1460 [00:00&lt;00:00, 3437.13it/s]</pre> <pre>\rSIR Model  74/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 846/1460 [00:00&lt;00:00, 4366.83it/s]</pre> <pre>\rSIR Model  74/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1349/1460 [00:00&lt;00:00, 4666.58it/s]</pre> <pre>\rSIR Model  74/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4507.40it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  75/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  75/115:  23%|\u2588\u2588\u258e       | 337/1460 [00:00&lt;00:00, 3367.54it/s]</pre> <pre>\rSIR Model  75/115:  46%|\u2588\u2588\u2588\u2588\u258b     | 677/1460 [00:00&lt;00:00, 3384.43it/s]</pre> <pre>\rSIR Model  75/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1043/1460 [00:00&lt;00:00, 3509.13it/s]</pre> <pre>\rSIR Model  75/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1433/1460 [00:00&lt;00:00, 3661.06it/s]</pre> <pre>\rSIR Model  75/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3569.83it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  76/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  76/115:  30%|\u2588\u2588\u2589       | 432/1460 [00:00&lt;00:00, 4316.48it/s]</pre> <pre>\rSIR Model  76/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 1002/1460 [00:00&lt;00:00, 5129.40it/s]</pre> <pre>\rSIR Model  76/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5147.54it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  77/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  77/115:  30%|\u2588\u2588\u2589       | 431/1460 [00:00&lt;00:00, 4302.27it/s]</pre> <pre>\rSIR Model  77/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 996/1460 [00:00&lt;00:00, 5092.34it/s]</pre> <pre>\rSIR Model  77/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5165.32it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  78/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  78/115:  28%|\u2588\u2588\u258a       | 411/1460 [00:00&lt;00:00, 4106.54it/s]</pre> <pre>\rSIR Model  78/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 961/1460 [00:00&lt;00:00, 4925.55it/s]</pre> <pre>\rSIR Model  78/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5006.93it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  79/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  79/115:  27%|\u2588\u2588\u258b       | 388/1460 [00:00&lt;00:00, 3878.36it/s]</pre> <pre>\rSIR Model  79/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 906/1460 [00:00&lt;00:00, 4643.48it/s]</pre> <pre>\rSIR Model  79/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1424/1460 [00:00&lt;00:00, 4884.35it/s]</pre> <pre>\rSIR Model  79/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4724.74it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  80/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  80/115:  24%|\u2588\u2588\u258d       | 348/1460 [00:00&lt;00:00, 3473.17it/s]</pre> <pre>\rSIR Model  80/115:  51%|\u2588\u2588\u2588\u2588\u2588\u258f    | 751/1460 [00:00&lt;00:00, 3796.57it/s]</pre> <pre>\rSIR Model  80/115:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 1171/1460 [00:00&lt;00:00, 3979.65it/s]</pre> <pre>\rSIR Model  80/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3944.74it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  81/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  81/115:  29%|\u2588\u2588\u2589       | 429/1460 [00:00&lt;00:00, 4285.24it/s]</pre> <pre>\rSIR Model  81/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 998/1460 [00:00&lt;00:00, 5107.50it/s]</pre> <pre>\rSIR Model  81/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5181.18it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  82/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  82/115:  30%|\u2588\u2588\u2588       | 441/1460 [00:00&lt;00:00, 4406.14it/s]</pre> <pre>\rSIR Model  82/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1007/1460 [00:00&lt;00:00, 5142.26it/s]</pre> <pre>\rSIR Model  82/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5212.49it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  83/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  83/115:  30%|\u2588\u2588\u2589       | 432/1460 [00:00&lt;00:00, 4313.64it/s]</pre> <pre>\rSIR Model  83/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 989/1460 [00:00&lt;00:00, 5051.90it/s]</pre> <pre>\rSIR Model  83/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5117.24it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  84/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  84/115:  27%|\u2588\u2588\u258b       | 388/1460 [00:00&lt;00:00, 3872.53it/s]</pre> <pre>\rSIR Model  84/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 911/1460 [00:00&lt;00:00, 4667.65it/s]</pre> <pre>\rSIR Model  84/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1436/1460 [00:00&lt;00:00, 4931.67it/s]</pre> <pre>\rSIR Model  84/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4761.68it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  85/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  85/115:  24%|\u2588\u2588\u258d       | 356/1460 [00:00&lt;00:00, 3555.87it/s]</pre> <pre>\rSIR Model  85/115:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 786/1460 [00:00&lt;00:00, 3991.82it/s]</pre> <pre>\rSIR Model  85/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1224/1460 [00:00&lt;00:00, 4165.93it/s]</pre> <pre>\rSIR Model  85/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4110.14it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  86/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  86/115:  30%|\u2588\u2588\u2588       | 445/1460 [00:00&lt;00:00, 4449.87it/s]</pre> <pre>\rSIR Model  86/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1020/1460 [00:00&lt;00:00, 5211.84it/s]</pre> <pre>\rSIR Model  86/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5268.03it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  87/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  87/115:  31%|\u2588\u2588\u2588       | 454/1460 [00:00&lt;00:00, 4533.23it/s]</pre> <pre>\rSIR Model  87/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1026/1460 [00:00&lt;00:00, 5226.71it/s]</pre> <pre>\rSIR Model  87/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5267.06it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  88/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  88/115:  26%|\u2588\u2588\u258c       | 383/1460 [00:00&lt;00:00, 3828.42it/s]</pre> <pre>\rSIR Model  88/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 943/1460 [00:00&lt;00:00, 4868.48it/s]</pre> <pre>\rSIR Model  88/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4974.80it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  89/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  89/115:  27%|\u2588\u2588\u258b       | 395/1460 [00:00&lt;00:00, 3943.95it/s]</pre> <pre>\rSIR Model  89/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 933/1460 [00:00&lt;00:00, 4786.11it/s]</pre> <pre>\rSIR Model  89/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4893.49it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  90/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  90/115:  22%|\u2588\u2588\u258f       | 323/1460 [00:00&lt;00:00, 3225.63it/s]</pre> <pre>\rSIR Model  90/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 766/1460 [00:00&lt;00:00, 3932.52it/s]</pre> <pre>\rSIR Model  90/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1222/1460 [00:00&lt;00:00, 4215.80it/s]</pre> <pre>\rSIR Model  90/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4127.63it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  91/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  91/115:  31%|\u2588\u2588\u2588       | 454/1460 [00:00&lt;00:00, 4539.42it/s]</pre> <pre>\rSIR Model  91/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1025/1460 [00:00&lt;00:00, 5221.34it/s]</pre> <pre>\rSIR Model  91/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5276.43it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  92/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  92/115:  30%|\u2588\u2588\u2589       | 434/1460 [00:00&lt;00:00, 4339.31it/s]</pre> <pre>\rSIR Model  92/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1004/1460 [00:00&lt;00:00, 5137.86it/s]</pre> <pre>\rSIR Model  92/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5205.61it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  93/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  93/115:  31%|\u2588\u2588\u2588       | 447/1460 [00:00&lt;00:00, 4466.97it/s]</pre> <pre>\rSIR Model  93/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1011/1460 [00:00&lt;00:00, 5152.54it/s]</pre> <pre>\rSIR Model  93/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5210.27it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  94/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  94/115:  29%|\u2588\u2588\u2589       | 429/1460 [00:00&lt;00:00, 4287.21it/s]</pre> <pre>\rSIR Model  94/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 973/1460 [00:00&lt;00:00, 4962.20it/s]</pre> <pre>\rSIR Model  94/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5035.25it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  95/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  95/115:  26%|\u2588\u2588\u258c       | 375/1460 [00:00&lt;00:00, 3744.65it/s]</pre> <pre>\rSIR Model  95/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 843/1460 [00:00&lt;00:00, 4289.81it/s]</pre> <pre>\rSIR Model  95/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1313/1460 [00:00&lt;00:00, 4475.70it/s]</pre> <pre>\rSIR Model  95/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4382.30it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  96/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  96/115:  32%|\u2588\u2588\u2588\u258f      | 462/1460 [00:00&lt;00:00, 4618.99it/s]</pre> <pre>\rSIR Model  96/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1036/1460 [00:00&lt;00:00, 5276.02it/s]</pre> <pre>\rSIR Model  96/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5307.64it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  97/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  97/115:  32%|\u2588\u2588\u2588\u258f      | 465/1460 [00:00&lt;00:00, 4642.19it/s]</pre> <pre>\rSIR Model  97/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1039/1460 [00:00&lt;00:00, 5283.84it/s]</pre> <pre>\rSIR Model  97/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5319.17it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  98/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  98/115:  31%|\u2588\u2588\u2588\u258f      | 459/1460 [00:00&lt;00:00, 4585.39it/s]</pre> <pre>\rSIR Model  98/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1026/1460 [00:00&lt;00:00, 5222.20it/s]</pre> <pre>\rSIR Model  98/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5264.57it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  99/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  99/115:  31%|\u2588\u2588\u2588       | 448/1460 [00:00&lt;00:00, 4472.21it/s]</pre> <pre>\rSIR Model  99/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 991/1460 [00:00&lt;00:00, 5033.01it/s]</pre> <pre>\rSIR Model  99/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5098.79it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 100/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 100/115:  28%|\u2588\u2588\u258a       | 404/1460 [00:00&lt;00:00, 4034.90it/s]</pre> <pre>\rSIR Model 100/115:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 886/1460 [00:00&lt;00:00, 4493.98it/s]</pre> <pre>\rSIR Model 100/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1366/1460 [00:00&lt;00:00, 4631.77it/s]</pre> <pre>\rSIR Model 100/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4543.93it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 101/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 101/115:  32%|\u2588\u2588\u2588\u258f      | 465/1460 [00:00&lt;00:00, 4644.25it/s]</pre> <pre>\rSIR Model 101/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1041/1460 [00:00&lt;00:00, 5295.07it/s]</pre> <pre>\rSIR Model 101/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5332.16it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 102/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 102/115:  32%|\u2588\u2588\u2588\u258f      | 474/1460 [00:00&lt;00:00, 4733.15it/s]</pre> <pre>\rSIR Model 102/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1043/1460 [00:00&lt;00:00, 5295.39it/s]</pre> <pre>\rSIR Model 102/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5328.83it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 103/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 103/115:  32%|\u2588\u2588\u2588\u258f      | 462/1460 [00:00&lt;00:00, 4615.09it/s]</pre> <pre>\rSIR Model 103/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1029/1460 [00:00&lt;00:00, 5230.33it/s]</pre> <pre>\rSIR Model 103/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5274.05it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 104/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 104/115:  31%|\u2588\u2588\u2588\u258f      | 458/1460 [00:00&lt;00:00, 4579.04it/s]</pre> <pre>\rSIR Model 104/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1009/1460 [00:00&lt;00:00, 5125.22it/s]</pre> <pre>\rSIR Model 104/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5171.43it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 105/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 105/115:  28%|\u2588\u2588\u258a       | 413/1460 [00:00&lt;00:00, 4125.75it/s]</pre> <pre>\rSIR Model 105/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 911/1460 [00:00&lt;00:00, 4625.09it/s]</pre> <pre>\rSIR Model 105/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1408/1460 [00:00&lt;00:00, 4777.97it/s]</pre> <pre>\rSIR Model 105/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4671.33it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 106/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 106/115:  32%|\u2588\u2588\u2588\u258f      | 471/1460 [00:00&lt;00:00, 4704.37it/s]</pre> <pre>\rSIR Model 106/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1041/1460 [00:00&lt;00:00, 5285.89it/s]</pre> <pre>\rSIR Model 106/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5312.86it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 107/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 107/115:  32%|\u2588\u2588\u2588\u258f      | 469/1460 [00:00&lt;00:00, 4681.91it/s]</pre> <pre>\rSIR Model 107/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1038/1460 [00:00&lt;00:00, 5271.01it/s]</pre> <pre>\rSIR Model 107/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5311.38it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 108/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 108/115:  32%|\u2588\u2588\u2588\u258f      | 463/1460 [00:00&lt;00:00, 4629.76it/s]</pre> <pre>\rSIR Model 108/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 998/1460 [00:00&lt;00:00, 5050.31it/s]</pre> <pre>\rSIR Model 108/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5185.10it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 109/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 109/115:  32%|\u2588\u2588\u2588\u258f      | 465/1460 [00:00&lt;00:00, 4648.35it/s]</pre> <pre>\rSIR Model 109/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1022/1460 [00:00&lt;00:00, 5185.57it/s]</pre> <pre>\rSIR Model 109/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5236.25it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 110/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 110/115:  30%|\u2588\u2588\u2589       | 432/1460 [00:00&lt;00:00, 4319.55it/s]</pre> <pre>\rSIR Model 110/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 941/1460 [00:00&lt;00:00, 4772.51it/s]</pre> <pre>\rSIR Model 110/115:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1451/1460 [00:00&lt;00:00, 4917.84it/s]</pre> <pre>\rSIR Model 110/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4807.72it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 111/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 111/115:  33%|\u2588\u2588\u2588\u258e      | 475/1460 [00:00&lt;00:00, 4746.97it/s]</pre> <pre>\rSIR Model 111/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1047/1460 [00:00&lt;00:00, 5317.28it/s]</pre> <pre>\rSIR Model 111/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5355.08it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 112/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 112/115:  30%|\u2588\u2588\u2588       | 444/1460 [00:00&lt;00:00, 4435.03it/s]</pre> <pre>\rSIR Model 112/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1014/1460 [00:00&lt;00:00, 5177.42it/s]</pre> <pre>\rSIR Model 112/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5237.62it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 113/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 113/115:  32%|\u2588\u2588\u2588\u258f      | 470/1460 [00:00&lt;00:00, 4694.33it/s]</pre> <pre>\rSIR Model 113/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1012/1460 [00:00&lt;00:00, 5116.31it/s]</pre> <pre>\rSIR Model 113/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5190.34it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 114/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 114/115:  32%|\u2588\u2588\u2588\u258f      | 468/1460 [00:00&lt;00:00, 4679.11it/s]</pre> <pre>\rSIR Model 114/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1025/1460 [00:00&lt;00:00, 5200.04it/s]</pre> <pre>\rSIR Model 114/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5240.94it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 115/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 115/115:  30%|\u2588\u2588\u2589       | 431/1460 [00:00&lt;00:00, 4301.47it/s]</pre> <pre>\rSIR Model 115/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 904/1460 [00:00&lt;00:00, 4551.56it/s]</pre> <pre>\rSIR Model 115/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1419/1460 [00:00&lt;00:00, 4821.48it/s]</pre> <pre>\rSIR Model 115/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4709.55it/s]</pre> <pre>\n</pre> In\u00a0[8]: Copied! <pre>plt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n    plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_exp\"], color=color)\n    plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_obs\"], \".\", label=\"_nolegend_\", color=color)\nplt.xlabel(\"$R_{0}$\")\nplt.ylabel(\"$I(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"I Expected and Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_exp\"], color=color)\n    plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_obs\"], \".\", label=\"_nolegend_\", color=color)\nplt.xlabel(\"$R_{0}$\")\nplt.ylabel(\"$S(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"S Expected and Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(\n        output[condition][\"R0\"] * S0,\n        (output[condition][\"I_inf_exp\"] - output[condition][\"I_inf_obs\"]),\n        \".\",\n        label=f\"Observed S0={S0}\",\n        color=color,\n    )\nplt.xlabel(\"$R_{eff}(t=0)$\")\nplt.ylabel(\"$I_{exp}(t \\\\rightarrow {\\\\infty}) - I_{obs}(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"I Expected - Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\n\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(\n        output[condition][\"R0\"] * S0,\n        (output[condition][\"S_inf_exp\"] - output[condition][\"S_inf_obs\"]),\n        \".\",\n        label=f\"Observed S0={S0}\",\n        color=color,\n    )\nplt.xlabel(\"$R_{eff}(t=0)$\")\nplt.ylabel(\"$S_{exp}(t \\\\rightarrow {\\\\infty}) - S_{obs}(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"S Expected - Observed v R0\")\n</pre> plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)     plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_exp\"], color=color)     plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_obs\"], \".\", label=\"_nolegend_\", color=color) plt.xlabel(\"$R_{0}$\") plt.ylabel(\"$I(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"I Expected and Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_exp\"], color=color)     plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_obs\"], \".\", label=\"_nolegend_\", color=color) plt.xlabel(\"$R_{0}$\") plt.ylabel(\"$S(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"S Expected and Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(         output[condition][\"R0\"] * S0,         (output[condition][\"I_inf_exp\"] - output[condition][\"I_inf_obs\"]),         \".\",         label=f\"Observed S0={S0}\",         color=color,     ) plt.xlabel(\"$R_{eff}(t=0)$\") plt.ylabel(\"$I_{exp}(t \\\\rightarrow {\\\\infty}) - I_{obs}(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"I Expected - Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])  for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(         output[condition][\"R0\"] * S0,         (output[condition][\"S_inf_exp\"] - output[condition][\"S_inf_obs\"]),         \".\",         label=f\"Observed S0={S0}\",         color=color,     ) plt.xlabel(\"$R_{eff}(t=0)$\") plt.ylabel(\"$S_{exp}(t \\\\rightarrow {\\\\infty}) - S_{obs}(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"S Expected - Observed v R0\") Out[8]: <pre>Text(0.5, 1.0, 'S Expected - Observed v R0')</pre> In\u00a0[9]: Copied! <pre>print(\n    \"S expected - S observed &lt; 0.05: \" + str((np.isclose(output[\"S_inf_exp\"], output[\"S_inf_obs\"], atol=0.05)).all())\n)  # Account for 1 timestep offset here\nprint(\n    \"I expected - I observed &lt; 0.05: \" + str((np.isclose(output[\"I_inf_exp\"], output[\"I_inf_obs\"], atol=0.05)).all())\n)  # Account for 1 timestep offset here\n</pre> print(     \"S expected - S observed &lt; 0.05: \" + str((np.isclose(output[\"S_inf_exp\"], output[\"S_inf_obs\"], atol=0.05)).all()) )  # Account for 1 timestep offset here print(     \"I expected - I observed &lt; 0.05: \" + str((np.isclose(output[\"I_inf_exp\"], output[\"I_inf_obs\"], atol=0.05)).all()) )  # Account for 1 timestep offset here <pre>S expected - S observed &lt; 0.05: True\nI expected - I observed &lt; 0.05: True\n</pre>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#outbreak-size-in-the-sir-model-kermack-mckendrick-relation","title":"Outbreak size in the SIR model (Kermack-McKendrick relation)\u00b6","text":"<p>We move next to the Susceptible-Infected-Recovered model, the first of these canonical test models that actually provides a decent, coarse, representation of many vaccine-preventable diseases that we are interested in.  This test will explore the size of acute outbreaks; in this situation, the role of demography is pretty small and serves only to complicate the analysis, so we will work without demography.  The model contains three agent states and two transitions: susceptible -&gt; infected -&gt; recovered, with the recovered state assumed to be lifelong.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} \\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I \\\\  \\dot{R} = \\gamma I $$</p> <p>As before, we discretize this as: $$ \\Delta I = Bin(S_t, 1-exp^{-\\beta \\Delta t \\frac{I}{N}}) \\\\ \\Delta R = Bin(I_t, 1-exp^{-\\gamma \\Delta t}) \\\\ S_{t+1} = S_t - \\Delta I_t \\\\ I_{t+1} = I_t + \\Delta I_t -\\Delta R_t \\\\ R_{t+1} = R_t + \\Delta R_t $$</p> <p>Note: As written, the dwell time of individuals in the infectious state is strictly exponentially distributed.  Without introducing substantially more complexity (delay-differential or integro-differential equations, the Generalized Linear Chain Trick), this is a general feature of ODE systems.  In agent-based models, however, the distribution of the dwell time in the Infectious state can be chosen from an arbitrary distribution, in which case the discretization as written no longer holds.  For the purposes of comparability with analytic results, we choose to draw from an exponential distribution in the below.</p> <p>Analysis of the SIR system can be found in other sources, and closed-form analytic solutions to the system dyanmics are elusive and generally too complicated to provide much insight - more generally useful are results about the equilibrium states as  $t \\rightarrow \\infty$.  We'll focus here on one of these, the size of an outbreak introduced into a closed population, given by the implicit formula</p> <p>$$  Z =  \\begin{cases}     S_0(1-e^{-R_0[Z+I_0]}), &amp; \\text{if} \\:\\:  R_0S(0)&gt;1 \\\\     0, &amp;\\text{if} \\:\\:  R_0S(0)&lt;=1 \\end{cases} \\\\ Z = \\sum_{t=0}^\\infty I(t) = S_0 - S_\\infty \\\\ R_0 = \\frac{\\beta}{\\gamma} $$</p> <p>One can obtain an approximate analytic solution for the outbreak curve itself, shown below. However, the approximation employed in deriving this is that $R_0 R(t)$ is small, which likely to be violated during the peak of the outbreak.  And it's immediately clear upon looking at this formula that it doesn't exactly offer some intuitive interpretation for the dynamics.</p> <p>$$ \\frac{dR}{dt} = \\frac{\\gamma \\alpha^2}{2S(0)R_0^2}\\text{sech}^2\\left(\\frac{\\alpha \\gamma t}{2} - \\phi\\right) \\\\ \\phi = \\text{tanh}^{-1}\\left(\\frac{S(0)(R_0-1)}{\\alpha}\\right) \\\\ \\alpha = \\sqrt{S(0)^2(R_0-1)^2 + 2S(0)I(0)R_0^2} $$</p> <p>This notebook will focus on testing the final size prediction and for now, ignore testing the approximate formula for the whole outbreak curve.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with four components: the states <code>Susceptible</code>, <code>Recovered</code>, and <code>Infectious</code>, and the <code>Transmission</code> process.  The <code>Susceptible</code> and <code>Transmission</code> components look largely the same as the SI and SIS models.  The <code>Infectious</code> component now moves people into a <code>Recovered</code> state when <code>itimer</code> expires, instead of sending them back to <code>Susceptible</code> as in the SIS model.  As there are no vital dynamics in this model, the <code>Recovered</code> state is a terminal state - these agents have no further dynamics and participate only by being part of the total population denominator in the <code>Transmission</code> component.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.  We can check that $S_t = N_t - \\sum{\\Delta I_t}$, that $R_t = \\sum{\\Delta R_t}$, and the total population is constant and equal to $S_t + I_t + R_t$ for all timesteps.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will loop over a set of $(R_0, S(0))$ pairs and confirm that the final outbreak size matches the expectation given in the equation above.  As this is a stochastic model, the main concern is that when $R_0S(0)$ is close to one, the outbreak may fail to take off or truncate at a slightly smaller final size.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the expected relationships between susceptible, infected, recovered, and total population hold.</p>"},{"location":"tutorials/notebooks/04_SIR_nobirths_outbreak_size/#scientific-test","title":"Scientific test\u00b6","text":"<p>We will now loop over a few values of R-zero and initial susceptibility, and compare the size of the outbreak against the expected size given by the equation in the introduction</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/","title":"Average age at infection in the SIR model","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.stats import expon\nfrom scipy.stats import kstest\nfrom sklearn.metrics import mean_squared_error\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.stats import expon from scipy.stats import kstest from sklearn.metrics import mean_squared_error  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.5'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>from functools import partial\n\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.generic.models import SIR\nfrom laser.generic.newutils import ValuesMap\nfrom laser.generic.newutils import grid\n\nprint(\"done\")\n</pre> from functools import partial  import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.generic.models import SIR from laser.generic.newutils import ValuesMap from laser.generic.newutils import grid  print(\"done\") <pre>done\n</pre> In\u00a0[3]: Copied! <pre># scenario = pd.DataFrame(data=[[\"homenode\", 1e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])\npop=1e6\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=-(122+(19+(59/60))/60), origin_y=47+(36+(35/60))/60)\ninitial_infected = 1\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\nscenario[\"R\"] = 0\nparameters = PropertySet(\n    # {\"seed\": 4, \"nticks\": 18250, \"verbose\": True, \"beta\": 0.1, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}\n    {\"seed\": 4, \"nticks\": 365*3, \"verbose\": True, \"beta\": 2/60, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}\n)\n\nprint(\"done\")\n</pre> # scenario = pd.DataFrame(data=[[\"homenode\", 1e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"]) pop=1e6 scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=-(122+(19+(59/60))/60), origin_y=47+(36+(35/60))/60) initial_infected = 1 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected scenario[\"R\"] = 0 parameters = PropertySet(     # {\"seed\": 4, \"nticks\": 18250, \"verbose\": True, \"beta\": 0.1, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}     {\"seed\": 4, \"nticks\": 365*3, \"verbose\": True, \"beta\": 2/60, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3} )  print(\"done\") <pre>done\n</pre> In\u00a0[4]: Copied! <pre>class Importation:\n    def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):\n        self.model = model\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n        self.period = period\n        self.count = count\n\n        self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)\n\n        return\n    \n    def step(self, tick: int) -&gt; None:\n        if tick &gt; 0 and tick % self.period == 0:\n            i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]\n            if len(i_susceptible) &gt; 0:\n                count = min(self.count, len(i_susceptible))\n                i_infect = np.random.choice(i_susceptible, size=count, replace=False)\n                self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value\n                samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))\n                samples = np.round(samples)\n                samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)\n                self.model.people.itimer[i_infect] = samples\n                inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)\n                self.model.nodes.S[tick + 1] -= inf_by_node\n                self.model.nodes.I[tick + 1] += inf_by_node\n                self.model.nodes.imports[tick] = inf_by_node\n            # else:\n            #     print(f\"No susceptibles to infect at tick {tick}\")\n\n        return\n\nprint(\"done\")\n</pre> class Importation:     def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):         self.model = model         self.infdurdist = infdurdist         self.infdurmin = infdurmin         self.period = period         self.count = count          self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)          return          def step(self, tick: int) -&gt; None:         if tick &gt; 0 and tick % self.period == 0:             i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]             if len(i_susceptible) &gt; 0:                 count = min(self.count, len(i_susceptible))                 i_infect = np.random.choice(i_susceptible, size=count, replace=False)                 self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value                 samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))                 samples = np.round(samples)                 samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)                 self.model.people.itimer[i_infect] = samples                 inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)                 self.model.nodes.S[tick + 1] -= inf_by_node                 self.model.nodes.I[tick + 1] += inf_by_node                 self.model.nodes.imports[tick] = inf_by_node             # else:             #     print(f\"No susceptibles to infect at tick {tick}\")          return  print(\"done\") <pre>done\n</pre> <p>We will need a modified Transmission component which tracks the date of infection (doi) for individuals so we can calculate age at infection.</p> In\u00a0[5]: Copied! <pre>import numba as nb\nfrom laser.generic.models.SIR import State\n\nclass TransmissionWithDOI(SIR.Transmission):\n    def __init__(self, model, infdurdist, infdurmin: int =1):\n        super().__init__(model, infdurdist, infdurmin)\n        self.model.people.add_vector_property(\"doi\", model.params.nticks + 1, dtype=np.int16, default=0)\n        return\n\n    @staticmethod\n    @nb.njit(\n        nogil=True,\n        parallel=True,\n        cache=True,\n    )\n    def nb_transmission_doi(states, nodeids, ft, inf_by_node, itimers, infdurdist, infdurmin, tick, dois):\n        for i in nb.prange(len(states)):\n            if states[i] == State.SUSCEPTIBLE.value:\n                # Check for infection\n                draw = np.random.rand()\n                nid = nodeids[i]\n                if draw &lt; ft[nid]:\n                    states[i] = State.INFECTIOUS.value\n                    dois[i] = tick  # Set date of infection\n                    itimers[i] = np.maximum(np.round(infdurdist()), infdurmin)  # Set the infection timer\n                    inf_by_node[nb.get_thread_id(), nid] += 1\n\n        return\n\n    def step(self, tick: int) -&gt; None:\n        ft = self.model.nodes.forces[tick]\n\n        N = self.model.nodes.S[tick] + (I := self.model.nodes.I[tick])  # noqa: E741\n        # Shouldn't be any exposed (E), because this is an S-&gt;I model\n        # Might have R\n        if hasattr(self.model.nodes, \"R\"):\n            N += self.model.nodes.R[tick]\n\n        ft[:] = self.model.params.beta * I / N\n        transfer = ft[:, None] * self.model.network\n        ft += transfer.sum(axis=0)\n        ft -= transfer.sum(axis=1)\n        ft = -np.expm1(-ft)  # Convert to probability of infection\n\n        inf_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.uint32)\n        self.nb_transmission_doi(\n            self.model.people.state, self.model.people.nodeid, ft, inf_by_node, self.model.people.itimer, self.infdurdist, self.infdurmin,\n            tick, self.model.people.doi # DOI specific parameters\n        )\n        inf_by_node = inf_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads\n\n        # state(t+1) = state(t) + \u2206state(t)\n        self.model.nodes.S[tick + 1] -= inf_by_node\n        self.model.nodes.I[tick + 1] += inf_by_node\n        # Record today's \u2206\n        self.model.nodes.incidence[tick] = inf_by_node\n\n        return\n</pre> import numba as nb from laser.generic.models.SIR import State  class TransmissionWithDOI(SIR.Transmission):     def __init__(self, model, infdurdist, infdurmin: int =1):         super().__init__(model, infdurdist, infdurmin)         self.model.people.add_vector_property(\"doi\", model.params.nticks + 1, dtype=np.int16, default=0)         return      @staticmethod     @nb.njit(         nogil=True,         parallel=True,         cache=True,     )     def nb_transmission_doi(states, nodeids, ft, inf_by_node, itimers, infdurdist, infdurmin, tick, dois):         for i in nb.prange(len(states)):             if states[i] == State.SUSCEPTIBLE.value:                 # Check for infection                 draw = np.random.rand()                 nid = nodeids[i]                 if draw &lt; ft[nid]:                     states[i] = State.INFECTIOUS.value                     dois[i] = tick  # Set date of infection                     itimers[i] = np.maximum(np.round(infdurdist()), infdurmin)  # Set the infection timer                     inf_by_node[nb.get_thread_id(), nid] += 1          return      def step(self, tick: int) -&gt; None:         ft = self.model.nodes.forces[tick]          N = self.model.nodes.S[tick] + (I := self.model.nodes.I[tick])  # noqa: E741         # Shouldn't be any exposed (E), because this is an S-&gt;I model         # Might have R         if hasattr(self.model.nodes, \"R\"):             N += self.model.nodes.R[tick]          ft[:] = self.model.params.beta * I / N         transfer = ft[:, None] * self.model.network         ft += transfer.sum(axis=0)         ft -= transfer.sum(axis=1)         ft = -np.expm1(-ft)  # Convert to probability of infection          inf_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.uint32)         self.nb_transmission_doi(             self.model.people.state, self.model.people.nodeid, ft, inf_by_node, self.model.people.itimer, self.infdurdist, self.infdurmin,             tick, self.model.people.doi # DOI specific parameters         )         inf_by_node = inf_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads          # state(t+1) = state(t) + \u2206state(t)         self.model.nodes.S[tick + 1] -= inf_by_node         self.model.nodes.I[tick + 1] += inf_by_node         # Record today's \u2206         self.model.nodes.incidence[tick] = inf_by_node          return  In\u00a0[6]: Copied! <pre>birthrate_map = ValuesMap.from_scalar(0, nnodes=len(scenario), nsteps=parameters.nticks)\nmodel = SIR.Model(scenario, parameters, birthrates=birthrate_map.values)\ninfdurdist = dists.normal(loc=parameters.inf_mean, scale=2)\npyramid = AliasedDistribution(np.full(89, 1_000))\nsurvival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\nmodel.components = [\n    SIR.Susceptible(model),\n    SIR.Recovered(model),\n    SIR.Infectious(model, infdurdist),\n    Importation(model, infdurdist),\n    # SIR.Transmission(model, infdurdist),\n    TransmissionWithDOI(model, infdurdist),\n    SIR.VitalDynamics(model, birthrates=birthrate_map.values, pyramid=pyramid, survival=survival)\n]\n\nmodel.run()\nplt.plot(model.nodes.S, color=\"blue\")\nplt.plot(model.nodes.I, color=\"red\")\nplt.plot(model.nodes.R, color=\"green\")\nplt.legend([\"S\", \"I\", \"R\"])\nplt.show()\n</pre> birthrate_map = ValuesMap.from_scalar(0, nnodes=len(scenario), nsteps=parameters.nticks) model = SIR.Model(scenario, parameters, birthrates=birthrate_map.values) infdurdist = dists.normal(loc=parameters.inf_mean, scale=2) pyramid = AliasedDistribution(np.full(89, 1_000)) survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum()) model.components = [     SIR.Susceptible(model),     SIR.Recovered(model),     SIR.Infectious(model, infdurdist),     Importation(model, infdurdist),     # SIR.Transmission(model, infdurdist),     TransmissionWithDOI(model, infdurdist),     SIR.VitalDynamics(model, birthrates=birthrate_map.values, pyramid=pyramid, survival=survival) ]  model.run() plt.plot(model.nodes.S, color=\"blue\") plt.plot(model.nodes.I, color=\"red\") plt.plot(model.nodes.R, color=\"green\") plt.legend([\"S\", \"I\", \"R\"]) plt.show() <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[6], line 2\n      1 birthrate_map = ValuesMap.from_scalar(0, nnodes=len(scenario), nsteps=parameters.nticks)\n----&gt; 2 model = SIR.Model(scenario, parameters, birthrates=birthrate_map.values)\n      3 infdurdist = dists.normal(loc=parameters.inf_mean, scale=2)\n      4 pyramid = AliasedDistribution(np.full(89, 1_000))\n\nAttributeError: module 'laser.generic.models.SIR' has no attribute 'Model'</pre> In\u00a0[7]: Copied! <pre>cases = np.squeeze(model.nodes.I)\nsusc = np.squeeze(model.nodes.S)\nrec = np.squeeze(model.nodes.R)\ninc = np.squeeze(model.nodes.incidence)\nbirths = np.squeeze(model.nodes.births)\npops = np.squeeze(model.nodes.S + model.nodes.I + model.nodes.R + model.nodes.births)\n\nprint(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all()))\n</pre> cases = np.squeeze(model.nodes.I) susc = np.squeeze(model.nodes.S) rec = np.squeeze(model.nodes.R) inc = np.squeeze(model.nodes.incidence) births = np.squeeze(model.nodes.births) pops = np.squeeze(model.nodes.S + model.nodes.I + model.nodes.R + model.nodes.births)  print(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all())) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 cases = np.squeeze(model.nodes.I)\n      2 susc = np.squeeze(model.nodes.S)\n      3 rec = np.squeeze(model.nodes.R)\n\nNameError: name 'model' is not defined</pre> In\u00a0[8]: Copied! <pre>mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nR0 = model.params.beta / (1 / model.params.inf_mean + mu)\nA = 1 / (R0 * mu) / 365\na = np.arange(0, 15, 100)\n\ndef fit_age_at_infection(model, cutpos=10000):\n    cut = model.population.doi &gt; cutpos\n    data = (model.population.doi[cut] - model.population.dob[cut]) / 365\n    expfit = expon.fit(data)\n    fitqual = kstest(data, expon.cdf, expfit)\n    return data, expfit, fitqual\n\ndata, expfit, fitqual = fit_age_at_infection(model)\n\nplt.hist(data, bins=a, density=True)\nplt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4)\nplt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\")\nplt.xlabel(\"Age at infection (years)\")\nplt.ylabel(\"Density\")\nplt.legend(\n    [\n        f\"Expected exponential distribution - A = {A:.2f} years\",\n        f\"Best fit age of infection, A = {expfit[1]:.2f} years\",\n        \"Ages from simulation\",\n    ]\n)\nplt.show()\nfitqual\n</pre> mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 R0 = model.params.beta / (1 / model.params.inf_mean + mu) A = 1 / (R0 * mu) / 365 a = np.arange(0, 15, 100)  def fit_age_at_infection(model, cutpos=10000):     cut = model.population.doi &gt; cutpos     data = (model.population.doi[cut] - model.population.dob[cut]) / 365     expfit = expon.fit(data)     fitqual = kstest(data, expon.cdf, expfit)     return data, expfit, fitqual  data, expfit, fitqual = fit_age_at_infection(model)  plt.hist(data, bins=a, density=True) plt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4) plt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\") plt.xlabel(\"Age at infection (years)\") plt.ylabel(\"Density\") plt.legend(     [         f\"Expected exponential distribution - A = {A:.2f} years\",         f\"Best fit age of infection, A = {expfit[1]:.2f} years\",         \"Ages from simulation\",     ] ) plt.show() fitqual <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\n      2 R0 = model.params.beta / (1 / model.params.inf_mean + mu)\n      3 A = 1 / (R0 * mu) / 365\n\nNameError: name 'model' is not defined</pre> In\u00a0[9]: Copied! <pre>A2 = 1 / ((R0 - 1) * mu) / 365\n\n\ndef Scurve(x, lam):\n    return np.exp(-x / lam)\n\n\ndef fit_susceptibility_vs_age(model, cutpos=10000):\n    cut = (model.population.susceptibility == 1) &amp; (model.population.dob &gt; cutpos)\n    bins = np.linspace(0, 50, 1200)\n    age_years = (np.max(model.population.dob) - model.population.dob) / 365\n    n1 = np.histogram(age_years, bins=bins)[0]\n    n2 = np.histogram(age_years[cut], bins=bins)[0]\n    n1[n1 == 0] = 1\n    y1 = n2 / n1\n    popt, pcov = curve_fit(Scurve, bins[:-1] + np.mean(np.diff(bins)), y1, p0=2.5)\n    mse = mean_squared_error(y1, Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))\n    return y1, bins, popt, pcov, mse\n\n\ndata, bins, popt, pcov, mse = fit_susceptibility_vs_age(model)\n\n# Plotting is a little more complicated here, want to plot at the bin centers and force y=1 at x=0\nplt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *data], \".\")\nplt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, A2))], lw=4)\nplt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))], \"k--\")\nplt.legend(\n    [\"Simulation output\", f\"Expected exponential distribution - A = {A2:.2f} years\", f\"Best fit age of infection, A = {popt[0]:.2f} years\"]\n)\nplt.xlabel(\"Age (years)\")\nplt.ylabel(\"Fraction of individuals susceptible at age\")\nplt.show()\nprint(\"RMSE = \", np.sqrt(mse))\n</pre> A2 = 1 / ((R0 - 1) * mu) / 365   def Scurve(x, lam):     return np.exp(-x / lam)   def fit_susceptibility_vs_age(model, cutpos=10000):     cut = (model.population.susceptibility == 1) &amp; (model.population.dob &gt; cutpos)     bins = np.linspace(0, 50, 1200)     age_years = (np.max(model.population.dob) - model.population.dob) / 365     n1 = np.histogram(age_years, bins=bins)[0]     n2 = np.histogram(age_years[cut], bins=bins)[0]     n1[n1 == 0] = 1     y1 = n2 / n1     popt, pcov = curve_fit(Scurve, bins[:-1] + np.mean(np.diff(bins)), y1, p0=2.5)     mse = mean_squared_error(y1, Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))     return y1, bins, popt, pcov, mse   data, bins, popt, pcov, mse = fit_susceptibility_vs_age(model)  # Plotting is a little more complicated here, want to plot at the bin centers and force y=1 at x=0 plt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *data], \".\") plt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, A2))], lw=4) plt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))], \"k--\") plt.legend(     [\"Simulation output\", f\"Expected exponential distribution - A = {A2:.2f} years\", f\"Best fit age of infection, A = {popt[0]:.2f} years\"] ) plt.xlabel(\"Age (years)\") plt.ylabel(\"Fraction of individuals susceptible at age\") plt.show() print(\"RMSE = \", np.sqrt(mse)) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 A2 = 1 / ((R0 - 1) * mu) / 365\n      4 def Scurve(x, lam):\n      5     return np.exp(-x / lam)\n\nNameError: name 'R0' is not defined</pre> In\u00a0[10]: Copied! <pre># Test that population age distribution is correct\ndef fit_population_age_distribution(model):\n    age_years = (np.max(model.population.dob) - model.population.dob) / 365\n    expfit = expon.fit(age_years)\n    fitqual = kstest(age_years, expon.cdf, expfit)\n    return age_years, expfit, fitqual\n\n\nage_years, expfit, fitqual = fit_population_age_distribution(model)\nmu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nA = 1 / mu / 365\na = np.arange(0, 60, 0.1)\n\nplt.hist(age_years, bins=a, density=True)\nplt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4)\nplt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\")\nplt.xlabel(\"Age at infection (years)\")\nplt.ylabel(\"Density\")\nplt.legend(\n    [f\"Expected exponential distribution - A = {A:.2f} years\", f\"Best fit age of infection, A = {expfit[1]:.2f} years\", \"Simulation output\"]\n)\nplt.show()\nfitqual\n</pre> # Test that population age distribution is correct def fit_population_age_distribution(model):     age_years = (np.max(model.population.dob) - model.population.dob) / 365     expfit = expon.fit(age_years)     fitqual = kstest(age_years, expon.cdf, expfit)     return age_years, expfit, fitqual   age_years, expfit, fitqual = fit_population_age_distribution(model) mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 A = 1 / mu / 365 a = np.arange(0, 60, 0.1)  plt.hist(age_years, bins=a, density=True) plt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4) plt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\") plt.xlabel(\"Age at infection (years)\") plt.ylabel(\"Density\") plt.legend(     [f\"Expected exponential distribution - A = {A:.2f} years\", f\"Best fit age of infection, A = {expfit[1]:.2f} years\", \"Simulation output\"] ) plt.show() fitqual <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 9\n      5     fitqual = kstest(age_years, expon.cdf, expfit)\n      6     return age_years, expfit, fitqual\n----&gt; 9 age_years, expfit, fitqual = fit_population_age_distribution(model)\n     10 mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\n     11 A = 1 / mu / 365\n\nNameError: name 'model' is not defined</pre> In\u00a0[11]: Copied! <pre>%%capture\n\nscenario = pd.DataFrame(data=[[\"homenode\", 3e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])\n\ncbrs = 15 + 85 * np.random.rand(25)\ninf_means = 5 + 45 * np.random.rand(25)\nR0s = 1.5 + 8.5 * np.random.rand(25)\noutput = pd.DataFrame(data={\"cbr\": cbrs, \"inf_mean\": inf_means, \"R0\": R0s})\noutput[\"Average_Iage_observed\"] = np.nan\noutput[\"Average_Iage_expected\"] = np.nan\noutput[\"Average_Sage_observed\"] = np.nan\noutput[\"Average_Sage_expected\"] = np.nan\noutput[\"Average_age_expected\"] = np.nan\noutput[\"Average_age_expected\"] = np.nan\nfor index, row in output.iterrows():\n    parameters = PropertySet(\n        {\n            \"seed\": 2,\n            \"nticks\": 73000,\n            \"verbose\": True,\n            \"beta\": row[\"R0\"] * (mu + 1 / row[\"inf_mean\"]),\n            \"inf_mean\": row[\"inf_mean\"],\n            \"cbr\": row[\"cbr\"],\n            \"importation_period\": 180,\n            \"importation_count\": 3,\n        }\n    )\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Random_Agents,\n    ]\n    set_initial_susceptibility_randomly(model, 1 / row[\"R0\"] + 0.05)\n    seed_infections_randomly(model, ninfections=1)\n    model.run()\n    mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\n    _, expfit, _ = fit_age_at_infection(model, 36500)\n\n    output.loc[index, \"Average_Iage_expected\"] = 1 / (row[\"R0\"] * mu) / 365\n    output.loc[index, \"Average_Iage_observed\"] = expfit[1]\n\n    _, _, popt, _, _ = fit_susceptibility_vs_age(model, 36500)\n    output.loc[index, \"Average_Sage_expected\"] = 1 / ((row[\"R0\"] - 1) * mu) / 365\n    output.loc[index, \"Average_Sage_observed\"] = popt[0]\n\n    _, expfit, _ = fit_population_age_distribution(model)\n    output.loc[index, \"Average_age_expected\"] = 1 / mu / 365\n    output.loc[index, \"Average_age_observed\"] = expfit[1]\n</pre> %%capture  scenario = pd.DataFrame(data=[[\"homenode\", 3e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])  cbrs = 15 + 85 * np.random.rand(25) inf_means = 5 + 45 * np.random.rand(25) R0s = 1.5 + 8.5 * np.random.rand(25) output = pd.DataFrame(data={\"cbr\": cbrs, \"inf_mean\": inf_means, \"R0\": R0s}) output[\"Average_Iage_observed\"] = np.nan output[\"Average_Iage_expected\"] = np.nan output[\"Average_Sage_observed\"] = np.nan output[\"Average_Sage_expected\"] = np.nan output[\"Average_age_expected\"] = np.nan output[\"Average_age_expected\"] = np.nan for index, row in output.iterrows():     parameters = PropertySet(         {             \"seed\": 2,             \"nticks\": 73000,             \"verbose\": True,             \"beta\": row[\"R0\"] * (mu + 1 / row[\"inf_mean\"]),             \"inf_mean\": row[\"inf_mean\"],             \"cbr\": row[\"cbr\"],             \"importation_period\": 180,             \"importation_count\": 3,         }     )      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Random_Agents,     ]     set_initial_susceptibility_randomly(model, 1 / row[\"R0\"] + 0.05)     seed_infections_randomly(model, ninfections=1)     model.run()     mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1     _, expfit, _ = fit_age_at_infection(model, 36500)      output.loc[index, \"Average_Iage_expected\"] = 1 / (row[\"R0\"] * mu) / 365     output.loc[index, \"Average_Iage_observed\"] = expfit[1]      _, _, popt, _, _ = fit_susceptibility_vs_age(model, 36500)     output.loc[index, \"Average_Sage_expected\"] = 1 / ((row[\"R0\"] - 1) * mu) / 365     output.loc[index, \"Average_Sage_observed\"] = popt[0]      _, expfit, _ = fit_population_age_distribution(model)     output.loc[index, \"Average_age_expected\"] = 1 / mu / 365     output.loc[index, \"Average_age_observed\"] = expfit[1] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[11], line 19\n     12 output[\"Average_age_expected\"] = np.nan\n     13 for index, row in output.iterrows():\n     14     parameters = PropertySet(\n     15         {\n     16             \"seed\": 2,\n     17             \"nticks\": 73000,\n     18             \"verbose\": True,\n---&gt; 19             \"beta\": row[\"R0\"] * (mu + 1 / row[\"inf_mean\"]),\n     20             \"inf_mean\": row[\"inf_mean\"],\n     21             \"cbr\": row[\"cbr\"],\n     22             \"importation_period\": 180,\n     23             \"importation_count\": 3,\n     24         }\n     25     )\n     27     model = Model(scenario, parameters)\n     28     model.components = [\n     29         Births_ConstantPop,\n     30         Susceptibility,\n   (...)     33         Infect_Random_Agents,\n     34     ]\n\nNameError: name 'mu' is not defined</pre> In\u00a0[12]: Copied! <pre># Plotting the expected and observed values\nfig, axes = plt.subplots(3, 1, figsize=(10, 15))\n\n# Plot for Average_Iage\naxes[0].scatter(output[\"Average_Iage_expected\"], output[\"Average_Iage_observed\"], c=\"blue\")\naxes[0].plot(\n    [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],\n    [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],\n    \"r--\",\n)\naxes[0].set_xlabel(\"Average_Iage_expected\")\naxes[0].set_ylabel(\"Average_Iage_observed\")\naxes[0].set_title(\"Average_Iage: Expected vs Observed\")\n\n# Plot for Average_Sage\naxes[1].scatter(output[\"Average_Sage_expected\"], output[\"Average_Sage_observed\"], c=\"green\")\naxes[1].plot(\n    [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],\n    [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],\n    \"r--\",\n)\naxes[1].set_xlabel(\"Average_Sage_expected\")\naxes[1].set_ylabel(\"Average_Sage_observed\")\naxes[1].set_title(\"Average_Sage: Expected vs Observed\")\n\n# Plot for Average_age\naxes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\")\naxes[2].plot(\n    [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n    [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n    \"r--\",\n)\naxes[2].set_xlabel(\"Average_age_expected\")\naxes[2].set_ylabel(\"Average_age_observed\")\naxes[2].set_title(\"Average_age: Expected vs Observed\")\n\nplt.tight_layout()\nplt.show()\n\n# Testing whether the expected and observed values are within 10% of each other\nwithin_10_percent_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] &lt;= 0.1\nwithin_10_percent_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] &lt;= 0.1\nwithin_10_percent_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"] &lt;= 0.1\n# Calculate deviations\ndeviation_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"]\ndeviation_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"]\ndeviation_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"]\n\n# Print average fractional deviation\nprint(f\"Average fractional deviation for Iage: {deviation_Iage.mean()}\")\nprint(f\"Average fractional deviation for Sage: {deviation_Sage.mean()}\")\nprint(f\"Average fractional deviation for age: {deviation_age.mean()}\")\n\n# Print max deviation\nprint(f\"Max deviation for Iage: {deviation_Iage.max()}\")\nprint(f\"Max deviation for Sage: {deviation_Sage.max()}\")\nprint(f\"Max deviation for age: {deviation_age.max()}\")\n\n# Print number of sims &gt;5% and 10% away from expectation\nprint(f\"Number of sims &gt;5% away for Iage: {(deviation_Iage &gt; 0.05).sum()}\")\nprint(f\"Number of sims &gt;10% away for Iage: {(deviation_Iage &gt; 0.1).sum()}\")\nprint(f\"Number of sims &gt;5% away for Sage: {(deviation_Sage &gt; 0.05).sum()}\")\nprint(f\"Number of sims &gt;10% away for Sage: {(deviation_Sage &gt; 0.1).sum()}\")\nprint(f\"Number of sims &gt;5% away for age: {(deviation_age &gt; 0.05).sum()}\")\nprint(f\"Number of sims &gt;10% away for age: {(deviation_age &gt; 0.1).sum()}\")\n</pre> # Plotting the expected and observed values fig, axes = plt.subplots(3, 1, figsize=(10, 15))  # Plot for Average_Iage axes[0].scatter(output[\"Average_Iage_expected\"], output[\"Average_Iage_observed\"], c=\"blue\") axes[0].plot(     [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],     [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],     \"r--\", ) axes[0].set_xlabel(\"Average_Iage_expected\") axes[0].set_ylabel(\"Average_Iage_observed\") axes[0].set_title(\"Average_Iage: Expected vs Observed\")  # Plot for Average_Sage axes[1].scatter(output[\"Average_Sage_expected\"], output[\"Average_Sage_observed\"], c=\"green\") axes[1].plot(     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],     \"r--\", ) axes[1].set_xlabel(\"Average_Sage_expected\") axes[1].set_ylabel(\"Average_Sage_observed\") axes[1].set_title(\"Average_Sage: Expected vs Observed\")  # Plot for Average_age axes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\") axes[2].plot(     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],     \"r--\", ) axes[2].set_xlabel(\"Average_age_expected\") axes[2].set_ylabel(\"Average_age_observed\") axes[2].set_title(\"Average_age: Expected vs Observed\")  plt.tight_layout() plt.show()  # Testing whether the expected and observed values are within 10% of each other within_10_percent_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] &lt;= 0.1 within_10_percent_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] &lt;= 0.1 within_10_percent_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"] &lt;= 0.1 # Calculate deviations deviation_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] deviation_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] deviation_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"]  # Print average fractional deviation print(f\"Average fractional deviation for Iage: {deviation_Iage.mean()}\") print(f\"Average fractional deviation for Sage: {deviation_Sage.mean()}\") print(f\"Average fractional deviation for age: {deviation_age.mean()}\")  # Print max deviation print(f\"Max deviation for Iage: {deviation_Iage.max()}\") print(f\"Max deviation for Sage: {deviation_Sage.max()}\") print(f\"Max deviation for age: {deviation_age.max()}\")  # Print number of sims &gt;5% and 10% away from expectation print(f\"Number of sims &gt;5% away for Iage: {(deviation_Iage &gt; 0.05).sum()}\") print(f\"Number of sims &gt;10% away for Iage: {(deviation_Iage &gt; 0.1).sum()}\") print(f\"Number of sims &gt;5% away for Sage: {(deviation_Sage &gt; 0.05).sum()}\") print(f\"Number of sims &gt;10% away for Sage: {(deviation_Sage &gt; 0.1).sum()}\") print(f\"Number of sims &gt;5% away for age: {(deviation_age &gt; 0.05).sum()}\") print(f\"Number of sims &gt;10% away for age: {(deviation_age &gt; 0.1).sum()}\") <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3811 try:\n-&gt; 3812     return self._engine.get_loc(casted_key)\n   3813 except KeyError as err:\n\nFile pandas/_libs/index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7096, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'Average_age_observed'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[12], line 27\n     24 axes[1].set_title(\"Average_Sage: Expected vs Observed\")\n     26 # Plot for Average_age\n---&gt; 27 axes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\")\n     28 axes[2].plot(\n     29     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n     30     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n     31     \"r--\",\n     32 )\n     33 axes[2].set_xlabel(\"Average_age_expected\")\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/frame.py:4113, in DataFrame.__getitem__(self, key)\n   4111 if self.columns.nlevels &gt; 1:\n   4112     return self._getitem_multilevel(key)\n-&gt; 4113 indexer = self.columns.get_loc(key)\n   4114 if is_integer(indexer):\n   4115     indexer = [indexer]\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexes/base.py:3819, in Index.get_loc(self, key)\n   3814     if isinstance(casted_key, slice) or (\n   3815         isinstance(casted_key, abc.Iterable)\n   3816         and any(isinstance(x, slice) for x in casted_key)\n   3817     ):\n   3818         raise InvalidIndexError(key)\n-&gt; 3819     raise KeyError(key) from err\n   3820 except TypeError:\n   3821     # If we have a listlike key, _check_indexing_error will raise\n   3822     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3823     #  the TypeError.\n   3824     self._check_indexing_error(key)\n\nKeyError: 'Average_age_observed'</pre> In\u00a0[13]: Copied! <pre>output\n</pre> output Out[13]: cbr inf_mean R0 Average_Iage_observed Average_Iage_expected Average_Sage_observed Average_Sage_expected Average_age_expected 0 83.540548 34.455730 2.632683 NaN NaN NaN NaN NaN 1 17.990564 26.767912 8.104656 NaN NaN NaN NaN NaN 2 20.672555 23.255215 4.966966 NaN NaN NaN NaN NaN 3 35.521175 43.844446 4.691883 NaN NaN NaN NaN NaN 4 93.240553 28.472593 9.659055 NaN NaN NaN NaN NaN 5 31.473449 9.271614 2.080554 NaN NaN NaN NaN NaN 6 45.803328 12.704352 7.168475 NaN NaN NaN NaN NaN 7 35.479323 12.591552 3.612183 NaN NaN NaN NaN NaN 8 68.236946 36.331254 4.526377 NaN NaN NaN NaN NaN 9 54.185976 24.607534 3.026495 NaN NaN NaN NaN NaN 10 70.892597 13.605581 6.221342 NaN NaN NaN NaN NaN 11 43.716282 28.999053 8.190825 NaN NaN NaN NaN NaN 12 56.235681 36.767056 8.164748 NaN NaN NaN NaN NaN 13 47.690816 18.382411 4.233190 NaN NaN NaN NaN NaN 14 88.869492 19.654912 5.154367 NaN NaN NaN NaN NaN 15 93.372450 6.466570 8.845029 NaN NaN NaN NaN NaN 16 91.498781 41.205988 8.472586 NaN NaN NaN NaN NaN 17 79.184451 47.497753 1.573452 NaN NaN NaN NaN NaN 18 17.879287 40.157191 1.650949 NaN NaN NaN NaN NaN 19 55.955813 25.500096 8.444784 NaN NaN NaN NaN NaN 20 87.781751 41.823752 2.397870 NaN NaN NaN NaN NaN 21 99.886723 38.176172 8.347976 NaN NaN NaN NaN NaN 22 63.067959 23.440639 6.322398 NaN NaN NaN NaN NaN 23 76.859523 43.872364 8.661432 NaN NaN NaN NaN NaN 24 71.378277 39.847558 5.495700 NaN NaN NaN NaN NaN"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#average-age-at-infection-in-the-sir-model","title":"Average age at infection in the SIR model\u00b6","text":"<p>Continuing our investigation of the Susceptible-Infected-Recovered model, we will add demographics and investigate the behavior of the model in and around the endemic equilibrium.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I - \\mu I\\\\  \\dot{R} = \\gamma I - \\mu R $$</p> <p>Analysis of this system can be found in other sources (ref. Keeling/Rohani).  Setting the derivatives to zero and doing a bit of algebra gets you to the endemic equilbrium</p> <p>$$ (S^*, \\: I^*, \\: R^*) = (\\frac{1}{R_0}, \\:\\: \\frac{\\mu (R_0-1)}{\\beta}, \\: \\: 1-\\frac{1}{R_0} - \\frac{\\mu (R_0-1)}{\\beta}) \\\\  \\text{where} \\:\\: R_0 = \\frac{\\beta}{\\gamma + \\mu} $$</p> <p>An individual susceptible's mean time to infection will then be the inverse of the total force of infection, $\\beta I^*$. $$ \\tau_{S \\rightarrow I} = \\frac{1}{\\mu (R_0 -1)} $$</p> <p>The equation above is often also described as the average age at infection.  However, it is key to remember that the measured age at infection will be censored by non-disease deaths occurring at a rate $\\mu$.  You can work through the impact of this, but in the simple case of constant mortality, it turns out to exactly balance out the $-1$ in the above equation, and so our observed average age at infection will be $\\frac{1}{\\mu R_0}$.  Since the hazard is constant at equilibrium, this implies an exponential distribution:</p> <p>$$P(a | S-&gt;I) \\sim \\mu R_0 e^{-\\mu R_0 a}$$</p> <p>Alternatively, we can correct for the influence of mortality by observing the fraction of children who are susceptible at age A, which necessarily conditions on survival to age A.  This will look like the cumulative distribution of an exponential distributed according to the mean time to infection above:</p> <p>$$P(R | a) \\sim 1 - e^{(-a \\mu (R_0-1))}$$</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Because we are now measuring an equilibrium property of this system, we will have to burn in, with repeated infection importations to ensure that we establish an endemic equilibrium.  We also need to model a large enough population to sustain the infection (see Critical Community Size notebook).  The primary determinant of the critical community size is the duration of infection, so keeping this relatively long (2 months) prevents us from needing huge agent populations.  So, we construct a single-patch LASER model with fice components: <code>Births_ConstantPop</code>, <code>Susceptibility</code>, <code>Transmission</code>, <code>Infection</code>, and <code>Infect_Random_Agents</code>, a function that implements repeated importation for a fixed period of time.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.  As it stands, I am not actually explicitly tracking the recovered population, but I can check that $S_t = N_t - \\sum{\\Delta_I}$.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will sample a set of $(\\mu, \\gamma, R_0)$ pairs and confirm that both the age at infection and the fraction of susceptibles at a given age are well-described by exponential distributions and that the associated rate constant is as expected.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#future-work","title":"Future work\u00b6","text":"<p>The addition of an exposed compartment should not change this result (other than changing the relevant transition from S-&gt;E rather than S-&gt;I) and we should test this.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>As always, check that we haven't broken anything - S+I+R = N at all times.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#first-scientific-test-check","title":"First scientific test check\u00b6","text":"<p>As usual, we will test this on a single simulation instance and demonstrate the analysis, before moving on to testing over a range of input values. Here, we are interested in equilibrium behavior, so I first place a cut to exclude all infections that occur before day 10000. We then plot the data, an exponential distribution with the expected value of $\\frac{1}{R_0 \\mu}$, a best-fit exponential distribution to the data, and perform a KS test.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#second-scientific-test-check","title":"Second scientific test check\u00b6","text":"<p>As noted above, because of the censoring that mortality induces, the distributions of age at infection vs. fraction susceptible at a given age will both follow exponential behavior but with a slight difference in the mean of the distribution - for the fraction susceptible, that value will be $\\frac{1}{\\mu (R_0-1)}$.  We develop this second test below.</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#third-scientific-test","title":"Third scientific test\u00b6","text":"<p>As long as we are here, let's test that the age distribution of the population is correct.  With constant birth rate, equal to death rate, the population should have exponentially distributed ages with parameter $\\frac{1}{\\mu}$</p>"},{"location":"tutorials/notebooks/05_SIR_wbirths_age_distribution/#larger-test-suite","title":"Larger test suite\u00b6","text":"<p>OK, so now we are going to replicate the above for many values of R0 and cbr, as a scientific validity test.</p> <p>TODO: As written, this takes a long time.  That's because the space of random values being sampled occasionally produces models where the average age at infection is 30 years old, or so.  Correspondingly, those models take a long time to equilibrate so that the tests don't look terrible fail.  So as of right now, these run for 200 years to sidestep this.  Should instead restrict the range of values - higher cbrs and R0s - so that the average age at infection is consistently lower and we can get away with running for like 30-50 years instead.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/","title":"Intrinsic periodicity of the SIR system","text":"In\u00a0[1]: Copied! <pre>import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.ndimage import gaussian_filter1d\nfrom scipy.signal import find_peaks\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic import Infection\nfrom laser.generic import Model\nfrom laser.generic import Susceptibility\nfrom laser.generic import Transmission\nfrom laser.generic.importation import Infect_Random_Agents\nfrom laser.generic.utils import seed_infections_randomly\nfrom laser.generic.utils import set_initial_susceptibility_randomly\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import math  import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.ndimage import gaussian_filter1d from scipy.signal import find_peaks  import laser.core import laser.generic from laser.generic import Births_ConstantPop from laser.generic import Infection from laser.generic import Model from laser.generic import Susceptibility from laser.generic import Transmission from laser.generic.importation import Infect_Random_Agents from laser.generic.utils import seed_infections_randomly from laser.generic.utils import set_initial_susceptibility_randomly  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>np.__version__='2.3.5'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> <p>OK, in testing here, we run into a couple of challenges, and my training in spectral analysis is a bit old at this point.  Mainly, we're interested in relatively low-frequency signals relative to our vector length - periods that can be order a few years in a sequence of a few decades, so only a few oscillations.  Not impossible but tough Second is that there are lots of other signals that will probably settle down over time, but may not.  Lastly, there seem to be some windowing effects from the length of the vector itself. So some approaches to get arounds this: Try to start relatively close to equilibrium Use time-domain autocorrelation spectrum Instead of looking for the period of maximum power, specifically look for a peak in the vicinity of the expected period.</p> In\u00a0[2]: Copied! <pre>scenario = pd.DataFrame(data=[[\"homenode\", 2e6]], columns=[\"name\", \"population\"])\nparameters = PropertySet(\n    {\"seed\": 4, \"nticks\": 36500, \"verbose\": True, \"beta\": 0.4, \"inf_mean\": 12, \"cbr\": 45, \"importation_period\": 180, \"importation_count\": 3}\n)\n</pre> scenario = pd.DataFrame(data=[[\"homenode\", 2e6]], columns=[\"name\", \"population\"]) parameters = PropertySet(     {\"seed\": 4, \"nticks\": 36500, \"verbose\": True, \"beta\": 0.4, \"inf_mean\": 12, \"cbr\": 45, \"importation_period\": 180, \"importation_count\": 3} ) In\u00a0[3]: Copied! <pre>model = Model(scenario, parameters)\nmodel.components = [\n    Infect_Random_Agents,\n    Births_ConstantPop,\n    Susceptibility,\n    Infection,\n    Transmission,\n]\n\nseed_infections_randomly(model, ninfections=1)\nmodel.run()\nplt.plot(model.patches.cases)\n</pre> model = Model(scenario, parameters) model.components = [     Infect_Random_Agents,     Births_ConstantPop,     Susceptibility,     Infection,     Transmission, ]  seed_infections_randomly(model, ninfections=1) model.run() plt.plot(model.patches.cases) <pre>2025-11-19 22:07:25.128971: Creating the generic model\u2026\n</pre> <pre>Initializing the generic model with 1 patches\u2026\n</pre> <pre>2025-11-19 22:07:25.207184: Running the generic model for 36500 ticks\u2026\n</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\n</pre> <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[3], line 11\n      2 model.components = [\n      3     Infect_Random_Agents,\n      4     Births_ConstantPop,\n   (...)      7     Transmission,\n      8 ]\n     10 seed_infections_randomly(model, ninfections=1)\n---&gt; 11 model.run()\n     12 plt.plot(model.patches.cases)\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:313, in Births_ConstantPop.__call__(self, model, tick)\n    309     model.population.dob[indices] = tick  # set to current tick\n    310 model.population.state[indices] = 0\n    312 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 313     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    314 ).astype(np.uint32)\n    316 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    317     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    318 ).astype(np.uint32)\n    320 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    321     model.population.nodeid[indices],\n    322     weights=(\n   (...)    327     minlength=model.patches.populations.shape[1],\n    328 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[4]: Copied! <pre>model.patches.cases[10000:10010]\n</pre> model.patches.cases[10000:10010] Out[4]: <pre>array([[0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0]], dtype=uint32)</pre> In\u00a0[5]: Copied! <pre>cases = np.squeeze(model.patches.cases)\nsusc = np.squeeze(model.patches.susceptibility)\nrec = np.squeeze(model.patches.recovered)\ninc = np.squeeze(model.patches.incidence)\nbirths = np.squeeze(model.patches.births)\npops = np.squeeze(model.patches.populations)[:-1]\n\nprint(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all()))\n</pre> cases = np.squeeze(model.patches.cases) susc = np.squeeze(model.patches.susceptibility) rec = np.squeeze(model.patches.recovered) inc = np.squeeze(model.patches.incidence) births = np.squeeze(model.patches.births) pops = np.squeeze(model.patches.populations)[:-1]  print(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all())) <pre>S+I+R = N:  False\n</pre> In\u00a0[6]: Copied! <pre>mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nR0 = model.params.beta / (1 / model.params.inf_mean + mu)\nA = 1 / ((R0 - 1) * mu) / 365\nG = 1 / (mu + 1 / model.params.inf_mean) / 365\nT_exp = 2 * np.pi * np.sqrt(A * G)\n\n\ndef ID_freq_peakfinder(y0, T_exp, cutoff=18250, plot=False):\n    y = y0[cutoff:]\n    y = y - np.mean(y)\n    y = gaussian_filter1d(y, sigma=100)\n    peaks, _ = find_peaks(y, distance=T_exp * 365 / 2)\n    if plot:\n        plt.figure()\n        plt.plot(y, alpha=0.5)\n        plt.plot(peaks, y[peaks], \"x\")\n    return np.median(np.diff(peaks)) / 365\n\n\nT_obs_pf = ID_freq_peakfinder(np.squeeze(model.patches.cases), T_exp, plot=True)\n\n\ndef ID_freq_autocorr(y0, cutoff=18250):\n    # Compute the FFT\n    Y1 = np.fft.fft(y0[cutoff:] - np.mean(y0[cutoff:]))\n\n    # Compute the circular autocorrelation using the inverse FFT\n    circular_autocorr = np.fft.ifft(Y1 * np.conj(Y1)).real\n    # Plot only the positive frequency spectrum\n    peaks, _ = find_peaks(circular_autocorr, distance=300)\n    return peaks[0] / 365\n\n\nT_obs_fft = ID_freq_autocorr(np.squeeze(model.patches.cases))\n\nplt.text(0.05, 0.9, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes)\nplt.text(0.05, 0.85, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes)\nplt.text(0.05, 0.8, f\"T observed, FFT: {T_obs_fft:.2f} y\", transform=plt.gca().transAxes)\nplt.show()\n</pre> mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 R0 = model.params.beta / (1 / model.params.inf_mean + mu) A = 1 / ((R0 - 1) * mu) / 365 G = 1 / (mu + 1 / model.params.inf_mean) / 365 T_exp = 2 * np.pi * np.sqrt(A * G)   def ID_freq_peakfinder(y0, T_exp, cutoff=18250, plot=False):     y = y0[cutoff:]     y = y - np.mean(y)     y = gaussian_filter1d(y, sigma=100)     peaks, _ = find_peaks(y, distance=T_exp * 365 / 2)     if plot:         plt.figure()         plt.plot(y, alpha=0.5)         plt.plot(peaks, y[peaks], \"x\")     return np.median(np.diff(peaks)) / 365   T_obs_pf = ID_freq_peakfinder(np.squeeze(model.patches.cases), T_exp, plot=True)   def ID_freq_autocorr(y0, cutoff=18250):     # Compute the FFT     Y1 = np.fft.fft(y0[cutoff:] - np.mean(y0[cutoff:]))      # Compute the circular autocorrelation using the inverse FFT     circular_autocorr = np.fft.ifft(Y1 * np.conj(Y1)).real     # Plot only the positive frequency spectrum     peaks, _ = find_peaks(circular_autocorr, distance=300)     return peaks[0] / 365   T_obs_fft = ID_freq_autocorr(np.squeeze(model.patches.cases))  plt.text(0.05, 0.9, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes) plt.text(0.05, 0.85, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes) plt.text(0.05, 0.8, f\"T observed, FFT: {T_obs_fft:.2f} y\", transform=plt.gca().transAxes) plt.show() <pre>/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/_core/fromnumeric.py:3860: RuntimeWarning: Mean of empty slice.\n  return _methods._mean(a, axis=axis, dtype=dtype,\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/_core/_methods.py:144: RuntimeWarning: invalid value encountered in scalar divide\n  ret = ret.dtype.type(ret / rcount)\n</pre> <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[6], line 34\n     30     peaks, _ = find_peaks(circular_autocorr, distance=300)\n     31     return peaks[0] / 365\n---&gt; 34 T_obs_fft = ID_freq_autocorr(np.squeeze(model.patches.cases))\n     36 plt.text(0.05, 0.9, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes)\n     37 plt.text(0.05, 0.85, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes)\n\nCell In[6], line 31, in ID_freq_autocorr(y0, cutoff)\n     29 # Plot only the positive frequency spectrum\n     30 peaks, _ = find_peaks(circular_autocorr, distance=300)\n---&gt; 31 return peaks[0] / 365\n\nIndexError: index 0 is out of bounds for axis 0 with size 0</pre> In\u00a0[7]: Copied! <pre># import os\n\nnsims = 10\nnticks = 36500\ncbrs = 30 + 50 * np.random.rand(nsims)\ninf_means = 5 + 45 * np.random.rand(nsims)\nR0s = 2.5 + 7.5 * np.random.rand(nsims)\nmu = [((1 + cbr / 1000) ** (1 / 365) - 1) for cbr in cbrs]\nA = [1 / ((R0 - 1) * mu) / 365 for R0, mu in zip(R0s, mu)]\nG = [1 / (mu + 1 / inf_mean) / 365 for mu, inf_mean in zip(mu, inf_means)]\nT_exp = [2 * math.pi * np.sqrt(A * G) for A, G in zip(A, G)]\nmycases = np.zeros((nsims, nticks))\nparams_df = pd.DataFrame(\n    {\n        \"cbr\": cbrs,\n        \"inf_mean\": inf_means,\n        \"R0\": R0s,\n        \"A\": A,\n        \"G\": G,\n        \"T_exp\": T_exp,\n    }\n)\ni = 0\nfor cbr, inf_mean, R0 in zip(cbrs, inf_means, R0s):\n    mu = (1 + cbr / 1000) ** (1 / 365) - 1\n    parameters = PropertySet(\n        {\n            \"seed\": 2,\n            \"nticks\": 36500,\n            \"verbose\": True,\n            \"beta\": R0 * (mu + 1 / inf_mean),\n            \"inf_mean\": inf_mean,\n            \"cbr\": cbr,\n            \"importation_period\": 180,\n            \"importation_count\": 3,\n        }\n    )\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Random_Agents,\n    ]\n\n    set_initial_susceptibility_randomly(model, 1 / R0 + 0.02)\n    seed_infections_randomly(model, ninfections=1)\n    model.run()\n    plt.plot(model.patches.cases)\n    mycases[i] = np.squeeze(model.patches.cases)\n    i = i + 1\n\n# output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"periodicity\"))\n# os.makedirs(output_folder, exist_ok=True)\n# params_df.to_csv(os.path.join(output_folder, \"params_df.csv\"), index=False)\n# np.save(os.path.join(output_folder, \"mycases.npy\"), mycases)\n</pre> # import os  nsims = 10 nticks = 36500 cbrs = 30 + 50 * np.random.rand(nsims) inf_means = 5 + 45 * np.random.rand(nsims) R0s = 2.5 + 7.5 * np.random.rand(nsims) mu = [((1 + cbr / 1000) ** (1 / 365) - 1) for cbr in cbrs] A = [1 / ((R0 - 1) * mu) / 365 for R0, mu in zip(R0s, mu)] G = [1 / (mu + 1 / inf_mean) / 365 for mu, inf_mean in zip(mu, inf_means)] T_exp = [2 * math.pi * np.sqrt(A * G) for A, G in zip(A, G)] mycases = np.zeros((nsims, nticks)) params_df = pd.DataFrame(     {         \"cbr\": cbrs,         \"inf_mean\": inf_means,         \"R0\": R0s,         \"A\": A,         \"G\": G,         \"T_exp\": T_exp,     } ) i = 0 for cbr, inf_mean, R0 in zip(cbrs, inf_means, R0s):     mu = (1 + cbr / 1000) ** (1 / 365) - 1     parameters = PropertySet(         {             \"seed\": 2,             \"nticks\": 36500,             \"verbose\": True,             \"beta\": R0 * (mu + 1 / inf_mean),             \"inf_mean\": inf_mean,             \"cbr\": cbr,             \"importation_period\": 180,             \"importation_count\": 3,         }     )     model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Random_Agents,     ]      set_initial_susceptibility_randomly(model, 1 / R0 + 0.02)     seed_infections_randomly(model, ninfections=1)     model.run()     plt.plot(model.patches.cases)     mycases[i] = np.squeeze(model.patches.cases)     i = i + 1  # output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"periodicity\")) # os.makedirs(output_folder, exist_ok=True) # params_df.to_csv(os.path.join(output_folder, \"params_df.csv\"), index=False) # np.save(os.path.join(output_folder, \"mycases.npy\"), mycases) <pre>2025-11-19 22:07:25.726683: Creating the generic model\u2026\n</pre> <pre>Initializing the generic model with 1 patches\u2026\n</pre> <pre>2025-11-19 22:07:25.813275: Running the generic model for 36500 ticks\u2026\n</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\n</pre> <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[7], line 49\n     47 set_initial_susceptibility_randomly(model, 1 / R0 + 0.02)\n     48 seed_infections_randomly(model, ninfections=1)\n---&gt; 49 model.run()\n     50 plt.plot(model.patches.cases)\n     51 mycases[i] = np.squeeze(model.patches.cases)\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:313, in Births_ConstantPop.__call__(self, model, tick)\n    309     model.population.dob[indices] = tick  # set to current tick\n    310 model.population.state[indices] = 0\n    312 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 313     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    314 ).astype(np.uint32)\n    316 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    317     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    318 ).astype(np.uint32)\n    320 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    321     model.population.nodeid[indices],\n    322     weights=(\n   (...)    327     minlength=model.patches.populations.shape[1],\n    328 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[8]: Copied! <pre>params_df[\"T_obs_peakfinder\"] = np.nan\nparams_df[\"T_obs_autocorr\"] = np.nan\n\nfor i in range(mycases.shape[0]):\n    params_df.loc[i, \"T_obs_peakfinder\"] = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=False)\n    params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :]))\n</pre> params_df[\"T_obs_peakfinder\"] = np.nan params_df[\"T_obs_autocorr\"] = np.nan  for i in range(mycases.shape[0]):     params_df.loc[i, \"T_obs_peakfinder\"] = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=False)     params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :])) <pre>/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/_core/fromnumeric.py:3860: RuntimeWarning: Mean of empty slice.\n  return _methods._mean(a, axis=axis, dtype=dtype,\n/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/_core/_methods.py:144: RuntimeWarning: invalid value encountered in scalar divide\n  ret = ret.dtype.type(ret / rcount)\n</pre> <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[8], line 6\n      4 for i in range(mycases.shape[0]):\n      5     params_df.loc[i, \"T_obs_peakfinder\"] = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=False)\n----&gt; 6     params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :]))\n\nCell In[6], line 31, in ID_freq_autocorr(y0, cutoff)\n     29 # Plot only the positive frequency spectrum\n     30 peaks, _ = find_peaks(circular_autocorr, distance=300)\n---&gt; 31 return peaks[0] / 365\n\nIndexError: index 0 is out of bounds for axis 0 with size 0</pre> In\u00a0[9]: Copied! <pre>params_df\n</pre> params_df Out[9]: cbr inf_mean R0 A G T_exp T_obs_peakfinder T_obs_autocorr 0 78.316126 47.646585 2.683894 7.875264 0.129266 6.339497 NaN NaN 1 39.831444 42.956050 3.782967 9.199236 0.117149 6.522672 NaN NaN 2 33.699968 38.245820 9.336544 3.618944 0.104420 3.862455 NaN NaN 3 31.004992 6.626953 4.586971 9.129974 0.018146 2.557436 NaN NaN 4 71.504780 45.480356 4.480147 4.160156 0.123540 4.504425 NaN NaN 5 65.847199 12.597417 5.757625 3.295760 0.034438 2.116774 NaN NaN 6 53.265700 25.198810 7.165544 3.125128 0.068791 2.913270 NaN NaN 7 62.940923 27.778342 5.920736 3.329067 0.075753 3.155305 NaN NaN 8 36.336657 46.437177 5.837691 5.791207 0.126650 5.381050 NaN NaN 9 56.508673 47.526219 6.532047 3.288195 0.129283 4.096661 NaN NaN In\u00a0[10]: Copied! <pre>plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder\"], \"o\")\n</pre> plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder\"], \"o\") Out[10]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f4390efccb0&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> Out[\u00a0]: <pre>[&lt;matplotlib.lines.Line2D at 0x32d8046d0&gt;,\n &lt;matplotlib.lines.Line2D at 0x30d3108d0&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d8b50&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d8ed0&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9110&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9410&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9790&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9bd0&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9fd0&gt;,\n &lt;matplotlib.lines.Line2D at 0x30d2da4d0&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#intrinsic-periodicity-of-the-sir-system","title":"Intrinsic periodicity of the SIR system\u00b6","text":"<p>Continuing our investigation of the Susceptible-Infected-Recovered system,</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I - \\mu I\\\\  \\dot{R} = \\gamma I - \\mu R $$</p> <p>With non-trivial endemic equilbrium</p> <p>$$ (S^*, \\: I^*, \\: R^*) = (\\frac{1}{R_0}, \\:\\: \\frac{\\mu (R_0-1)}{\\beta}, \\: \\: 1-\\frac{1}{R_0} - \\frac{\\mu (R_0-1)}{\\beta}) \\\\  \\text{where} \\:\\: R_0 = \\frac{\\beta}{\\gamma + \\mu} $$</p> <p>General analysis of a system's stability of and approach to equilibria is beyond the scope of this notebook, and detailed discussions are available elsewhere (e.g., Keeling/Rohani Box 2.4).  In brief, one constructs the Jacobian of the system at the equilibrium points and computes its eigenvalues.  If all eigenvalues have negative real component, then the equilibrium is stable; if the dominant eigenvalues are complex conjugates, then system approaches equilibrium via damped oscillations, with damping constant equal to the real component and frequency equal to the imaginary component. This is the case for the SIR system around the non-trivial ($R_0 \\gt 1$) equilibrium, with dominant eigenvalues:</p> <p>$$ \\Lambda = -\\frac{\\mu R_0}{2} \\pm \\frac{\\sqrt{\\mu^2 R_0^2 - \\frac{4}{A G}}}{2} \\\\ \\text{where} \\:\\: A = \\frac{1}{\\mu (R_0 -1)} and G = \\frac{1}{\\mu + \\gamma}  $$</p> <p>In general, $\\mu^2 R_0^2$ is quite small, and the intrinsic periodicity of the system is $T \\approx 2 \\pi \\sqrt{A G}$.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>The model is contructed as in notebook 05.  As again, we are looking at behavior around the endemic equilibrium, the same considerations of large-ish populations and long simulations apply here.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.  As it stands, I am not actually explicitly tracking the recovered population, but I can check that $S_t = N_t - \\sum{\\Delta_I}$.</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will sample a set of $(\\mu, \\gamma, R_0)$ tuplets and confirm that the periodicity is</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#future-work","title":"Future work\u00b6","text":"<p>The addition of an exposed compartment with rate constant $\\sigma$ should change this result, by changing the generation time $G$ to $\\frac{1}{\\mu + \\gamma} + \\frac{1}{\\mu + \\sigma}$</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>As always, check that we haven't broken anything - S+I+R = N at all times</p>"},{"location":"tutorials/notebooks/06_SIR_wbirths_natural_periodicity/#larger-test-suite","title":"Larger test suite\u00b6","text":"<p>OK, so now we are going to replicate the above test for many values of R0 and cbr, as a scientific validity test.</p> <p>TODO: As written, this takes a long time.  That's because the space of random values being sampled occasionally produces models with long equilibration times and long periodicities.  So as of right now, these run for 100 years to sidestep this.  Should instead restrict the range of values - higher cbrs and R0s - so that the average age at infection is consistently lower and we can get away with running for like 30-50 years instead.</p>"},{"location":"tutorials/notebooks/07_SIR_CCS/","title":"Exploring the critical community size of an SIR model","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nimport matplotlib.pyplot as plt\nimport os\nfrom scipy.optimize import fsolve\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Model\nfrom laser.generic import Infection\nfrom laser.generic import Susceptibility\nfrom laser.generic import Transmission\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic.importation import Infect_Agents_In_Patch\n\nfrom laser.generic.utils import set_initial_susceptibility_in_patch\nfrom laser.generic.utils import seed_infections_in_patch\n\n%load_ext line_profiler\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd from laser.core.propertyset import PropertySet import matplotlib.pyplot as plt import os from scipy.optimize import fsolve  import laser.core import laser.generic from laser.generic import Model from laser.generic import Infection from laser.generic import Susceptibility from laser.generic import Transmission from laser.generic import Births_ConstantPop from laser.generic.importation import Infect_Agents_In_Patch  from laser.generic.utils import set_initial_susceptibility_in_patch from laser.generic.utils import seed_infections_in_patch  %load_ext line_profiler  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 20\n     17 from laser.generic.utils import set_initial_susceptibility_in_patch\n     18 from laser.generic.utils import seed_infections_in_patch\n---&gt; 20 get_ipython().run_line_magic('load_ext', 'line_profiler')\n     22 print(f\"{np.__version__=}\")\n     23 print(f\"{laser.core.__version__=}\")\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:2504, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2502     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2503 with self.builtin_trap:\n-&gt; 2504     result = fn(*args, **kwargs)\n   2506 # The code below prevents the output from being displayed\n   2507 # when using magics with decorator @output_can_be_silenced\n   2508 # when the last Python token in the expression is a ';'.\n   2509 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/magics/extension.py:33, in ExtensionMagics.load_ext(self, module_str)\n     31 if not module_str:\n     32     raise UsageError('Missing module name.')\n---&gt; 33 res = self.shell.extension_manager.load_extension(module_str)\n     35 if res == 'already loaded':\n     36     print(\"The %s extension is already loaded. To reload it, use:\" % module_str)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/extensions.py:62, in ExtensionManager.load_extension(self, module_str)\n     55 \"\"\"Load an IPython extension by its module name.\n     56 \n     57 Returns the string \"already loaded\" if the extension is already loaded,\n     58 \"no load function\" if the module doesn't have a load_ipython_extension\n     59 function, or None if it succeeded.\n     60 \"\"\"\n     61 try:\n---&gt; 62     return self._load_extension(module_str)\n     63 except ModuleNotFoundError:\n     64     if module_str in BUILTINS_EXTS:\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/extensions.py:77, in ExtensionManager._load_extension(self, module_str)\n     75 with self.shell.builtin_trap:\n     76     if module_str not in sys.modules:\n---&gt; 77         mod = import_module(module_str)\n     78     mod = sys.modules[module_str]\n     79     if self._call_load_ipython_extension(mod):\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/importlib/__init__.py:90, in import_module(name, package)\n     88             break\n     89         level += 1\n---&gt; 90 return _bootstrap._gcd_import(name[level:], package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1387, in _gcd_import(name, package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1360, in _find_and_load(name, import_)\n\nFile &lt;frozen importlib._bootstrap&gt;:1324, in _find_and_load_unlocked(name, import_)\n\nModuleNotFoundError: No module named 'line_profiler'</pre> In\u00a0[2]: Copied! <pre>%%capture\n\nnticks = 50 * 365\nnpatches = 61\npops = np.logspace(3, 6, npatches)\nscenario = pd.DataFrame({\"name\": [str(i) for i in range(npatches)], \"population\": pops})\n\n# np.random.seed(5)  # Ensure reproducibility\nnsims = 200\nR0_samples = np.random.uniform(3, 16, nsims)\ninfmean_samples = 5 + np.random.gamma(2, 10, nsims)\ncbr_samples = 10 + np.random.gamma(2, 20, nsims)\ni = 0\noutputs = np.zeros((nsims, nticks, npatches))\n# Create a folder to store the outputs\noutput_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\"))\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\nfor R0, infmean, cbr in zip(R0_samples, infmean_samples, cbr_samples):\n    parameters = PropertySet(\n        {\n            \"seed\": np.random.randint(0, 1000000),\n            \"nticks\": nticks,\n            \"verbose\": True,\n            \"beta\": R0 / infmean,\n            \"inf_mean\": infmean,\n            \"cbr\": cbr,\n            \"importation_period\": 180,\n            \"importation_end\": 20 * 365,\n        }\n    )\n\n    mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Agents_In_Patch,\n    ]\n\n    # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch\n    # Want to see how connectivity drives correlation over time.\n    for j in range(npatches):\n        set_initial_susceptibility_in_patch(model, j, 1 / R0 + 0.1 / R0 * np.random.normal())\n\n    model.run()\n    outputs[i, :, :] = model.patches.cases\n    np.save(f\"{output_folder}/CCSSIRoutputs_{i}.npy\", outputs[i, :, :])\n    i += 1\n</pre> %%capture  nticks = 50 * 365 npatches = 61 pops = np.logspace(3, 6, npatches) scenario = pd.DataFrame({\"name\": [str(i) for i in range(npatches)], \"population\": pops})  # np.random.seed(5)  # Ensure reproducibility nsims = 200 R0_samples = np.random.uniform(3, 16, nsims) infmean_samples = 5 + np.random.gamma(2, 10, nsims) cbr_samples = 10 + np.random.gamma(2, 20, nsims) i = 0 outputs = np.zeros((nsims, nticks, npatches)) # Create a folder to store the outputs output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\")) if not os.path.exists(output_folder):     os.makedirs(output_folder) for R0, infmean, cbr in zip(R0_samples, infmean_samples, cbr_samples):     parameters = PropertySet(         {             \"seed\": np.random.randint(0, 1000000),             \"nticks\": nticks,             \"verbose\": True,             \"beta\": R0 / infmean,             \"inf_mean\": infmean,             \"cbr\": cbr,             \"importation_period\": 180,             \"importation_end\": 20 * 365,         }     )      mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Agents_In_Patch,     ]      # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch     # Want to see how connectivity drives correlation over time.     for j in range(npatches):         set_initial_susceptibility_in_patch(model, j, 1 / R0 + 0.1 / R0 * np.random.normal())      model.run()     outputs[i, :, :] = model.patches.cases     np.save(f\"{output_folder}/CCSSIRoutputs_{i}.npy\", outputs[i, :, :])     i += 1 <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[2], line 47\n     44 for j in range(npatches):\n     45     set_initial_susceptibility_in_patch(model, j, 1 / R0 + 0.1 / R0 * np.random.normal())\n---&gt; 47 model.run()\n     48 outputs[i, :, :] = model.patches.cases\n     49 np.save(f\"{output_folder}/CCSSIRoutputs_{i}.npy\", outputs[i, :, :])\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:313, in Births_ConstantPop.__call__(self, model, tick)\n    309     model.population.dob[indices] = tick  # set to current tick\n    310 model.population.state[indices] = 0\n    312 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 313     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    314 ).astype(np.uint32)\n    316 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    317     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    318 ).astype(np.uint32)\n    320 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    321     model.population.nodeid[indices],\n    322     weights=(\n   (...)    327     minlength=model.patches.populations.shape[1],\n    328 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[3]: Copied! <pre>params_df = pd.DataFrame({\n    'R0': R0_samples,\n    'infmean': infmean_samples,\n    'cbr': cbr_samples\n})\n\nparams_df.to_csv(os.path.join(output_folder, 'params.csv'), index = False)\n</pre> params_df = pd.DataFrame({     'R0': R0_samples,     'infmean': infmean_samples,     'cbr': cbr_samples })  params_df.to_csv(os.path.join(output_folder, 'params.csv'), index = False) In\u00a0[4]: Copied! <pre>plt.imshow(outputs[26, 7300:, :].T / pops[:, np.newaxis], aspect=\"auto\", origin=\"lower\")\nplt.colorbar(label=\"Cases\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Patch\")\nplt.yticks(range(0, npatches, 10), np.log10(pops[::10]))\nplt.title(\"Infection spread over time across patches\")\nplt.show()\n</pre> plt.imshow(outputs[26, 7300:, :].T / pops[:, np.newaxis], aspect=\"auto\", origin=\"lower\") plt.colorbar(label=\"Cases\") plt.xlabel(\"Time (days)\") plt.ylabel(\"Patch\") plt.yticks(range(0, npatches, 10), np.log10(pops[::10])) plt.title(\"Infection spread over time across patches\") plt.show() In\u00a0[5]: Copied! <pre>output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\"))\nparams_df = pd.read_csv(os.path.join(output_folder, \"params.csv\"))\n\noutputs = []\nnsims = 200\nnpatches = 61\npops = np.logspace(3, 6, npatches)\n\nfor i in range(nsims):\n    output_file = os.path.join(output_folder, f\"CCSSIRoutputs_{i}.npy\")\n    outputs.append(np.load(output_file))\n\noutputs = np.array(outputs)\n</pre> output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\")) params_df = pd.read_csv(os.path.join(output_folder, \"params.csv\"))  outputs = [] nsims = 200 npatches = 61 pops = np.logspace(3, 6, npatches)  for i in range(nsims):     output_file = os.path.join(output_folder, f\"CCSSIRoutputs_{i}.npy\")     outputs.append(np.load(output_file))  outputs = np.array(outputs) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[5], line 11\n      9 for i in range(nsims):\n     10     output_file = os.path.join(output_folder, f\"CCSSIRoutputs_{i}.npy\")\n---&gt; 11     outputs.append(np.load(output_file))\n     13 outputs = np.array(outputs)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/lib/_npyio_impl.py:454, in load(file, mmap_mode, allow_pickle, fix_imports, encoding, max_header_size)\n    452     own_fid = False\n    453 else:\n--&gt; 454     fid = stack.enter_context(open(os.fspath(file), \"rb\"))\n    455     own_fid = True\n    457 # Code to distinguish from NumPy binary files and pickles.\n\nFileNotFoundError: [Errno 2] No such file or directory: '/home/runner/work/laser-generic/laser-generic/docs/laser-generic-outputs/CCSSIRoutputs2/CCSSIRoutputs_0.npy'</pre> In\u00a0[6]: Copied! <pre>CCS1 = []\nCCS2 = []\n\nfor sim in range(nsims):\n    end_output = outputs[sim, -1, :]\n    zero_pops = pops[end_output == 0]\n    nonzero_pops = pops[end_output != 0]\n\n    if len(zero_pops) &gt; 0:\n        CCS2.append(np.max(zero_pops))\n    else:\n        CCS2.append(None)\n\n    if len(nonzero_pops) &gt; 0:\n        CCS1.append(np.min(nonzero_pops))\n    else:\n        CCS1.append(None)\n\nresults_df = pd.DataFrame({\"largest_zero_pop\": CCS2, \"smallest_nonzero_pop\": CCS1})\n\nprint(results_df)\n</pre> CCS1 = [] CCS2 = []  for sim in range(nsims):     end_output = outputs[sim, -1, :]     zero_pops = pops[end_output == 0]     nonzero_pops = pops[end_output != 0]      if len(zero_pops) &gt; 0:         CCS2.append(np.max(zero_pops))     else:         CCS2.append(None)      if len(nonzero_pops) &gt; 0:         CCS1.append(np.min(nonzero_pops))     else:         CCS1.append(None)  results_df = pd.DataFrame({\"largest_zero_pop\": CCS2, \"smallest_nonzero_pop\": CCS1})  print(results_df) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[6], line 5\n      2 CCS2 = []\n      4 for sim in range(nsims):\n----&gt; 5     end_output = outputs[sim, -1, :]\n      6     zero_pops = pops[end_output == 0]\n      7     nonzero_pops = pops[end_output != 0]\n\nTypeError: list indices must be integers or slices, not tuple</pre> In\u00a0[7]: Copied! <pre>fig, axs = plt.subplots(3, 2, figsize=(15, 15))\n\n# Plot largest_zero_pop against R0, infmean, and cbr\naxs[0, 0].scatter(params_df[\"R0\"], results_df[\"largest_zero_pop\"])\naxs[0, 0].set_xlabel(\"R0\")\naxs[0, 0].set_ylabel(\"Largest Zero Pop\")\naxs[0, 0].set_title(\"Largest Zero Pop vs R0\")\naxs[0, 0].set_yscale(\"log\")\n\naxs[1, 0].scatter(params_df[\"infmean\"], results_df[\"largest_zero_pop\"])\naxs[1, 0].set_xlabel(\"Infectious Mean Period\")\naxs[1, 0].set_ylabel(\"Largest Zero Pop\")\naxs[1, 0].set_title(\"Largest Zero Pop vs Infectious Mean Period\")\naxs[1, 0].set_yscale(\"log\")\n\naxs[2, 0].scatter(params_df[\"cbr\"], results_df[\"largest_zero_pop\"])\naxs[2, 0].set_xlabel(\"Contact Birth Rate\")\naxs[2, 0].set_ylabel(\"Largest Zero Pop\")\naxs[2, 0].set_title(\"Largest Zero Pop vs Contact Birth Rate\")\naxs[2, 0].set_yscale(\"log\")\n\n# Plot smallest_nonzero_pop against R0, infmean, and cbr\naxs[0, 1].scatter(params_df[\"R0\"], results_df[\"smallest_nonzero_pop\"])\naxs[0, 1].set_xlabel(\"R0\")\naxs[0, 1].set_ylabel(\"Smallest Nonzero Pop\")\naxs[0, 1].set_title(\"Smallest Nonzero Pop vs R0\")\naxs[0, 1].set_yscale(\"log\")\n\naxs[1, 1].scatter(params_df[\"infmean\"], results_df[\"smallest_nonzero_pop\"])\naxs[1, 1].set_xlabel(\"Infectious Mean Period\")\naxs[1, 1].set_ylabel(\"Smallest Nonzero Pop\")\naxs[1, 1].set_title(\"Smallest Nonzero Pop vs Infectious Mean Period\")\naxs[1, 1].set_yscale(\"log\")\n\naxs[2, 1].scatter(params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"])\naxs[2, 1].set_xlabel(\"Contact Birth Rate\")\naxs[2, 1].set_ylabel(\"Smallest Nonzero Pop\")\naxs[2, 1].set_title(\"Smallest Nonzero Pop vs Contact Birth Rate\")\naxs[2, 1].set_yscale(\"log\")\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axs = plt.subplots(3, 2, figsize=(15, 15))  # Plot largest_zero_pop against R0, infmean, and cbr axs[0, 0].scatter(params_df[\"R0\"], results_df[\"largest_zero_pop\"]) axs[0, 0].set_xlabel(\"R0\") axs[0, 0].set_ylabel(\"Largest Zero Pop\") axs[0, 0].set_title(\"Largest Zero Pop vs R0\") axs[0, 0].set_yscale(\"log\")  axs[1, 0].scatter(params_df[\"infmean\"], results_df[\"largest_zero_pop\"]) axs[1, 0].set_xlabel(\"Infectious Mean Period\") axs[1, 0].set_ylabel(\"Largest Zero Pop\") axs[1, 0].set_title(\"Largest Zero Pop vs Infectious Mean Period\") axs[1, 0].set_yscale(\"log\")  axs[2, 0].scatter(params_df[\"cbr\"], results_df[\"largest_zero_pop\"]) axs[2, 0].set_xlabel(\"Contact Birth Rate\") axs[2, 0].set_ylabel(\"Largest Zero Pop\") axs[2, 0].set_title(\"Largest Zero Pop vs Contact Birth Rate\") axs[2, 0].set_yscale(\"log\")  # Plot smallest_nonzero_pop against R0, infmean, and cbr axs[0, 1].scatter(params_df[\"R0\"], results_df[\"smallest_nonzero_pop\"]) axs[0, 1].set_xlabel(\"R0\") axs[0, 1].set_ylabel(\"Smallest Nonzero Pop\") axs[0, 1].set_title(\"Smallest Nonzero Pop vs R0\") axs[0, 1].set_yscale(\"log\")  axs[1, 1].scatter(params_df[\"infmean\"], results_df[\"smallest_nonzero_pop\"]) axs[1, 1].set_xlabel(\"Infectious Mean Period\") axs[1, 1].set_ylabel(\"Smallest Nonzero Pop\") axs[1, 1].set_title(\"Smallest Nonzero Pop vs Infectious Mean Period\") axs[1, 1].set_yscale(\"log\")  axs[2, 1].scatter(params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"]) axs[2, 1].set_xlabel(\"Contact Birth Rate\") axs[2, 1].set_ylabel(\"Smallest Nonzero Pop\") axs[2, 1].set_title(\"Smallest Nonzero Pop vs Contact Birth Rate\") axs[2, 1].set_yscale(\"log\")  plt.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 4\n      1 fig, axs = plt.subplots(3, 2, figsize=(15, 15))\n      3 # Plot largest_zero_pop against R0, infmean, and cbr\n----&gt; 4 axs[0, 0].scatter(params_df[\"R0\"], results_df[\"largest_zero_pop\"])\n      5 axs[0, 0].set_xlabel(\"R0\")\n      6 axs[0, 0].set_ylabel(\"Largest Zero Pop\")\n\nNameError: name 'results_df' is not defined</pre> In\u00a0[8]: Copied! <pre>from mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure(figsize=(14, 7))\n\n# Surface plot for largest_zero_pop\nax1 = fig.add_subplot(121, projection=\"3d\")\nax1.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"largest_zero_pop\"], cmap=\"viridis\")\nax1.set_xlabel(\"Infectious Mean Period\")\nax1.set_ylabel(\"Contact Birth Rate\")\nax1.set_zlabel(\"Largest Zero Pop\")\nax1.set_zscale(\"log\")\n\nax1.set_title(\"Largest Zero Pop vs Infectious Mean Period and Contact Birth Rate\")\n\n# Surface plot for smallest_nonzero_pop\nax2 = fig.add_subplot(122, projection=\"3d\")\nax2.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"], cmap=\"viridis\")\nax2.set_xlabel(\"Infectious Mean Period\")\nax2.set_ylabel(\"Contact Birth Rate\")\nax2.set_zlabel(\"Smallest Nonzero Pop\")\nax2.set_title(\"Smallest Nonzero Pop vs Infectious Mean Period and Contact Birth Rate\")\nax2.set_zscale(\"log\")\nplt.tight_layout()\nplt.show()\n</pre> from mpl_toolkits.mplot3d import Axes3D  fig = plt.figure(figsize=(14, 7))  # Surface plot for largest_zero_pop ax1 = fig.add_subplot(121, projection=\"3d\") ax1.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"largest_zero_pop\"], cmap=\"viridis\") ax1.set_xlabel(\"Infectious Mean Period\") ax1.set_ylabel(\"Contact Birth Rate\") ax1.set_zlabel(\"Largest Zero Pop\") ax1.set_zscale(\"log\")  ax1.set_title(\"Largest Zero Pop vs Infectious Mean Period and Contact Birth Rate\")  # Surface plot for smallest_nonzero_pop ax2 = fig.add_subplot(122, projection=\"3d\") ax2.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"], cmap=\"viridis\") ax2.set_xlabel(\"Infectious Mean Period\") ax2.set_ylabel(\"Contact Birth Rate\") ax2.set_zlabel(\"Smallest Nonzero Pop\") ax2.set_title(\"Smallest Nonzero Pop vs Infectious Mean Period and Contact Birth Rate\") ax2.set_zscale(\"log\") plt.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 7\n      5 # Surface plot for largest_zero_pop\n      6 ax1 = fig.add_subplot(121, projection=\"3d\")\n----&gt; 7 ax1.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"largest_zero_pop\"], cmap=\"viridis\")\n      8 ax1.set_xlabel(\"Infectious Mean Period\")\n      9 ax1.set_ylabel(\"Contact Birth Rate\")\n\nNameError: name 'results_df' is not defined</pre> In\u00a0[9]: Copied! <pre># from scipy.optimize import curve_fit\n\n# # Calculate alpha\n# alpha = params_df['infmean'] * params_df['cbr']\n# R0 = params_df['R0']\n\n# # Define the fitting function\n# def fitting_function(alpha, R0, constant, a, b, c):\n#     return constant * alpha**a * (R0)**b * (R0-1)**c\n\n# # Prepare the data for fitting'\n# # Drop NA values from smallest_nonzero_pop and corresponding entries from alpha and R0\n# valid_indices = ~results_df['smallest_nonzero_pop'].isna()\n# alpha_values = alpha[valid_indices].values\n# R0_values = params_df['R0'][valid_indices].values\n# smallest_nonzero_pop_values = results_df['smallest_nonzero_pop'][valid_indices].values\n\n\n# # Fit the function to the data\n# popt, pcov = curve_fit(lambda alpha, constant, a, b, c: fitting_function(alpha, R0_values, constant, a, b, c), alpha_values, smallest_nonzero_pop_values)\n\n# # Extract the optimal parameters\n# constant_opt, a_opt, b_opt, c_opt = popt\nprint(f\"Optimal parameters: constant = {constant_opt}, a = {a_opt}, b = {b_opt}\")\n# # Plot smallest_nonzero_pop against alpha\n# plt.figure()\n\n# # Plot the best fit line\n# #\n# # Create a meshgrid for alpha and R0 values\n# alpha_fit = np.linspace(min(alpha_values), max(alpha_values), 100)\n# R0_fit = np.linspace(min(R0_values), max(R0_values), 100)\n# alpha_fit, R0_fit = np.meshgrid(alpha_fit, R0_fit)\n\n# # Calculate the best fit surface\n# best_fit_surface = fitting_function(alpha_fit, R0_fit, constant_opt, a_opt, b_opt)\n\n# Plot the best fit surface\nfig = plt.figure(figsize=(14, 7))\nax = fig.add_subplot(111, projection=\"3d\")\n\n# Calculate 1/alpha\ninv_alpha_fit = 1 / alpha_fit\ninv_alpha_values = 1 / alpha_values\n\n# Plot the best fit surface\nax.plot_surface(inv_alpha_fit, R0_fit, np.log10(best_fit_surface), cmap=\"viridis\", alpha=0.7)\n\n# Scatter the real values for comparison\nax.scatter(inv_alpha_values, R0_values, np.log10(smallest_nonzero_pop_values), color=\"red\", label=\"Real Values\")\n\nax.set_xlabel(\"1/Alpha (1/(inf_mean * cbr))\")\nax.set_ylabel(\"R0\")\nax.set_zlabel(\"Log(Smallest Nonzero Pop)\")\nax.set_title(\"Best Fit Surface and Real Values\")\n\n# Add the best fit equation as a textbox\nequation_text = f\"Best fit: y = {constant_opt:.2e} * alpha^{a_opt:.2f} * (R0/(R0-1))^{b_opt:.2f}\"\n# plt.text(0.05, 0.95, equation_text, transform=plt.gca().transAxes, fontsize=12, verticalalignment='top', bbox=dict(facecolor='white', alpha=0.5))\n\nplt.tight_layout()\n# Rotate the camera for a better viewing angle\nax.view_init(elev=20, azim=255)\nplt.show()\n</pre> # from scipy.optimize import curve_fit  # # Calculate alpha # alpha = params_df['infmean'] * params_df['cbr'] # R0 = params_df['R0']  # # Define the fitting function # def fitting_function(alpha, R0, constant, a, b, c): #     return constant * alpha**a * (R0)**b * (R0-1)**c  # # Prepare the data for fitting' # # Drop NA values from smallest_nonzero_pop and corresponding entries from alpha and R0 # valid_indices = ~results_df['smallest_nonzero_pop'].isna() # alpha_values = alpha[valid_indices].values # R0_values = params_df['R0'][valid_indices].values # smallest_nonzero_pop_values = results_df['smallest_nonzero_pop'][valid_indices].values   # # Fit the function to the data # popt, pcov = curve_fit(lambda alpha, constant, a, b, c: fitting_function(alpha, R0_values, constant, a, b, c), alpha_values, smallest_nonzero_pop_values)  # # Extract the optimal parameters # constant_opt, a_opt, b_opt, c_opt = popt print(f\"Optimal parameters: constant = {constant_opt}, a = {a_opt}, b = {b_opt}\") # # Plot smallest_nonzero_pop against alpha # plt.figure()  # # Plot the best fit line # # # # Create a meshgrid for alpha and R0 values # alpha_fit = np.linspace(min(alpha_values), max(alpha_values), 100) # R0_fit = np.linspace(min(R0_values), max(R0_values), 100) # alpha_fit, R0_fit = np.meshgrid(alpha_fit, R0_fit)  # # Calculate the best fit surface # best_fit_surface = fitting_function(alpha_fit, R0_fit, constant_opt, a_opt, b_opt)  # Plot the best fit surface fig = plt.figure(figsize=(14, 7)) ax = fig.add_subplot(111, projection=\"3d\")  # Calculate 1/alpha inv_alpha_fit = 1 / alpha_fit inv_alpha_values = 1 / alpha_values  # Plot the best fit surface ax.plot_surface(inv_alpha_fit, R0_fit, np.log10(best_fit_surface), cmap=\"viridis\", alpha=0.7)  # Scatter the real values for comparison ax.scatter(inv_alpha_values, R0_values, np.log10(smallest_nonzero_pop_values), color=\"red\", label=\"Real Values\")  ax.set_xlabel(\"1/Alpha (1/(inf_mean * cbr))\") ax.set_ylabel(\"R0\") ax.set_zlabel(\"Log(Smallest Nonzero Pop)\") ax.set_title(\"Best Fit Surface and Real Values\")  # Add the best fit equation as a textbox equation_text = f\"Best fit: y = {constant_opt:.2e} * alpha^{a_opt:.2f} * (R0/(R0-1))^{b_opt:.2f}\" # plt.text(0.05, 0.95, equation_text, transform=plt.gca().transAxes, fontsize=12, verticalalignment='top', bbox=dict(facecolor='white', alpha=0.5))  plt.tight_layout() # Rotate the camera for a better viewing angle ax.view_init(elev=20, azim=255) plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 24\n      1 # from scipy.optimize import curve_fit\n      2 \n      3 # # Calculate alpha\n   (...)     22 # # Extract the optimal parameters\n     23 # constant_opt, a_opt, b_opt, c_opt = popt\n---&gt; 24 print(f\"Optimal parameters: constant = {constant_opt}, a = {a_opt}, b = {b_opt}\")\n     25 # # Plot smallest_nonzero_pop against alpha\n     26 # plt.figure()\n     27 \n   (...)     37 \n     38 # Plot the best fit surface\n     39 fig = plt.figure(figsize=(14, 7))\n\nNameError: name 'constant_opt' is not defined</pre> In\u00a0[10]: Copied! <pre>plt.figure(figsize=(10, 6))\nplt.scatter(inv_alpha_values, smallest_nonzero_pop_values)\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.xlabel(\"1/Alpha (1/(inf_mean * cbr))\")\nplt.ylabel(\"Smallest Nonzero Pop\")\nplt.title(\"Smallest Nonzero Pop vs 1/Alpha\")\nplt.grid(True, which=\"both\", ls=\"--\")\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) plt.scatter(inv_alpha_values, smallest_nonzero_pop_values) plt.xscale(\"log\") plt.yscale(\"log\") plt.xlabel(\"1/Alpha (1/(inf_mean * cbr))\") plt.ylabel(\"Smallest Nonzero Pop\") plt.title(\"Smallest Nonzero Pop vs 1/Alpha\") plt.grid(True, which=\"both\", ls=\"--\") plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 2\n      1 plt.figure(figsize=(10, 6))\n----&gt; 2 plt.scatter(inv_alpha_values, smallest_nonzero_pop_values)\n      3 plt.xscale(\"log\")\n      4 plt.yscale(\"log\")\n\nNameError: name 'inv_alpha_values' is not defined</pre> <pre>&lt;Figure size 1000x600 with 0 Axes&gt;</pre> In\u00a0[11]: Copied! <pre>output_folder = \"..\\..\\laser-generic-outputs\\CCSSIRoutputs\"\n</pre> output_folder = \"..\\..\\laser-generic-outputs\\CCSSIRoutputs\" <pre>&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\.'\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\.'\n/tmp/ipykernel_2629/2486691589.py:1: SyntaxWarning: invalid escape sequence '\\.'\n  output_folder = \"..\\..\\laser-generic-outputs\\CCSSIRoutputs\"\n</pre> In\u00a0[33]: Copied! <pre>\n</pre> <pre>['twopatchSIRoutputs', 'CCSSIRoutputs']\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/notebooks/07_SIR_CCS/#exploring-the-critical-community-size-of-an-sir-model","title":"Exploring the critical community size of an SIR model\u00b6","text":"<p>Use multiple nodes with no connection to identify the critical community size and its dependence on disease and demographic parameters</p>"},{"location":"tutorials/notebooks/08_2patch_SIR_wbirths_correlation/","title":"The relationship between spatial coupling and incidence correlation in a 2-patch model","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import fsolve\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Model\nfrom laser.generic import Infection\nfrom laser.generic import Susceptibility\nfrom laser.generic import Transmission\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic.importation import Infect_Random_Agents\n\nfrom laser.generic.utils import set_initial_susceptibility_in_patch\nfrom laser.generic.utils import seed_infections_in_patch\n\n%load_ext line_profiler\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd from laser.core.propertyset import PropertySet import matplotlib.pyplot as plt from scipy.optimize import fsolve  import laser.core import laser.generic from laser.generic import Model from laser.generic import Infection from laser.generic import Susceptibility from laser.generic import Transmission from laser.generic import Births_ConstantPop from laser.generic.importation import Infect_Random_Agents  from laser.generic.utils import set_initial_susceptibility_in_patch from laser.generic.utils import seed_infections_in_patch  %load_ext line_profiler  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 19\n     16 from laser.generic.utils import set_initial_susceptibility_in_patch\n     17 from laser.generic.utils import seed_infections_in_patch\n---&gt; 19 get_ipython().run_line_magic('load_ext', 'line_profiler')\n     21 print(f\"{np.__version__=}\")\n     22 print(f\"{laser.core.__version__=}\")\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:2504, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2502     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2503 with self.builtin_trap:\n-&gt; 2504     result = fn(*args, **kwargs)\n   2506 # The code below prevents the output from being displayed\n   2507 # when using magics with decorator @output_can_be_silenced\n   2508 # when the last Python token in the expression is a ';'.\n   2509 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/magics/extension.py:33, in ExtensionMagics.load_ext(self, module_str)\n     31 if not module_str:\n     32     raise UsageError('Missing module name.')\n---&gt; 33 res = self.shell.extension_manager.load_extension(module_str)\n     35 if res == 'already loaded':\n     36     print(\"The %s extension is already loaded. To reload it, use:\" % module_str)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/extensions.py:62, in ExtensionManager.load_extension(self, module_str)\n     55 \"\"\"Load an IPython extension by its module name.\n     56 \n     57 Returns the string \"already loaded\" if the extension is already loaded,\n     58 \"no load function\" if the module doesn't have a load_ipython_extension\n     59 function, or None if it succeeded.\n     60 \"\"\"\n     61 try:\n---&gt; 62     return self._load_extension(module_str)\n     63 except ModuleNotFoundError:\n     64     if module_str in BUILTINS_EXTS:\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/extensions.py:77, in ExtensionManager._load_extension(self, module_str)\n     75 with self.shell.builtin_trap:\n     76     if module_str not in sys.modules:\n---&gt; 77         mod = import_module(module_str)\n     78     mod = sys.modules[module_str]\n     79     if self._call_load_ipython_extension(mod):\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/importlib/__init__.py:90, in import_module(name, package)\n     88             break\n     89         level += 1\n---&gt; 90 return _bootstrap._gcd_import(name[level:], package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1387, in _gcd_import(name, package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1360, in _find_and_load(name, import_)\n\nFile &lt;frozen importlib._bootstrap&gt;:1324, in _find_and_load_unlocked(name, import_)\n\nModuleNotFoundError: No module named 'line_profiler'</pre> In\u00a0[2]: Copied! <pre>%%capture\nimport os\n\n# Set parameters to match those of Keeling &amp; Rohani, 2002.  They have a constant importation rate of 5.5e-5*sqrt(N) per day,\n# which for this sim would be something like 40 per year.  I'm importing 6 per year, but I don't think that should be the big deal.\n# more important is setting the birth, R0, and infectious period to their numbers and then seeing the\n# connectivity-correlation relationship.\nnticks = 36500\nscenario = pd.DataFrame(data=[[\"patch1\", 1e6], [\"patch2\", 1e6]], columns=[\"name\", \"population\"])\nparameters = PropertySet(\n    {\n        \"seed\": 4,\n        \"nticks\": nticks,\n        \"verbose\": True,\n        \"beta\": 17 / 13,\n        \"inf_mean\": 13,\n        \"cbr\": 20.277294,\n        \"importation_period\": 180,\n        \"importation_count\": 3,\n        \"importation_start\": 500,\n    }\n)\n\nmu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\nR0 = parameters.beta / (mu + 1 / parameters.inf_mean)\nnsims = 100\ni = 0\noutputs = np.zeros((nsims, parameters.nticks, scenario.shape[0]))\n# Create a folder to store the outputs\noutput_folder = \"twopatchSIRoutputs\"\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\nfor connection in np.logspace(-4, -1, nsims):\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Random_Agents,\n    ]\n\n    # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch\n    # Want to see how connectivity drives correlation over time.\n    model.patches.network = np.array([[0, connection], [connection, 0]])\n    set_initial_susceptibility_in_patch(model, 1, 1 / R0 + 0.02 * np.random.normal())\n    set_initial_susceptibility_in_patch(model, 0, 1 / R0 + 0.02 * np.random.normal())\n    seed_infections_in_patch(model, ipatch=0, ninfections=3)\n\n    model.run()\n    outputs[i, :, :] = model.patches.cases\n    np.save(f\"{output_folder}/twopatchSIRoutputs_{i}.npy\", outputs[i, :, :])\n    i += 1\n</pre> %%capture import os  # Set parameters to match those of Keeling &amp; Rohani, 2002.  They have a constant importation rate of 5.5e-5*sqrt(N) per day, # which for this sim would be something like 40 per year.  I'm importing 6 per year, but I don't think that should be the big deal. # more important is setting the birth, R0, and infectious period to their numbers and then seeing the # connectivity-correlation relationship. nticks = 36500 scenario = pd.DataFrame(data=[[\"patch1\", 1e6], [\"patch2\", 1e6]], columns=[\"name\", \"population\"]) parameters = PropertySet(     {         \"seed\": 4,         \"nticks\": nticks,         \"verbose\": True,         \"beta\": 17 / 13,         \"inf_mean\": 13,         \"cbr\": 20.277294,         \"importation_period\": 180,         \"importation_count\": 3,         \"importation_start\": 500,     } )  mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1 R0 = parameters.beta / (mu + 1 / parameters.inf_mean) nsims = 100 i = 0 outputs = np.zeros((nsims, parameters.nticks, scenario.shape[0])) # Create a folder to store the outputs output_folder = \"twopatchSIRoutputs\" if not os.path.exists(output_folder):     os.makedirs(output_folder) for connection in np.logspace(-4, -1, nsims):     model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Random_Agents,     ]      # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch     # Want to see how connectivity drives correlation over time.     model.patches.network = np.array([[0, connection], [connection, 0]])     set_initial_susceptibility_in_patch(model, 1, 1 / R0 + 0.02 * np.random.normal())     set_initial_susceptibility_in_patch(model, 0, 1 / R0 + 0.02 * np.random.normal())     seed_infections_in_patch(model, ipatch=0, ninfections=3)      model.run()     outputs[i, :, :] = model.patches.cases     np.save(f\"{output_folder}/twopatchSIRoutputs_{i}.npy\", outputs[i, :, :])     i += 1 <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[2], line 49\n     46 set_initial_susceptibility_in_patch(model, 0, 1 / R0 + 0.02 * np.random.normal())\n     47 seed_infections_in_patch(model, ipatch=0, ninfections=3)\n---&gt; 49 model.run()\n     50 outputs[i, :, :] = model.patches.cases\n     51 np.save(f\"{output_folder}/twopatchSIRoutputs_{i}.npy\", outputs[i, :, :])\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:313, in Births_ConstantPop.__call__(self, model, tick)\n    309     model.population.dob[indices] = tick  # set to current tick\n    310 model.population.state[indices] = 0\n    312 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 313     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    314 ).astype(np.uint32)\n    316 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    317     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    318 ).astype(np.uint32)\n    320 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    321     model.population.nodeid[indices],\n    322     weights=(\n   (...)    327     minlength=model.patches.populations.shape[1],\n    328 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[5], line 3\n      1 # Extract outputs for patch 1 and patch 2\n----&gt; 3 with pd.ExcelWriter('2patch_SIR_wbirths_simulations.xlsx') as writer:\n      4     for sim in range(outputs.shape[0]):\n      5         df_sim = pd.DataFrame(outputs[sim, :, :], columns=['Patch1', 'Patch2'])\n\nFile ~/Documents/GitHub/laser-generic/.venv/lib/python3.11/site-packages/pandas/io/excel/_openpyxl.py:57, in OpenpyxlWriter.__init__(self, path, engine, date_format, datetime_format, mode, storage_options, if_sheet_exists, engine_kwargs, **kwargs)\n     44 def __init__(\n     45     self,\n     46     path: FilePath | WriteExcelBuffer | ExcelWriter,\n   (...)\n     55 ) -&gt; None:\n     56     # Use the openpyxl module as the Excel writer.\n---&gt; 57     from openpyxl.workbook import Workbook\n     59     engine_kwargs = combine_kwargs(engine_kwargs, kwargs)\n     61     super().__init__(\n     62         path,\n     63         mode=mode,\n   (...)\n     66         engine_kwargs=engine_kwargs,\n     67     )\n\nModuleNotFoundError: No module named 'openpyxl'</pre> In\u00a0[3]: Copied! <pre>correlations = []\nlast_50_years = 50 * 365  # 50 years in days\n\nfor sim in range(outputs.shape[0]):\n    patch1_data = outputs[sim, -last_50_years:, 0]\n    patch2_data = outputs[sim, -last_50_years:, 1]\n    correlation = np.corrcoef(patch1_data, patch2_data)[0, 1]\n    correlations.append(correlation)\n\ncorrelations = np.array(correlations)\nprint(correlations)\n</pre> correlations = [] last_50_years = 50 * 365  # 50 years in days  for sim in range(outputs.shape[0]):     patch1_data = outputs[sim, -last_50_years:, 0]     patch2_data = outputs[sim, -last_50_years:, 1]     correlation = np.corrcoef(patch1_data, patch2_data)[0, 1]     correlations.append(correlation)  correlations = np.array(correlations) print(correlations) <pre>[nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan]\n</pre> <pre>/opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/lib/_function_base_impl.py:3065: RuntimeWarning: invalid value encountered in divide\n  c /= stddev[:, None]\n</pre> In\u00a0[4]: Copied! <pre>from scipy.optimize import curve_fit\n\nx = np.logspace(-4, -1, nsims)\n\n\n# Define the function to fit\ndef func(x, psi, beta):\n    return beta + x / (psi + x)\n\n\n# Fit the curve\npopt, pcov = curve_fit(func, x, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002]))\npsi_opt = popt[0]\nbeta_opt = popt[1]\nplt.plot(x, correlations, \".\")\nplt.xscale(\"log\")\n# Plot the fitted curve\nplt.plot(x, func(x, psi_opt, beta_opt), label=f\"Fitted curve: y = {beta_opt:.4f} + x / ({psi_opt:.4f} + x)\")\nplt.legend()\n</pre> from scipy.optimize import curve_fit  x = np.logspace(-4, -1, nsims)   # Define the function to fit def func(x, psi, beta):     return beta + x / (psi + x)   # Fit the curve popt, pcov = curve_fit(func, x, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002])) psi_opt = popt[0] beta_opt = popt[1] plt.plot(x, correlations, \".\") plt.xscale(\"log\") # Plot the fitted curve plt.plot(x, func(x, psi_opt, beta_opt), label=f\"Fitted curve: y = {beta_opt:.4f} + x / ({psi_opt:.4f} + x)\") plt.legend() <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[4], line 12\n      8     return beta + x / (psi + x)\n     11 # Fit the curve\n---&gt; 12 popt, pcov = curve_fit(func, x, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002]))\n     13 psi_opt = popt[0]\n     14 beta_opt = popt[1]\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/scipy/optimize/_minpack_py.py:936, in curve_fit(f, xdata, ydata, p0, sigma, absolute_sigma, check_finite, bounds, method, jac, full_output, nan_policy, **kwargs)\n    934 # optimization may produce garbage for float32 inputs, cast them to float64\n    935 if check_finite:\n--&gt; 936     ydata = np.asarray_chkfinite(ydata, float)\n    937 else:\n    938     ydata = np.asarray(ydata, float)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/lib/_function_base_impl.py:665, in asarray_chkfinite(a, dtype, order)\n    663 a = asarray(a, dtype=dtype, order=order)\n    664 if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():\n--&gt; 665     raise ValueError(\n    666         \"array must not contain infs or NaNs\")\n    667 return a\n\nValueError: array must not contain infs or NaNs</pre>"},{"location":"tutorials/notebooks/08_2patch_SIR_wbirths_correlation/#the-relationship-between-spatial-coupling-and-incidence-correlation-in-a-2-patch-model","title":"The relationship between spatial coupling and incidence correlation in a 2-patch model\u00b6","text":"<p>Ref: Keeling &amp; Rohani, Estimating spatial coupling in epidemiological systems: a mechanistic approach, Ecol. Letters (2002) 5:20-29</p>"},{"location":"tutorials/notebooks/10_EW_periodicity/","title":"10 EW periodicity","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport os\nimport sys\nfrom laser.core.propertyset import PropertySet\nfrom laser.core.migration import gravity\nfrom laser.core.migration import row_normalizer\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import fsolve\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Model\nfrom laser.generic import Infection\nfrom laser.generic import Susceptibility\nfrom laser.generic import Exposure\nfrom laser.generic import Transmission\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic import Births_ConstantPop_VariableBirthRate\nfrom laser.generic import Infect_Random_Agents\nfrom laser.generic.utils import set_initial_susceptibility_in_patch\nfrom laser.generic.utils import seed_infections_in_patch\nimport pickle\n\n\ndata_dir = os.path.join('..', \"data\")\nsys.path.append(data_dir)\n\nfrom EnglandWalesmeasles import data as engwal\ndistances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd import os import sys from laser.core.propertyset import PropertySet from laser.core.migration import gravity from laser.core.migration import row_normalizer import matplotlib.pyplot as plt from scipy.optimize import fsolve  import laser.core import laser.generic from laser.generic import Model from laser.generic import Infection from laser.generic import Susceptibility from laser.generic import Exposure from laser.generic import Transmission from laser.generic import Births_ConstantPop from laser.generic import Births_ConstantPop_VariableBirthRate from laser.generic import Infect_Random_Agents from laser.generic.utils import set_initial_susceptibility_in_patch from laser.generic.utils import seed_infections_in_patch import pickle   data_dir = os.path.join('..', \"data\") sys.path.append(data_dir)  from EnglandWalesmeasles import data as engwal distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 29\n     26 data_dir = os.path.join('..', \"data\")\n     27 sys.path.append(data_dir)\n---&gt; 29 from EnglandWalesmeasles import data as engwal\n     30 distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n     32 print(f\"{np.__version__=}\")\n\nModuleNotFoundError: No module named 'EnglandWalesmeasles'</pre> In\u00a0[2]: Copied! <pre>average_pop = np.array([np.mean(place.population) for place in engwal.places.values()])\naverage_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()])\naverage_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop)\naverage_pop\naverage_cbr\n</pre> average_pop = np.array([np.mean(place.population) for place in engwal.places.values()]) average_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()]) average_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop) average_pop average_cbr <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 average_pop = np.array([np.mean(place.population) for place in engwal.places.values()])\n      2 average_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()])\n      3 average_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop)\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[3]: Copied! <pre># Compute the average birthrate across all places for each year\nyears = len(next(iter(engwal.places.values())).births)\nbirths_matrix = np.array([place.births for place in engwal.places.values()])\npop_matrix = np.array([place.population for place in engwal.places.values()])\naverage_birthrate_per_year = np.sum(births_matrix, axis=0) / np.sum(pop_matrix, axis=0)\naverage_birthrate_per_year\nvarcbrs = {'rates': average_birthrate_per_year*1000, 'timesteps': np.arange(20*365, 41*365, 365)}\n</pre> # Compute the average birthrate across all places for each year years = len(next(iter(engwal.places.values())).births) births_matrix = np.array([place.births for place in engwal.places.values()]) pop_matrix = np.array([place.population for place in engwal.places.values()]) average_birthrate_per_year = np.sum(births_matrix, axis=0) / np.sum(pop_matrix, axis=0) average_birthrate_per_year varcbrs = {'rates': average_birthrate_per_year*1000, 'timesteps': np.arange(20*365, 41*365, 365)} <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 2\n      1 # Compute the average birthrate across all places for each year\n----&gt; 2 years = len(next(iter(engwal.places.values())).births)\n      3 births_matrix = np.array([place.births for place in engwal.places.values()])\n      4 pop_matrix = np.array([place.population for place in engwal.places.values()])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[4]: Copied! <pre>varcbrs\n</pre> varcbrs <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 varcbrs\n\nNameError: name 'varcbrs' is not defined</pre> In\u00a0[5]: Copied! <pre>#For starters, we will work with a constant population and constant crude birth rate over the network.  \n#This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now.\ndata = [{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\nscenario = pd.DataFrame(data)\nparameters = PropertySet(\n    {\"seed\": 4, \"nticks\": 20*365,\n    \"exp_shape\": 40, \"exp_scale\": 0.25,\n    \"verbose\": True, \"beta\": 1.2, \"inf_mean\": 10, \"inf_sigma\": 2, \"cbr\": average_cbr,\n    \"seasonality_factor\": 0.2, \"seasonality_phase\": 182,\n    \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 8*365}\n)\n\nmodel = Model(scenario, parameters)\nmodel.components = [\n    Births_ConstantPop,\n    Susceptibility,\n    Transmission,\n    Exposure,\n    Infection,\n    Infect_Random_Agents,\n]\n\nmodel.patches.network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-8, 0, 1, 2), 0.2)\n\nmu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\nR0 = parameters.beta / (mu + 1 / parameters.inf_mean)\nfor i in range(len(model.patches)):\n    set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.02 * np.random.normal())\n\nseed_infections_in_patch(model, ipatch=0, ninfections=3)\n#model.run()\n</pre> #For starters, we will work with a constant population and constant crude birth rate over the network.   #This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now. data = [{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()]  scenario = pd.DataFrame(data) parameters = PropertySet(     {\"seed\": 4, \"nticks\": 20*365,     \"exp_shape\": 40, \"exp_scale\": 0.25,     \"verbose\": True, \"beta\": 1.2, \"inf_mean\": 10, \"inf_sigma\": 2, \"cbr\": average_cbr,     \"seasonality_factor\": 0.2, \"seasonality_phase\": 182,     \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 8*365} )  model = Model(scenario, parameters) model.components = [     Births_ConstantPop,     Susceptibility,     Transmission,     Exposure,     Infection,     Infect_Random_Agents, ]  model.patches.network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-8, 0, 1, 2), 0.2)  mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1 R0 = parameters.beta / (mu + 1 / parameters.inf_mean) for i in range(len(model.patches)):     set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.02 * np.random.normal())  seed_infections_in_patch(model, ipatch=0, ninfections=3) #model.run() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 6\n      1 #For starters, we will work with a constant population and constant crude birth rate over the network.  \n      2 #This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now.\n      3 data = [{\"name\": placename,\n      4          \"population\": place.population[0],\n      5          \"latitude\": place.latitude,\n----&gt; 6          \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n      8 scenario = pd.DataFrame(data)\n      9 parameters = PropertySet(\n     10     {\"seed\": 4, \"nticks\": 20*365,\n     11     \"exp_shape\": 40, \"exp_scale\": 0.25,\n   (...)     14     \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 8*365}\n     15 )\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[6]: Copied! <pre>plt.plot(np.log10(model.patches.populations[0,:]), np.sum(model.patches.cases_test[3650:,:] == 0, axis=0)/((model.patches.cases_test.shape[0]-3650)), '.')\nplt.xlabel('Population')\nplt.ylabel('Sum of Entries (Cases == 0)')\nplt.title('Population vs Sum of Entries where Cases == 0')\nplt.show()\n</pre> plt.plot(np.log10(model.patches.populations[0,:]), np.sum(model.patches.cases_test[3650:,:] == 0, axis=0)/((model.patches.cases_test.shape[0]-3650)), '.') plt.xlabel('Population') plt.ylabel('Sum of Entries (Cases == 0)') plt.title('Population vs Sum of Entries where Cases == 0') plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 plt.plot(np.log10(model.patches.populations[0,:]), np.sum(model.patches.cases_test[3650:,:] == 0, axis=0)/((model.patches.cases_test.shape[0]-3650)), '.')\n      2 plt.xlabel('Population')\n      3 plt.ylabel('Sum of Entries (Cases == 0)')\n\nNameError: name 'model' is not defined</pre> In\u00a0[7]: Copied! <pre># Test equality for cases\n#cases_equal = np.array_equal(model.patches.cases, model.patches.cases_test[:-1, :])\n\n# Test equality for susceptibility\n#susceptibility_equal = np.array_equal(model.patches.susceptibility, model.patches.susceptibility_test[:-1, :])\n\n# Test equality for recovered\n#recovered_equal = np.array_equal(model.patches.recovered, model.patches.recovered_test[:-1, :])\n\n# Test equality for exposed\n#exposed_equal = np.array_equal(model.patches.exposed, model.patches.exposed_test[:-1, :])\n\n#cases_equal, susceptibility_equal, recovered_equal, exposed_equal\n</pre> # Test equality for cases #cases_equal = np.array_equal(model.patches.cases, model.patches.cases_test[:-1, :])  # Test equality for susceptibility #susceptibility_equal = np.array_equal(model.patches.susceptibility, model.patches.susceptibility_test[:-1, :])  # Test equality for recovered #recovered_equal = np.array_equal(model.patches.recovered, model.patches.recovered_test[:-1, :])  # Test equality for exposed #exposed_equal = np.array_equal(model.patches.exposed, model.patches.exposed_test[:-1, :])  #cases_equal, susceptibility_equal, recovered_equal, exposed_equal In\u00a0[8]: Copied! <pre>%%capture\ndata = [{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\nscenario = pd.DataFrame(data)\nlog_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n-0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\n\n#Round 2\nks = 10**(np.random.uniform(-3, -1.5, 100))\nbs = np.random.uniform(0.3, 0.8, 100)\ncs = np.random.uniform(1.0, 2.0, 100)\nbetas = np.random.uniform(0.3, 1.8, 100)\nparams_df = pd.DataFrame({\n    \"k\": ks,\n    \"b\": bs,\n    \"c\": cs\n})\nparams_df.to_csv(os.path.join('..', 'outputs3', 'params.csv'), index=False)\nfor ind in range(len(ks)):\n    k = ks[ind]\n    b = bs[ind]\n    c = cs[ind]\n    parameters = PropertySet(\n        {\"seed\": 4, \"nticks\": 40*365,\n        \"exp_shape\": 40, \"exp_scale\": 0.25,\n        \"verbose\": True, \"beta\": 3.4, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,\n        \"biweekly_beta_scalar\": np.exp(0.6*(log_betas - np.mean(log_betas))),\n        \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365\n        }\n    )\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Exposure,\n        Infection,\n        Infect_Random_Agents,\n    ]\n\n    model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, b, c)\n    rowsums = np.sum(model.patches.network, axis=1)\n    model.patches.network = model.patches.network / rowsums[:, np.newaxis] * k\n    model.patches.network = row_normalizer(model.patches.network, 0.2)\n\n    mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\n    R0 = parameters.beta / (mu + 1 / parameters.inf_mean)\n    for i in range(len(model.patches)):\n        set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.2/R0 * np.random.normal())\n\n    seed_infections_in_patch(model, ipatch=507, ninfections=3)\n    model.run()\n    output_path = os.path.join('..', 'outputs3', f\"EWoutputs_gravity_{int(ind)}.pkl\")\n    for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:\n        if hasattr(model.patches, attr):\n            delattr(model.patches, attr)\n    with open(output_path, \"wb\") as file:\n        pickle.dump(model.patches, file)\n</pre> %%capture data = [{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()] scenario = pd.DataFrame(data) log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074, -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])   #Round 2 ks = 10**(np.random.uniform(-3, -1.5, 100)) bs = np.random.uniform(0.3, 0.8, 100) cs = np.random.uniform(1.0, 2.0, 100) betas = np.random.uniform(0.3, 1.8, 100) params_df = pd.DataFrame({     \"k\": ks,     \"b\": bs,     \"c\": cs }) params_df.to_csv(os.path.join('..', 'outputs3', 'params.csv'), index=False) for ind in range(len(ks)):     k = ks[ind]     b = bs[ind]     c = cs[ind]     parameters = PropertySet(         {\"seed\": 4, \"nticks\": 40*365,         \"exp_shape\": 40, \"exp_scale\": 0.25,         \"verbose\": True, \"beta\": 3.4, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,         \"biweekly_beta_scalar\": np.exp(0.6*(log_betas - np.mean(log_betas))),         \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365         }     )      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Exposure,         Infection,         Infect_Random_Agents,     ]      model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, b, c)     rowsums = np.sum(model.patches.network, axis=1)     model.patches.network = model.patches.network / rowsums[:, np.newaxis] * k     model.patches.network = row_normalizer(model.patches.network, 0.2)      mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1     R0 = parameters.beta / (mu + 1 / parameters.inf_mean)     for i in range(len(model.patches)):         set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.2/R0 * np.random.normal())      seed_infections_in_patch(model, ipatch=507, ninfections=3)     model.run()     output_path = os.path.join('..', 'outputs3', f\"EWoutputs_gravity_{int(ind)}.pkl\")     for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:         if hasattr(model.patches, attr):             delattr(model.patches, attr)     with open(output_path, \"wb\") as file:         pickle.dump(model.patches, file)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 4\n      1 data = [{\"name\": placename,\n      2          \"population\": place.population[0],\n      3          \"latitude\": place.latitude,\n----&gt; 4          \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n      5 scenario = pd.DataFrame(data)\n      6 log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n      7 -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> Out[\u00a0]: <pre>array([1.00000000e-09, 1.37382380e-09, 1.88739182e-09, 2.59294380e-09,\n       3.56224789e-09, 4.89390092e-09, 6.72335754e-09, 9.23670857e-09,\n       1.26896100e-08, 1.74332882e-08, 2.39502662e-08, 3.29034456e-08,\n       4.52035366e-08, 6.21016942e-08, 8.53167852e-08, 1.17210230e-07,\n       1.61026203e-07, 2.21221629e-07, 3.03919538e-07, 4.17531894e-07,\n       5.73615251e-07, 7.88046282e-07, 1.08263673e-06, 1.48735211e-06,\n       2.04335972e-06, 2.80721620e-06, 3.85662042e-06, 5.29831691e-06,\n       7.27895384e-06, 1.00000000e-05])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[9]: Copied! <pre>plt.plot(x.cases_test[:, 507], label=\"Susceptibility\")\nplt.xlim(12500, 13000)\n</pre> plt.plot(x.cases_test[:, 507], label=\"Susceptibility\") plt.xlim(12500, 13000) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 plt.plot(x.cases_test[:, 507], label=\"Susceptibility\")\n      2 plt.xlim(12500, 13000)\n\nNameError: name 'x' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> Out[\u00a0]: <pre>30182538</pre> In\u00a0[10]: Copied! <pre>data = [{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\nscenario = pd.DataFrame(data)\nnetwork = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.2).T\n</pre> data = [{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()]  scenario = pd.DataFrame(data) network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.2).T  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 4\n      1 data = [{\"name\": placename,\n      2          \"population\": place.population[0],\n      3          \"latitude\": place.latitude,\n----&gt; 4          \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n      6 scenario = pd.DataFrame(data)\n      7 network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.2).T\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[11]: Copied! <pre>plt.figure(figsize=(10, 8))\nplt.imshow(np.log10(network), cmap='viridis', aspect='auto')\nplt.colorbar(label='Connection Strength')\nplt.title('Network Matrix Visualization')\nplt.xlabel('Node Index')\nplt.ylabel('Node Index')\nplt.show()\n</pre> plt.figure(figsize=(10, 8)) plt.imshow(np.log10(network), cmap='viridis', aspect='auto') plt.colorbar(label='Connection Strength') plt.title('Network Matrix Visualization') plt.xlabel('Node Index') plt.ylabel('Node Index') plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[11], line 2\n      1 plt.figure(figsize=(10, 8))\n----&gt; 2 plt.imshow(np.log10(network), cmap='viridis', aspect='auto')\n      3 plt.colorbar(label='Connection Strength')\n      4 plt.title('Network Matrix Visualization')\n\nNameError: name 'network' is not defined</pre> <pre>&lt;Figure size 1000x800 with 0 Axes&gt;</pre> In\u00a0[12]: Copied! <pre>transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\n</pre> transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\n\nNameError: name 'x' is not defined</pre> In\u00a0[13]: Copied! <pre>np.unravel_index(np.argmax(transfer), transfer.shape)\n</pre> np.unravel_index(np.argmax(transfer), transfer.shape) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 np.unravel_index(np.argmax(transfer), transfer.shape)\n\nNameError: name 'transfer' is not defined</pre> In\u00a0[14]: Copied! <pre>network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.999).T\ntransfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\nany((x.cases_test[10000, :]-transfer.sum(axis=0))&lt;0)\n</pre> network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.999).T transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network any((x.cases_test[10000, :]-transfer.sum(axis=0))&lt;0) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.999).T\n      2 transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\n      3 any((x.cases_test[10000, :]-transfer.sum(axis=0))&lt;0)\n\nNameError: name 'scenario' is not defined</pre> In\u00a0[15]: Copied! <pre>pops = np.array([10., 100., 1000.])\ndistances = np.array([[0., 1., 2.], [1, 0, 5], [2, 5, 0]])\nnetwork = gravity(pops, distances, 1, 0, 1, 1)\n</pre> pops = np.array([10., 100., 1000.]) distances = np.array([[0., 1., 2.], [1, 0, 5], [2, 5, 0]]) network = gravity(pops, distances, 1, 0, 1, 1) In\u00a0[16]: Copied! <pre>network\n</pre> network Out[16]: <pre>array([[  0., 100., 500.],\n       [ 10.,   0., 200.],\n       [  5.,  20.,   0.]])</pre> In\u00a0[17]: Copied! <pre>row_normalizer(network, 0.5)\n</pre> row_normalizer(network, 0.5) Out[17]: <pre>array([[0.        , 0.08333334, 0.41666666],\n       [0.02380952, 0.        , 0.47619048],\n       [0.1       , 0.4       , 0.        ]], dtype=float32)</pre> In\u00a0[18]: Copied! <pre>cases = np.array([1., 2, 3])\n</pre> cases = np.array([1., 2, 3]) In\u00a0[19]: Copied! <pre>transfer = cases*network\n</pre> transfer = cases*network In\u00a0[20]: Copied! <pre>transfer\n</pre> transfer Out[20]: <pre>array([[   0.,  200., 1500.],\n       [  10.,    0.,  600.],\n       [   5.,   40.,    0.]])</pre> In\u00a0[21]: Copied! <pre>transfer[0,1]\n</pre> transfer[0,1] Out[21]: <pre>np.float64(200.0)</pre> In\u00a0[22]: Copied! <pre>cases[0]*network[0,1]\n</pre> cases[0]*network[0,1] Out[22]: <pre>np.float64(100.0)</pre> In\u00a0[23]: Copied! <pre>cases.shape\n</pre> cases.shape Out[23]: <pre>(3,)</pre> In\u00a0[24]: Copied! <pre>model.patches.cases_test[25, :].shape\n</pre> model.patches.cases_test[25, :].shape <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[24], line 1\n----&gt; 1 model.patches.cases_test[25, :].shape\n\nNameError: name 'model' is not defined</pre> In\u00a0[25]: Copied! <pre>np.sqrt(3)\n</pre> np.sqrt(3) Out[25]: <pre>np.float64(1.7320508075688772)</pre> In\u00a0[26]: Copied! <pre>3**(0.5)\n</pre> 3**(0.5) Out[26]: <pre>1.7320508075688772</pre> In\u00a0[27]: Copied! <pre>model.patches.\n</pre> model.patches. <pre>\n  Cell In[27], line 1\n    model.patches.\n                  ^\nSyntaxError: invalid syntax\n</pre> In\u00a0[28]: Copied! <pre>.017*3e7\n</pre> .017*3e7 Out[28]: <pre>510000.00000000006</pre> In\u00a0[29]: Copied! <pre>#For starters, we will work with a constant population and constant crude birth rate over the network.  \n#This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now.\n#test_outs = []\nmyparams = []\n#for i in range(6, 11):\n#    for j in range(5):\nj=0\nfor i in range (20):\n    beta = 3.4\n    scalar = 0.6\n    myparams.append((beta, scalar))\n    data = [{\"name\": placename,\n            \"population\": place.population[0],\n            \"latitude\": place.latitude,\n            \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\n    log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n    -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\n    scenario = pd.DataFrame(data)\n    parameters = PropertySet(\n        {\"seed\": i, \"nticks\": 40*365,\n        \"exp_shape\": 40, \"exp_scale\": 0.25,\n        \"verbose\": True, \"beta\": beta, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,\n        \"biweekly_beta_scalar\": np.exp( scalar*(log_betas - np.mean(log_betas)) ),\n        \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}\n    )\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Exposure,\n        Infection,\n        Infect_Random_Agents,\n    ]\n    model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)\n    rowsums = np.sum(model.patches.network, axis=1)\n    model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3\n    model.patches.network = row_normalizer(model.patches.network, 0.2)\n\n    mu = (1 + parameters.cbr/ 1000) ** (1 / 365) - 1\n    R0 = parameters.beta / (mu + 1 / parameters.inf_mean)\n    for p in range(len(model.patches)):\n        set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())\n\n    seed_infections_in_patch(model, ipatch=507, ninfections=3)\n    model.run()\n    #test_outs.append(model.patches.cases_test)\n    #myparams.append((0.5+i/5, 0.5+0.25*j))\n\n    output_path = os.path.join('..', 'periodicity_outs', f\"EWoutputs3_betas_{i}_{j}.pkl\")\n    for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:\n        if hasattr(model.patches, attr):\n            delattr(model.patches, attr)\n    with open(output_path, \"wb\") as file:\n        pickle.dump(model.patches, file)\n</pre> #For starters, we will work with a constant population and constant crude birth rate over the network.   #This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now. #test_outs = [] myparams = [] #for i in range(6, 11): #    for j in range(5): j=0 for i in range (20):     beta = 3.4     scalar = 0.6     myparams.append((beta, scalar))     data = [{\"name\": placename,             \"population\": place.population[0],             \"latitude\": place.latitude,             \"longitude\": place.longitude} for placename, place in engwal.places.items()]      log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,     -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])      scenario = pd.DataFrame(data)     parameters = PropertySet(         {\"seed\": i, \"nticks\": 40*365,         \"exp_shape\": 40, \"exp_scale\": 0.25,         \"verbose\": True, \"beta\": beta, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,         \"biweekly_beta_scalar\": np.exp( scalar*(log_betas - np.mean(log_betas)) ),         \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}     )      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Exposure,         Infection,         Infect_Random_Agents,     ]     model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)     rowsums = np.sum(model.patches.network, axis=1)     model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3     model.patches.network = row_normalizer(model.patches.network, 0.2)      mu = (1 + parameters.cbr/ 1000) ** (1 / 365) - 1     R0 = parameters.beta / (mu + 1 / parameters.inf_mean)     for p in range(len(model.patches)):         set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())      seed_infections_in_patch(model, ipatch=507, ninfections=3)     model.run()     #test_outs.append(model.patches.cases_test)     #myparams.append((0.5+i/5, 0.5+0.25*j))      output_path = os.path.join('..', 'periodicity_outs', f\"EWoutputs3_betas_{i}_{j}.pkl\")     for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:         if hasattr(model.patches, attr):             delattr(model.patches, attr)     with open(output_path, \"wb\") as file:         pickle.dump(model.patches, file)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[29], line 15\n     10 scalar = 0.6\n     11 myparams.append((beta, scalar))\n     12 data = [{\"name\": placename,\n     13         \"population\": place.population[0],\n     14         \"latitude\": place.latitude,\n---&gt; 15         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n     17 log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n     18 -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n     20 scenario = pd.DataFrame(data)\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[30]: Copied! <pre>import glob\n\nfiles = glob.glob(os.path.join('..', 'periodicity_outs', 'EWoutputs3_betas_*_*.pkl'))\n\n# Prepare a 9x5 grid of axes\nfig, axes = plt.subplots(5, 4, figsize=(18, 24), sharex=True, sharey=True)\n\nfor file in files:\n    basename = os.path.basename(file)\n    parts = basename.replace('.pkl', '').split('_')\n    i = int(parts[-2])\n    j = int(parts[-1])\n    with open(file, \"rb\") as f:\n        x = pickle.load(f)\n    # Only plot years 20:40 (indices 7300:14600)\n    t = 1./365 * np.arange(x.cases_test.shape[0])\n    mask = (t &gt;= 0) &amp; (t &lt;= 40)\n    axes[i % 5, i//5].plot(t[mask], np.sum(x.cases_test, axis=1)[mask])\n    axes[i % 5, i//5].set_title(f\"beta={3.1+0.1*i:.2f}, scalar={0.5+0.1*j:.2f}\", fontsize=9)\n    if i == 5:\n        axes[i%5, i//5].set_xlabel(\"Years\")\n    if j == 0:\n        axes[i%5, i//5].set_ylabel(\"Total Cases\")\n\nplt.tight_layout()\nplt.show()\n</pre> import glob  files = glob.glob(os.path.join('..', 'periodicity_outs', 'EWoutputs3_betas_*_*.pkl'))  # Prepare a 9x5 grid of axes fig, axes = plt.subplots(5, 4, figsize=(18, 24), sharex=True, sharey=True)  for file in files:     basename = os.path.basename(file)     parts = basename.replace('.pkl', '').split('_')     i = int(parts[-2])     j = int(parts[-1])     with open(file, \"rb\") as f:         x = pickle.load(f)     # Only plot years 20:40 (indices 7300:14600)     t = 1./365 * np.arange(x.cases_test.shape[0])     mask = (t &gt;= 0) &amp; (t &lt;= 40)     axes[i % 5, i//5].plot(t[mask], np.sum(x.cases_test, axis=1)[mask])     axes[i % 5, i//5].set_title(f\"beta={3.1+0.1*i:.2f}, scalar={0.5+0.1*j:.2f}\", fontsize=9)     if i == 5:         axes[i%5, i//5].set_xlabel(\"Years\")     if j == 0:         axes[i%5, i//5].set_ylabel(\"Total Cases\")  plt.tight_layout() plt.show()  In\u00a0[31]: Copied! <pre>test_outs = []\nmyparams = []\nfor i in range(9):\n    for j in range(5):\n        data = [{\"name\": placename,\n                \"population\": place.population[0],\n                \"latitude\": place.latitude,\n                \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\n        log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n        -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\n        scenario = pd.DataFrame([data[507]])\n        parameters = PropertySet(\n            {\"seed\": 4, \"nticks\": 40*365,\n            \"exp_shape\": 40, \"exp_scale\": 0.25,\n            \"verbose\": True, \"beta\": 0.5+0.25*i, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": varcbrs,\n            \"biweekly_beta_scalar\": np.exp( (0.5 + 0.25*j)*(log_betas - np.mean(log_betas)) ),\n            \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}\n        )\n\n        model = Model(scenario, parameters)\n        model.components = [\n            Births_ConstantPop_VariableBirthRate,\n            Susceptibility,\n            Transmission,\n            Exposure,\n            Infection,\n            Infect_Random_Agents,\n        ]\n        # model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)\n        # rowsums = np.sum(model.patches.network, axis=1)\n        # model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3\n        # model.patches.network = row_normalizer(model.patches.network, 0.2)\n\n        mu = (1 + parameters.cbr['rates'][0] / 1000) ** (1 / 365) - 1\n        R0 = parameters.beta / (mu + 1 / parameters.inf_mean)\n        for p in range(len(model.patches)):\n            set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())\n\n        seed_infections_in_patch(model, ipatch=507, ninfections=3)\n        model.run()\n        test_outs.append(model.patches.incidence)\n</pre> test_outs = [] myparams = [] for i in range(9):     for j in range(5):         data = [{\"name\": placename,                 \"population\": place.population[0],                 \"latitude\": place.latitude,                 \"longitude\": place.longitude} for placename, place in engwal.places.items()]          log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,         -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])          scenario = pd.DataFrame([data[507]])         parameters = PropertySet(             {\"seed\": 4, \"nticks\": 40*365,             \"exp_shape\": 40, \"exp_scale\": 0.25,             \"verbose\": True, \"beta\": 0.5+0.25*i, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": varcbrs,             \"biweekly_beta_scalar\": np.exp( (0.5 + 0.25*j)*(log_betas - np.mean(log_betas)) ),             \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}         )          model = Model(scenario, parameters)         model.components = [             Births_ConstantPop_VariableBirthRate,             Susceptibility,             Transmission,             Exposure,             Infection,             Infect_Random_Agents,         ]         # model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)         # rowsums = np.sum(model.patches.network, axis=1)         # model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3         # model.patches.network = row_normalizer(model.patches.network, 0.2)          mu = (1 + parameters.cbr['rates'][0] / 1000) ** (1 / 365) - 1         R0 = parameters.beta / (mu + 1 / parameters.inf_mean)         for p in range(len(model.patches)):             set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())          seed_infections_in_patch(model, ipatch=507, ninfections=3)         model.run()         test_outs.append(model.patches.incidence) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[31], line 8\n      3 for i in range(9):\n      4     for j in range(5):\n      5         data = [{\"name\": placename,\n      6                 \"population\": place.population[0],\n      7                 \"latitude\": place.latitude,\n----&gt; 8                 \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n     10         log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n     11         -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n     13         scenario = pd.DataFrame([data[507]])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[32]: Copied! <pre>plt.plot(1./365*np.arange(len(test_outs[0])), test_outs[45])\n</pre> plt.plot(1./365*np.arange(len(test_outs[0])), test_outs[45]) <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 plt.plot(1./365*np.arange(len(test_outs[0])), test_outs[45])\n\nIndexError: list index out of range</pre> In\u00a0[33]: Copied! <pre>betas = []\nscalars = []\nfor i in range(9):\n    for j in range(5):\n        betas.append(0.5+0.25*i)\n        scalars.append(0.5+0.25*j)\n</pre> betas = [] scalars = [] for i in range(9):     for j in range(5):         betas.append(0.5+0.25*i)         scalars.append(0.5+0.25*j) In\u00a0[34]: Copied! <pre>betas[35], scalars[35]\n</pre> betas[35], scalars[35] Out[34]: <pre>(2.25, 0.5)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/notebooks/EW_analysis/","title":"EW analysis","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport os\nimport sys\nfrom laser.core.propertyset import PropertySet\nimport matplotlib.pyplot as plt\n\nimport pickle\n\n\ndata_dir = os.path.join('..', \"data\")\nsys.path.append(data_dir)\n\nfrom EnglandWalesmeasles import data as engwal\ndistances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd import os import sys from laser.core.propertyset import PropertySet import matplotlib.pyplot as plt  import pickle   data_dir = os.path.join('..', \"data\") sys.path.append(data_dir)  from EnglandWalesmeasles import data as engwal distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 14\n     11 data_dir = os.path.join('..', \"data\")\n     12 sys.path.append(data_dir)\n---&gt; 14 from EnglandWalesmeasles import data as engwal\n     15 distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n     17 import laser.core\n\nModuleNotFoundError: No module named 'EnglandWalesmeasles'</pre> In\u00a0[2]: Copied! <pre>EWdata = pd.DataFrame([{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()])\n</pre> EWdata = pd.DataFrame([{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()]) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 4\n      1 EWdata = pd.DataFrame([{\"name\": placename,\n      2          \"population\": place.population[0],\n      3          \"latitude\": place.latitude,\n----&gt; 4          \"longitude\": place.longitude} for placename, place in engwal.places.items()])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[3]: Copied! <pre>EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)]\n</pre> EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)]\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[4]: Copied! <pre>EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases)\nEWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births)\nEWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))\n</pre> EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases) EWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births) EWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases)\n      2 EWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births)\n      3 EWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[5]: Copied! <pre>EWdata.loc[507]['births']/EWdata.loc[507]['population']\n</pre> EWdata.loc[507]['births']/EWdata.loc[507]['population'] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 EWdata.loc[507]['births']/EWdata.loc[507]['population']\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[6]: Copied! <pre>plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o')\n</pre> plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o') <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o')\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[7]: Copied! <pre>import re\n\noutput_dir = os.path.join('..', 'outputs3')\nparams = pd.read_csv(os.path.join(output_dir, \"params.csv\"))\n\nresults = []\n\nfor fname in range(100):\n   \n    with open(os.path.join(output_dir, 'EWoutputs_gravity_'+str(fname)+'.pkl'), \"rb\") as f:\n        x = pickle.load(f)\n    # x.cases_test: shape (days, 954)\n    cases_test = np.array(x.cases_test)\n    incidence = np.array(x.incidence)\n    populations = np.array(x.populations[0 ,:])\n    # Aggregate daily to weekly: sum every 7 days along axis 0\n    num_weeks = cases_test.shape[0] // 7\n    weekly_cases = cases_test[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)\n    weekly_incidence = incidence[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)\n    # Create a DataFrame for this parameter set, matching EWdata's structure\n    df = pd.DataFrame({\n        \"name\": EWdata[\"name\"],\n        \"population\": populations,\n        \"cases\": list(weekly_cases.T),  # each entry is a list of weekly cases for that place\n        \"incidence\": list(weekly_incidence.T)  # each entry is a list of weekly cases for that place\n    })\n    df[\"k\"] = params.iloc[fname][\"k\"]\n    df[\"b\"] = params.iloc[fname][\"b\"]\n    df[\"c\"] = params.iloc[fname][\"c\"]\n    #df.set_index([\"k\", \"a\", \"c\", \"name\"], inplace=True)\n    results.append(df)\n</pre> import re  output_dir = os.path.join('..', 'outputs3') params = pd.read_csv(os.path.join(output_dir, \"params.csv\"))  results = []  for fname in range(100):         with open(os.path.join(output_dir, 'EWoutputs_gravity_'+str(fname)+'.pkl'), \"rb\") as f:         x = pickle.load(f)     # x.cases_test: shape (days, 954)     cases_test = np.array(x.cases_test)     incidence = np.array(x.incidence)     populations = np.array(x.populations[0 ,:])     # Aggregate daily to weekly: sum every 7 days along axis 0     num_weeks = cases_test.shape[0] // 7     weekly_cases = cases_test[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)     weekly_incidence = incidence[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)     # Create a DataFrame for this parameter set, matching EWdata's structure     df = pd.DataFrame({         \"name\": EWdata[\"name\"],         \"population\": populations,         \"cases\": list(weekly_cases.T),  # each entry is a list of weekly cases for that place         \"incidence\": list(weekly_incidence.T)  # each entry is a list of weekly cases for that place     })     df[\"k\"] = params.iloc[fname][\"k\"]     df[\"b\"] = params.iloc[fname][\"b\"]     df[\"c\"] = params.iloc[fname][\"c\"]     #df.set_index([\"k\", \"a\", \"c\", \"name\"], inplace=True)     results.append(df) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[7], line 4\n      1 import re\n      3 output_dir = os.path.join('..', 'outputs3')\n----&gt; 4 params = pd.read_csv(os.path.join(output_dir, \"params.csv\"))\n      6 results = []\n      8 for fname in range(100):\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620, in _read(filepath_or_buffer, kwds)\n    617 _validate_names(kwds.get(\"names\", None))\n    619 # Create the parser.\n--&gt; 620 parser = TextFileReader(filepath_or_buffer, **kwds)\n    622 if chunksize or iterator:\n    623     return parser\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620, in TextFileReader.__init__(self, f, engine, **kwds)\n   1617     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n   1619 self.handles: IOHandles | None = None\n-&gt; 1620 self._engine = self._make_engine(f, self.engine)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880, in TextFileReader._make_engine(self, f, engine)\n   1878     if \"b\" not in mode:\n   1879         mode += \"b\"\n-&gt; 1880 self.handles = get_handle(\n   1881     f,\n   1882     mode,\n   1883     encoding=self.options.get(\"encoding\", None),\n   1884     compression=self.options.get(\"compression\", None),\n   1885     memory_map=self.options.get(\"memory_map\", False),\n   1886     is_text=is_text,\n   1887     errors=self.options.get(\"encoding_errors\", \"strict\"),\n   1888     storage_options=self.options.get(\"storage_options\", None),\n   1889 )\n   1890 assert self.handles is not None\n   1891 f = self.handles.handle\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/io/common.py:873, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n    868 elif isinstance(handle, str):\n    869     # Check whether the filename is to be opened in binary mode.\n    870     # Binary mode does not support 'encoding' and 'newline'.\n    871     if ioargs.encoding and \"b\" not in ioargs.mode:\n    872         # Encoding\n--&gt; 873         handle = open(\n    874             handle,\n    875             ioargs.mode,\n    876             encoding=ioargs.encoding,\n    877             errors=errors,\n    878             newline=\"\",\n    879         )\n    880     else:\n    881         # Binary mode\n    882         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: '../outputs3/params.csv'</pre> In\u00a0[8]: Copied! <pre>for df_result in results:\n    df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))\n    df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 ))\n</pre> for df_result in results:     df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))     df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 )) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 for df_result in results:\n      2     df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))\n      3     df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 ))\n\nNameError: name 'results' is not defined</pre> In\u00a0[9]: Copied! <pre>from scipy.optimize import curve_fit\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 1. Define fitting functions for mean and variance\ndef logistic(x, x0, k):\n    # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases\n    return 1 / (1 + np.exp(k * (x - x0)))\n\ndef fit_mean_var(x, y):\n    # Fit a logistic to the mean\n    # Initial guess: midpoint at median(x), width=1\n    p0 = [np.median(x), 1.0]\n    bounds = ([-np.inf, 0.01], [np.inf, 10.0])\n    popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)\n    return popt_mean\n\n# 3. Define similarity metric (sum of squared differences of mean and variance fits)\ndef similarity_metric(mean_data, mean_sim):\n    # Evaluate both curves on a common grid\n    x_grid = np.linspace(2.5, 6.5, 200)\n    data_curve = logistic(x_grid, *mean_data)\n    sim_curve = logistic(x_grid, *mean_sim)\n    # Similarity: sum of squared differences between the curves\n    mean_diff = np.sum((sim_curve - data_curve) ** 2)\n    return mean_diff\n\nparams = []\nsim_metrics = []\n\nfor i, df_result in enumerate(results):\n    # Plot observed and simulated data\n    logpop_obs = np.log10(EWdata['population'])\n    prop_zero_obs = EWdata['prop_zero']\n    logpop_sim = np.log10(df_result['population'])\n    prop_zero_sim = df_result['prop_zero']\n\n    # Fit to observed\n    popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)\n    popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)\n    # Similarity metric\n    sim = similarity_metric(popt_obs, popt_sim)\n    k = df_result['k'].iloc[0]\n    a = df_result['b'].iloc[0]\n    c = df_result['c'].iloc[0]\n    params.append((k, a, c))\n    sim_metrics.append(sim)\n</pre> from scipy.optimize import curve_fit from mpl_toolkits.mplot3d import Axes3D  # 1. Define fitting functions for mean and variance def logistic(x, x0, k):     # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases     return 1 / (1 + np.exp(k * (x - x0)))  def fit_mean_var(x, y):     # Fit a logistic to the mean     # Initial guess: midpoint at median(x), width=1     p0 = [np.median(x), 1.0]     bounds = ([-np.inf, 0.01], [np.inf, 10.0])     popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)     return popt_mean  # 3. Define similarity metric (sum of squared differences of mean and variance fits) def similarity_metric(mean_data, mean_sim):     # Evaluate both curves on a common grid     x_grid = np.linspace(2.5, 6.5, 200)     data_curve = logistic(x_grid, *mean_data)     sim_curve = logistic(x_grid, *mean_sim)     # Similarity: sum of squared differences between the curves     mean_diff = np.sum((sim_curve - data_curve) ** 2)     return mean_diff  params = [] sim_metrics = []  for i, df_result in enumerate(results):     # Plot observed and simulated data     logpop_obs = np.log10(EWdata['population'])     prop_zero_obs = EWdata['prop_zero']     logpop_sim = np.log10(df_result['population'])     prop_zero_sim = df_result['prop_zero']      # Fit to observed     popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)     popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)     # Similarity metric     sim = similarity_metric(popt_obs, popt_sim)     k = df_result['k'].iloc[0]     a = df_result['b'].iloc[0]     c = df_result['c'].iloc[0]     params.append((k, a, c))     sim_metrics.append(sim)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 30\n     27 params = []\n     28 sim_metrics = []\n---&gt; 30 for i, df_result in enumerate(results):\n     31     # Plot observed and simulated data\n     32     logpop_obs = np.log10(EWdata['population'])\n     33     prop_zero_obs = EWdata['prop_zero']\n\nNameError: name 'results' is not defined</pre> In\u00a0[10]: Copied! <pre># Create a DataFrame with k, b, c, and similarity score, then sort by similarity\nparams_df = pd.DataFrame(params, columns=['k', 'b', 'c'])\nparams_df['similarity'] = sim_metrics\nranked_params = params_df.sort_values('similarity').reset_index(drop=True)\nranked_params[0:20]\n</pre> # Create a DataFrame with k, b, c, and similarity score, then sort by similarity params_df = pd.DataFrame(params, columns=['k', 'b', 'c']) params_df['similarity'] = sim_metrics ranked_params = params_df.sort_values('similarity').reset_index(drop=True) ranked_params[0:20] Out[10]: k b c similarity In\u00a0[11]: Copied! <pre>params_df\n</pre> params_df Out[11]: k b c similarity In\u00a0[12]: Copied! <pre>fig, axes = plt.subplots(6, 2, figsize=(14, 18))\naxes = axes.flatten()\n\nfor idx in range(12):\n    # Get the parameter set with the idx-th lowest similarity\n    k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]\n    sim_score = ranked_params.loc[idx, 'similarity']\n    # Find the corresponding result DataFrame\n    for df in results:\n        if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):\n            df_best = df\n            break\n\n    logpop_sim = np.log10(df_best['population'])\n    prop_zero_sim = df_best['prop_zero']\n\n    # Fit logistic to simulation\n    popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)\n    # Fit logistic to observed (reuse from above)\n    popt_obs = fit_mean_var(np.log10(EWdata['population']), EWdata['prop_zero'])\n\n    xfit = np.linspace(2.8, 6.4, 200)\n    axes[idx].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)\n    axes[idx].plot(logpop_sim, prop_zero_sim, 'o', label='Simulated', alpha=0.6)\n    axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')\n    axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')\n    axes[idx].set_title(f\"k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")\n    axes[idx].set_xlabel(\"log10(Population)\")\n    axes[idx].set_ylabel(\"Proportion zero\")\n    axes[idx].legend()\n\nplt.tight_layout()\nplt.show()\n</pre>   fig, axes = plt.subplots(6, 2, figsize=(14, 18)) axes = axes.flatten()  for idx in range(12):     # Get the parameter set with the idx-th lowest similarity     k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]     sim_score = ranked_params.loc[idx, 'similarity']     # Find the corresponding result DataFrame     for df in results:         if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):             df_best = df             break      logpop_sim = np.log10(df_best['population'])     prop_zero_sim = df_best['prop_zero']      # Fit logistic to simulation     popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)     # Fit logistic to observed (reuse from above)     popt_obs = fit_mean_var(np.log10(EWdata['population']), EWdata['prop_zero'])      xfit = np.linspace(2.8, 6.4, 200)     axes[idx].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)     axes[idx].plot(logpop_sim, prop_zero_sim, 'o', label='Simulated', alpha=0.6)     axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')     axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')     axes[idx].set_title(f\"k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")     axes[idx].set_xlabel(\"log10(Population)\")     axes[idx].set_ylabel(\"Proportion zero\")     axes[idx].legend()  plt.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexes/range.py:413, in RangeIndex.get_loc(self, key)\n    412 try:\n--&gt; 413     return self._range.index(new_key)\n    414 except ValueError as err:\n\nValueError: 0 is not in range\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[12], line 6\n      2 axes = axes.flatten()\n      4 for idx in range(12):\n      5     # Get the parameter set with the idx-th lowest similarity\n----&gt; 6     k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]\n      7     sim_score = ranked_params.loc[idx, 'similarity']\n      8     # Find the corresponding result DataFrame\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1185, in _LocationIndexer.__getitem__(self, key)\n   1183     if self._is_scalar_access(key):\n   1184         return self.obj._get_value(*key, takeable=self._takeable)\n-&gt; 1185     return self._getitem_tuple(key)\n   1186 else:\n   1187     # we by definition only have the 0th axis\n   1188     axis = self.axis or 0\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1369, in _LocIndexer._getitem_tuple(self, tup)\n   1367 with suppress(IndexingError):\n   1368     tup = self._expand_ellipsis(tup)\n-&gt; 1369     return self._getitem_lowerdim(tup)\n   1371 # no multi-index, so validate all of the indexers\n   1372 tup = self._validate_tuple_indexer(tup)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1066, in _LocationIndexer._getitem_lowerdim(self, tup)\n   1062 for i, key in enumerate(tup):\n   1063     if is_label_like(key):\n   1064         # We don't need to check for tuples here because those are\n   1065         #  caught by the _is_nested_tuple_indexer check above.\n-&gt; 1066         section = self._getitem_axis(key, axis=i)\n   1068         # We should never have a scalar section here, because\n   1069         #  _getitem_lowerdim is only called after a check for\n   1070         #  is_scalar_access, which that would be.\n   1071         if section.ndim == self.ndim:\n   1072             # we're in the middle of slicing through a MultiIndex\n   1073             # revise the key wrt to `section` by inserting an _NS\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1432, in _LocIndexer._getitem_axis(self, key, axis)\n   1430 # fall thru to straight lookup\n   1431 self._validate_key(key, axis)\n-&gt; 1432 return self._get_label(key, axis=axis)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1382, in _LocIndexer._get_label(self, label, axis)\n   1380 def _get_label(self, label, axis: AxisInt):\n   1381     # GH#5567 this will fail if the label is not present in the axis.\n-&gt; 1382     return self.obj.xs(label, axis=axis)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/generic.py:4323, in NDFrame.xs(self, key, axis, level, drop_level)\n   4321             new_index = index[loc]\n   4322 else:\n-&gt; 4323     loc = index.get_loc(key)\n   4325     if isinstance(loc, np.ndarray):\n   4326         if loc.dtype == np.bool_:\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/pandas/core/indexes/range.py:415, in RangeIndex.get_loc(self, key)\n    413         return self._range.index(new_key)\n    414     except ValueError as err:\n--&gt; 415         raise KeyError(key) from err\n    416 if isinstance(key, Hashable):\n    417     raise KeyError(key)\n\nKeyError: 0</pre> In\u00a0[13]: Copied! <pre># Find the top 10 best simulations (lowest similarity)\ntop10 = ranked_params.iloc[:10]\n\n# Collect the corresponding result DataFrames\ndf_top10 = []\nfor idx, row in top10.iterrows():\n    k_best, b_best, c_best = row[['k', 'b', 'c']]\n    for df in results:\n        if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):\n            df_top10.append(df)\n            break\n\n# Stack prop_zero and population for averaging\npopulations = np.stack([np.log10(df['population'].values) for df in df_top10])\nprop_zeros = np.stack([df['prop_zero'].values for df in df_top10])\n\n# Compute mean and std across the top 10\nlogpop_sim_mean = populations.mean(axis=0)\nprop_zero_sim_mean = prop_zeros.mean(axis=0)\nprop_zero_sim_std = prop_zeros.std(axis=0)\n\nlogpop_obs = np.log10(EWdata['population'])\nprop_zero_obs = EWdata['prop_zero']\n#logpop_sim = np.log10(df_best['population'])\n#prop_zero_sim = df_best['prop_zero']\n\nplt.figure(figsize=(9, 6), dpi=200)\n# Use colorblind-friendly colors (e.g., from Color Universal Design palette)\n# Blue: #0072B2, Orange: #E69F00\nplt.scatter(logpop_obs, prop_zero_obs, s=40, color='#0072B2', label='Observed', alpha=0.8, edgecolor='k', linewidth=0.7)\nplt.scatter(logpop_sim_mean, prop_zero_sim_mean, s=40, color='#E69F00', label='Simulated', alpha=0.8, marker='s', edgecolor='k', linewidth=0.7)\n\nplt.xlabel(\"City population\", fontsize=18)\nplt.ylabel(\"Proportion of weeks \\n with no reported cases\", fontsize=18)\nplt.title(\"England + Wales 954 city dataset \\n Measles fadeout and reinvasion dynamics, 1944-1964\", fontsize=20)\nplt.legend(fontsize=16)\n# Set custom x-ticks and labels for log10 scale\nxticks = [3, 4, 5, 6]\nxticklabels = [r\"$10^{%g}$\" % x for x in xticks]\nplt.xticks(xticks, xticklabels, fontsize=15)\nplt.xticks(fontsize=15)\nplt.yticks(fontsize=15)\nplt.tight_layout()\nplt.show()\n</pre> # Find the top 10 best simulations (lowest similarity) top10 = ranked_params.iloc[:10]  # Collect the corresponding result DataFrames df_top10 = [] for idx, row in top10.iterrows():     k_best, b_best, c_best = row[['k', 'b', 'c']]     for df in results:         if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):             df_top10.append(df)             break  # Stack prop_zero and population for averaging populations = np.stack([np.log10(df['population'].values) for df in df_top10]) prop_zeros = np.stack([df['prop_zero'].values for df in df_top10])  # Compute mean and std across the top 10 logpop_sim_mean = populations.mean(axis=0) prop_zero_sim_mean = prop_zeros.mean(axis=0) prop_zero_sim_std = prop_zeros.std(axis=0)  logpop_obs = np.log10(EWdata['population']) prop_zero_obs = EWdata['prop_zero'] #logpop_sim = np.log10(df_best['population']) #prop_zero_sim = df_best['prop_zero']  plt.figure(figsize=(9, 6), dpi=200) # Use colorblind-friendly colors (e.g., from Color Universal Design palette) # Blue: #0072B2, Orange: #E69F00 plt.scatter(logpop_obs, prop_zero_obs, s=40, color='#0072B2', label='Observed', alpha=0.8, edgecolor='k', linewidth=0.7) plt.scatter(logpop_sim_mean, prop_zero_sim_mean, s=40, color='#E69F00', label='Simulated', alpha=0.8, marker='s', edgecolor='k', linewidth=0.7)  plt.xlabel(\"City population\", fontsize=18) plt.ylabel(\"Proportion of weeks \\n with no reported cases\", fontsize=18) plt.title(\"England + Wales 954 city dataset \\n Measles fadeout and reinvasion dynamics, 1944-1964\", fontsize=20) plt.legend(fontsize=16) # Set custom x-ticks and labels for log10 scale xticks = [3, 4, 5, 6] xticklabels = [r\"$10^{%g}$\" % x for x in xticks] plt.xticks(xticks, xticklabels, fontsize=15) plt.xticks(fontsize=15) plt.yticks(fontsize=15) plt.tight_layout() plt.show()  <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[13], line 14\n     11             break\n     13 # Stack prop_zero and population for averaging\n---&gt; 14 populations = np.stack([np.log10(df['population'].values) for df in df_top10])\n     15 prop_zeros = np.stack([df['prop_zero'].values for df in df_top10])\n     17 # Compute mean and std across the top 10\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/numpy/_core/shape_base.py:456, in stack(arrays, axis, out, dtype, casting)\n    454 arrays = [asanyarray(arr) for arr in arrays]\n    455 if not arrays:\n--&gt; 456     raise ValueError('need at least one array to stack')\n    458 shapes = {arr.shape for arr in arrays}\n    459 if len(shapes) != 1:\n\nValueError: need at least one array to stack</pre> In\u00a0[14]: Copied! <pre>import geopandas as gpd\n\n# Plot spatial distribution of cities with marker size proportional to log(population)\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8, 10))\n\n# Scatter plot: marker size proportional to log(population)\nsizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed\nsc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)\n\nax.set_xlabel('Longitude')\nax.set_ylabel('Latitude')\nax.set_title('Cities in England &amp; Wales\\nMarker size ~ log10(population)')\n\n# # Optional: Add England &amp; Wales borders using geopandas if available\n# try:\n#     # Plot England &amp; Wales borders from local shapefile\n#     shapefile_path = os.path.join('..', 'ne_110m_admin_0_map_units', 'ne_110m_admin_0_map_units.shp')\n#     borders = gpd.read_file(shapefile_path)\n#     # Filter for United Kingdom, then further for England and Wales if possible\n#     uk = borders[borders['SOVEREIGNT'] == 'United Kingdom']\n#     # If there are subregions, filter for England and Wales\n#     if 'NAME' in uk.columns:\n#         england_wales = uk[uk['NAME'].isin(['England', 'Wales'])]\n#         if not england_wales.empty:\n#             england_wales.boundary.plot(ax=ax, color='k', linewidth=1)\n#         else:\n#             uk.boundary.plot(ax=ax, color='k', linewidth=1)\n#     else:\n#         uk.boundary.plot(ax=ax, color='k', linewidth=1)\n# except ImportError:\n#     print(\"geopandas not installed, skipping borders.\")\n# except Exception as e:\n#     print(f\"Could not plot borders: {e}\")\n</pre> import geopandas as gpd  # Plot spatial distribution of cities with marker size proportional to log(population) import matplotlib.pyplot as plt  fig, ax = plt.subplots(figsize=(8, 10))  # Scatter plot: marker size proportional to log(population) sizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed sc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)  ax.set_xlabel('Longitude') ax.set_ylabel('Latitude') ax.set_title('Cities in England &amp; Wales\\nMarker size ~ log10(population)')  # # Optional: Add England &amp; Wales borders using geopandas if available # try: #     # Plot England &amp; Wales borders from local shapefile #     shapefile_path = os.path.join('..', 'ne_110m_admin_0_map_units', 'ne_110m_admin_0_map_units.shp') #     borders = gpd.read_file(shapefile_path) #     # Filter for United Kingdom, then further for England and Wales if possible #     uk = borders[borders['SOVEREIGNT'] == 'United Kingdom'] #     # If there are subregions, filter for England and Wales #     if 'NAME' in uk.columns: #         england_wales = uk[uk['NAME'].isin(['England', 'Wales'])] #         if not england_wales.empty: #             england_wales.boundary.plot(ax=ax, color='k', linewidth=1) #         else: #             uk.boundary.plot(ax=ax, color='k', linewidth=1) #     else: #         uk.boundary.plot(ax=ax, color='k', linewidth=1) # except ImportError: #     print(\"geopandas not installed, skipping borders.\") # except Exception as e: #     print(f\"Could not plot borders: {e}\")   <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 9\n      6 fig, ax = plt.subplots(figsize=(8, 10))\n      8 # Scatter plot: marker size proportional to log(population)\n----&gt; 9 sizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed\n     10 sc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)\n     12 ax.set_xlabel('Longitude')\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[15]: Copied! <pre>np.max(sizes)\n</pre> np.max(sizes) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[15], line 1\n----&gt; 1 np.max(sizes)\n\nNameError: name 'sizes' is not defined</pre> In\u00a0[16]: Copied! <pre>borders\n</pre> borders <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 borders\n\nNameError: name 'borders' is not defined</pre> In\u00a0[17]: Copied! <pre>#wavelet phase analysis\nimport pywt\n\ndef pad_data(x):\n    \"\"\"\n    Pad data to the next power of 2\n    \"\"\"\n    nx = len(x) # number of samples\n    nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2\n    x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2\n    offset = (nx2-nx)//2 # offset\n    x2[offset:(offset+nx)] = x # copy\n    return x2\n\ndef log_transform(x, debug=1):\n    \"\"\"\n    Log transform for case data\n    \"\"\" \n    # add one and take log\n    x = np.log(x+1)\n    # set mean=0 and std=1\n    m = np.mean(x)\n    s = np.std(x)\n    x = (x - m)/s\n    return x\n\n\ndef calc_Ws(cases):\n    # transform case data\n    log_cases = pad_data(log_transform(cases))\n\n    # setup and execute wavelet transform\n    # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet\n    wavelet = pywt.ContinuousWavelet('cmor2-1')\n\n    dt = 1 # 2 weeks\n    widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))\n    [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)\n\n    # Number of time steps in padded time series\n    nt = len(cases)\n    # trim matrix\n    offset = (cwt.shape[1] - nt) // 2\n    cwt = cwt[:, offset:offset + nt]\n\n    return cwt, frequencies\n</pre> #wavelet phase analysis import pywt  def pad_data(x):     \"\"\"     Pad data to the next power of 2     \"\"\"     nx = len(x) # number of samples     nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2     x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2     offset = (nx2-nx)//2 # offset     x2[offset:(offset+nx)] = x # copy     return x2  def log_transform(x, debug=1):     \"\"\"     Log transform for case data     \"\"\"      # add one and take log     x = np.log(x+1)     # set mean=0 and std=1     m = np.mean(x)     s = np.std(x)     x = (x - m)/s     return x   def calc_Ws(cases):     # transform case data     log_cases = pad_data(log_transform(cases))      # setup and execute wavelet transform     # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet     wavelet = pywt.ContinuousWavelet('cmor2-1')      dt = 1 # 2 weeks     widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))     [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)      # Number of time steps in padded time series     nt = len(cases)     # trim matrix     offset = (cwt.shape[1] - nt) // 2     cwt = cwt[:, offset:offset + nt]      return cwt, frequencies  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[17], line 2\n      1 #wavelet phase analysis\n----&gt; 2 import pywt\n      4 def pad_data(x):\n      5     \"\"\"\n      6     Pad data to the next power of 2\n      7     \"\"\"\n\nModuleNotFoundError: No module named 'pywt'</pre> In\u00a0[18]: Copied! <pre># Get the cases for London from EWdata\nlondon_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\nlondon_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\nref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten()))\ndistances_from_london = distances[london_idx, :]\n\nx = np.zeros(len(EWdata))\ny = np.zeros(len(EWdata))\ny2 = np.zeros(len(EWdata))\nfor i, row in EWdata.iterrows():\n    if distances_from_london[i] &gt; 30:\n        continue\n    cwt, frequencies = calc_Ws(row[\"cases\"].flatten())\n    diff = ref_cwt*np.conj(cwt)\n    ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))\n    diff1 = diff[ind[0], :]\n    x[i] = distances_from_london[i]\n    y[i] = np.angle(np.mean(diff1))\n    ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))\n    diff2 = diff[ind2[0], :]\n    y2[i] = np.angle(np.mean(diff2))\n\nplt.plot(x, y, 'o')\nplt.xlabel(\"Distance from London\")\nplt.ylabel(\"Phase difference\")\nplt.title(\"Phase difference of London wavelet transform\")\nplt.show()\n</pre> # Get the cases for London from EWdata london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0] london_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0] ref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten())) distances_from_london = distances[london_idx, :]  x = np.zeros(len(EWdata)) y = np.zeros(len(EWdata)) y2 = np.zeros(len(EWdata)) for i, row in EWdata.iterrows():     if distances_from_london[i] &gt; 30:         continue     cwt, frequencies = calc_Ws(row[\"cases\"].flatten())     diff = ref_cwt*np.conj(cwt)     ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))     diff1 = diff[ind[0], :]     x[i] = distances_from_london[i]     y[i] = np.angle(np.mean(diff1))     ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))     diff2 = diff[ind2[0], :]     y2[i] = np.angle(np.mean(diff2))  plt.plot(x, y, 'o') plt.xlabel(\"Distance from London\") plt.ylabel(\"Phase difference\") plt.title(\"Phase difference of London wavelet transform\") plt.show()  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 2\n      1 # Get the cases for London from EWdata\n----&gt; 2 london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\n      3 london_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\n      4 ref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten()))\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[19]: Copied! <pre>plt.plot(x, -y*180/np.pi, 'o')\nplt.xlim(5, 30)\nplt.ylim(-90, 0)\nplt.xlabel(\"Distance from London\")\nplt.ylabel(\"Phase difference\")\nplt.title(\"Phase difference of London wavelet transform\")\nplt.show()\n</pre> plt.plot(x, -y*180/np.pi, 'o') plt.xlim(5, 30) plt.ylim(-90, 0) plt.xlabel(\"Distance from London\") plt.ylabel(\"Phase difference\") plt.title(\"Phase difference of London wavelet transform\") plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[19], line 1\n----&gt; 1 plt.plot(x, -y*180/np.pi, 'o')\n      2 plt.xlim(5, 30)\n      3 plt.ylim(-90, 0)\n\nNameError: name 'x' is not defined</pre> In\u00a0[20]: Copied! <pre>len(results)\n</pre> len(results)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 len(results)\n\nNameError: name 'results' is not defined</pre> In\u00a0[21]: Copied! <pre># Get the cases for London from EWdata\n# For each simulation in results, compute phase difference arrays y_sim and y2_sim\nphase_diff_results = []\n\nlondon_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\ndistances_from_london = distances[london_idx, :]\n\nfor sim_idx, df_sim in enumerate(results):\n    # Get London cases for this simulation\n    london_cases_sim = df_sim[df_sim[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\n    ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())\n    x_sim = np.zeros(len(df_sim))\n    y_sim = np.zeros(len(df_sim))\n    y2_sim = np.zeros(len(df_sim))\n    for i, row in df_sim.iterrows():\n        if distances_from_london[i] &gt; 30:\n            continue\n        cwt_sim, frequencies_sim = calc_Ws(np.array(row[\"cases\"][520:]).flatten())\n        diff_sim = ref_cwt_sim * np.conj(cwt_sim)\n        ind = np.where(np.logical_and(frequencies_sim &lt; 1/(1.5 * 52), frequencies_sim &gt; 1 / (3 * 52)))\n        diff1_sim = diff_sim[ind[0], :]\n        x_sim[i] = distances_from_london[i]\n        y_sim[i] = np.angle(np.mean(diff1_sim))\n        ind2 = np.where(np.logical_and(frequencies_sim &lt; 1/(0.75 * 52), frequencies_sim &gt; 1 / (1.25 * 52)))\n        diff2_sim = diff_sim[ind2[0], :]\n        y2_sim[i] = np.angle(np.mean(diff2_sim))\n    phase_diff_results.append({\n        \"sim_idx\": sim_idx,\n        \"x\": x_sim,\n        \"y\": y_sim,\n        \"y2\": y2_sim\n    })\n</pre> # Get the cases for London from EWdata # For each simulation in results, compute phase difference arrays y_sim and y2_sim phase_diff_results = []  london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0] distances_from_london = distances[london_idx, :]  for sim_idx, df_sim in enumerate(results):     # Get London cases for this simulation     london_cases_sim = df_sim[df_sim[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]     ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())     x_sim = np.zeros(len(df_sim))     y_sim = np.zeros(len(df_sim))     y2_sim = np.zeros(len(df_sim))     for i, row in df_sim.iterrows():         if distances_from_london[i] &gt; 30:             continue         cwt_sim, frequencies_sim = calc_Ws(np.array(row[\"cases\"][520:]).flatten())         diff_sim = ref_cwt_sim * np.conj(cwt_sim)         ind = np.where(np.logical_and(frequencies_sim &lt; 1/(1.5 * 52), frequencies_sim &gt; 1 / (3 * 52)))         diff1_sim = diff_sim[ind[0], :]         x_sim[i] = distances_from_london[i]         y_sim[i] = np.angle(np.mean(diff1_sim))         ind2 = np.where(np.logical_and(frequencies_sim &lt; 1/(0.75 * 52), frequencies_sim &gt; 1 / (1.25 * 52)))         diff2_sim = diff_sim[ind2[0], :]         y2_sim[i] = np.angle(np.mean(diff2_sim))     phase_diff_results.append({         \"sim_idx\": sim_idx,         \"x\": x_sim,         \"y\": y_sim,         \"y2\": y2_sim     }) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[21], line 5\n      1 # Get the cases for London from EWdata\n      2 # For each simulation in results, compute phase difference arrays y_sim and y2_sim\n      3 phase_diff_results = []\n----&gt; 5 london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\n      6 distances_from_london = distances[london_idx, :]\n      8 for sim_idx, df_sim in enumerate(results):\n      9     # Get London cases for this simulation\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[22]: Copied! <pre>with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:\n    pickle.dump(phase_diff_results, f)\n</pre> with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:     pickle.dump(phase_diff_results, f) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[22], line 1\n----&gt; 1 with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:\n      2     pickle.dump(phase_diff_results, f)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:343, in _modified_open(file, *args, **kwargs)\n    336 if file in {0, 1, 2}:\n    337     raise ValueError(\n    338         f\"IPython won't let you open fd={file} by default \"\n    339         \"as it is likely to crash IPython. If you know what you are doing, \"\n    340         \"you can use builtins' open.\"\n    341     )\n--&gt; 343 return io_open(file, *args, **kwargs)\n\nFileNotFoundError: [Errno 2] No such file or directory: '../outputs3/phase_diff_results2.pkl'</pre> In\u00a0[23]: Copied! <pre>with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:\n    phase_diff_results = pickle.load(f)\n</pre> with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:     phase_diff_results = pickle.load(f) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:\n      2     phase_diff_results = pickle.load(f)\n\nFile /opt/hostedtoolcache/Python/3.12.12/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:343, in _modified_open(file, *args, **kwargs)\n    336 if file in {0, 1, 2}:\n    337     raise ValueError(\n    338         f\"IPython won't let you open fd={file} by default \"\n    339         \"as it is likely to crash IPython. If you know what you are doing, \"\n    340         \"you can use builtins' open.\"\n    341     )\n--&gt; 343 return io_open(file, *args, **kwargs)\n\nFileNotFoundError: [Errno 2] No such file or directory: '../outputs3/phase_diff_results2.pkl'</pre> In\u00a0[24]: Copied! <pre>params_df\n</pre> params_df Out[24]: k b c similarity In\u00a0[25]: Copied! <pre>for ind in range(100):\n    fig, axs = plt.subplots(1, 2, figsize=(12, 5))\n\n    # Left plot: Phase difference\n    axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')\n    axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')\n    axs[0].set_xlim(5, 30)\n    axs[0].set_ylim(-90, 90)\n    axs[0].set_xlabel(\"Distance from London\")\n    axs[0].set_ylabel(\"Phase difference\")\n    axs[0].set_title(\"Phase difference of London wavelet transform\")\n    axs[0].legend()\n\n    # Right plot: Proportion zero vs log10(population)\n    axs[1].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)\n    axs[1].plot(np.log10(results[10]['population']), results[ind][\"prop_low\"], '.', label='Simulated')\n    axs[1].set_xlabel(\"log10(Population)\")\n    axs[1].set_ylabel(\"Proportion zero\")\n    axs[1].set_title(\"Proportion zero vs log10(Population)\")\n    axs[1].legend()\n\n    plt.tight_layout()\n    plt.show()\n</pre> for ind in range(100):     fig, axs = plt.subplots(1, 2, figsize=(12, 5))      # Left plot: Phase difference     axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')     axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')     axs[0].set_xlim(5, 30)     axs[0].set_ylim(-90, 90)     axs[0].set_xlabel(\"Distance from London\")     axs[0].set_ylabel(\"Phase difference\")     axs[0].set_title(\"Phase difference of London wavelet transform\")     axs[0].legend()      # Right plot: Proportion zero vs log10(population)     axs[1].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)     axs[1].plot(np.log10(results[10]['population']), results[ind][\"prop_low\"], '.', label='Simulated')     axs[1].set_xlabel(\"log10(Population)\")     axs[1].set_ylabel(\"Proportion zero\")     axs[1].set_title(\"Proportion zero vs log10(Population)\")     axs[1].legend()      plt.tight_layout()     plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[25], line 5\n      2 fig, axs = plt.subplots(1, 2, figsize=(12, 5))\n      4 # Left plot: Phase difference\n----&gt; 5 axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')\n      6 axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')\n      7 axs[0].set_xlim(5, 30)\n\nNameError: name 'x' is not defined</pre> In\u00a0[26]: Copied! <pre>from scipy.spatial.distance import euclidean\n\n# 1. Compute similarity between observed and each simulation's phase difference curve\n# We'll use the y (phase difference) vs x (distance) arrays\n\n# Only consider cities within 5-30 km (as in previous plots)\nmask = (x &gt;= 5) &amp; (x &lt;= 30)\nx_obs = x[mask]\ny_obs = y[mask]\n\nsim_scores = []\nfor sim in phase_diff_results:\n    x_sim = sim[\"x\"]\n    y_sim = sim[\"y\"]\n    # Interpolate simulation phase difference to observed x values for fair comparison\n    mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)\n    if np.sum(mask_sim) &lt; 5:  # skip if not enough points\n        sim_scores.append(np.inf)\n        continue\n    # Interpolate simulation y to observed x points\n    try:\n        y_sim_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])\n        score = np.sum((y_obs - y_sim_interp) ** 2)\n    except Exception:\n        score = np.inf\n    sim_scores.append(score)\n\n# 2. Get indices of the 10 best simulations (lowest scores)\ntop10_idx = np.argsort(sim_scores)[:10]\n\n# 3. Plot\nplt.figure(figsize=(8, 6), dpi=300)\nplt.plot(x_obs, -y_obs*180/np.pi, 'o', color='#0072B2', label='Observed', linewidth=2, markersize=6)\n\n# Color palette for simulations\nimport matplotlib.cm as cm\ncolors = cm.viridis(np.linspace(0, 1, 10))\n# Average the top 10 simulations' phase difference curves (interpolated to observed x points)\ny_sims_interp = []\nfor idx in top10_idx:\n    sim = phase_diff_results[idx]\n    x_sim = sim[\"x\"]\n    y_sim = sim[\"y\"]\n    mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)\n    if np.sum(mask_sim) &lt; 5:\n        continue\n    y_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])\n    y_sims_interp.append(y_interp)\ny_sims_interp = np.array(y_sims_interp)\ny_sim_mean = np.mean(y_sims_interp, axis=0)\ny_sim_std = np.std(y_sims_interp, axis=0)\n\n#plt.plot(x_obs, -y_sim_mean*180/np.pi, 'o', color='#E69F00', linewidth=2.5, label='Simulated (mean)')\nplt.errorbar(x_obs, -y_sim_mean*180/np.pi, yerr=y_sim_std*180/np.pi, marker='s', fmt='none', ecolor='#E69F00', capsize=3, label='Simulated (\u00b11 std)')\n\nplt.xlim(5, 30)\nplt.ylim(-90, 20)\nplt.xlabel(\"Distance from London (km)\", fontsize=14)\nplt.ylabel(\"Phase difference (degrees)\", fontsize=14)\nplt.title(\"Top 10 Simulations: Phase difference vs. Distance\", fontsize=16)\nplt.legend(fontsize=10, loc='lower left', ncol=2, frameon=True)\nplt.tight_layout()\nplt.grid(True, linestyle='--', alpha=0.3)\nplt.show()\n</pre> from scipy.spatial.distance import euclidean  # 1. Compute similarity between observed and each simulation's phase difference curve # We'll use the y (phase difference) vs x (distance) arrays  # Only consider cities within 5-30 km (as in previous plots) mask = (x &gt;= 5) &amp; (x &lt;= 30) x_obs = x[mask] y_obs = y[mask]  sim_scores = [] for sim in phase_diff_results:     x_sim = sim[\"x\"]     y_sim = sim[\"y\"]     # Interpolate simulation phase difference to observed x values for fair comparison     mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)     if np.sum(mask_sim) &lt; 5:  # skip if not enough points         sim_scores.append(np.inf)         continue     # Interpolate simulation y to observed x points     try:         y_sim_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])         score = np.sum((y_obs - y_sim_interp) ** 2)     except Exception:         score = np.inf     sim_scores.append(score)  # 2. Get indices of the 10 best simulations (lowest scores) top10_idx = np.argsort(sim_scores)[:10]  # 3. Plot plt.figure(figsize=(8, 6), dpi=300) plt.plot(x_obs, -y_obs*180/np.pi, 'o', color='#0072B2', label='Observed', linewidth=2, markersize=6)  # Color palette for simulations import matplotlib.cm as cm colors = cm.viridis(np.linspace(0, 1, 10)) # Average the top 10 simulations' phase difference curves (interpolated to observed x points) y_sims_interp = [] for idx in top10_idx:     sim = phase_diff_results[idx]     x_sim = sim[\"x\"]     y_sim = sim[\"y\"]     mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)     if np.sum(mask_sim) &lt; 5:         continue     y_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])     y_sims_interp.append(y_interp) y_sims_interp = np.array(y_sims_interp) y_sim_mean = np.mean(y_sims_interp, axis=0) y_sim_std = np.std(y_sims_interp, axis=0)  #plt.plot(x_obs, -y_sim_mean*180/np.pi, 'o', color='#E69F00', linewidth=2.5, label='Simulated (mean)') plt.errorbar(x_obs, -y_sim_mean*180/np.pi, yerr=y_sim_std*180/np.pi, marker='s', fmt='none', ecolor='#E69F00', capsize=3, label='Simulated (\u00b11 std)')  plt.xlim(5, 30) plt.ylim(-90, 20) plt.xlabel(\"Distance from London (km)\", fontsize=14) plt.ylabel(\"Phase difference (degrees)\", fontsize=14) plt.title(\"Top 10 Simulations: Phase difference vs. Distance\", fontsize=16) plt.legend(fontsize=10, loc='lower left', ncol=2, frameon=True) plt.tight_layout() plt.grid(True, linestyle='--', alpha=0.3) plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[26], line 7\n      1 from scipy.spatial.distance import euclidean\n      3 # 1. Compute similarity between observed and each simulation's phase difference curve\n      4 # We'll use the y (phase difference) vs x (distance) arrays\n      5 \n      6 # Only consider cities within 5-30 km (as in previous plots)\n----&gt; 7 mask = (x &gt;= 5) &amp; (x &lt;= 30)\n      8 x_obs = x[mask]\n      9 y_obs = y[mask]\n\nNameError: name 'x' is not defined</pre> In\u00a0[27]: Copied! <pre># Compute the total cases across all towns for each simulation in results\ntotal_cases_per_sim = []\n\nfor df in results:\n    # Each row's \"cases\" is a list/array of weekly cases for that town\n    # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)\n    cases_matrix = np.stack(df[\"incidence\"].values)\n    # Sum across towns (axis=0) to get total cases per week\n    total_cases = cases_matrix.sum(axis=0)\n    total_cases_per_sim.append(total_cases)\n</pre> # Compute the total cases across all towns for each simulation in results total_cases_per_sim = []  for df in results:     # Each row's \"cases\" is a list/array of weekly cases for that town     # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)     cases_matrix = np.stack(df[\"incidence\"].values)     # Sum across towns (axis=0) to get total cases per week     total_cases = cases_matrix.sum(axis=0)     total_cases_per_sim.append(total_cases) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[27], line 4\n      1 # Compute the total cases across all towns for each simulation in results\n      2 total_cases_per_sim = []\n----&gt; 4 for df in results:\n      5     # Each row's \"cases\" is a list/array of weekly cases for that town\n      6     # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)\n      7     cases_matrix = np.stack(df[\"incidence\"].values)\n      8     # Sum across towns (axis=0) to get total cases per week\n\nNameError: name 'results' is not defined</pre> In\u00a0[28]: Copied! <pre>plt.plot(total_cases_per_sim[39], label='Sim 1')\n</pre> plt.plot(total_cases_per_sim[39], label='Sim 1') <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 plt.plot(total_cases_per_sim[39], label='Sim 1')\n\nIndexError: list index out of range</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/notebooks/distributions/","title":"Numba Compatible Distributions","text":"In\u00a0[1]: Copied! <pre>import numba as nb\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nimport laser.core.distributions as distributions\n</pre> import numba as nb import numpy as np from matplotlib import pyplot as plt  import laser.core.distributions as distributions  In\u00a0[2]: Copied! <pre>def plot_histogram(data: list[tuple[np.ndarray, str, str]], bins: int = 101) -&gt; None:\n\n    for d, label, color in data:\n        plt.hist(d, bins=bins, density=True, alpha=0.6, color=color, label=label)\n    plt.xlabel('Value')\n    plt.ylabel('Density')\n    plt.title('Histogram')\n    plt.grid(True)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n</pre> def plot_histogram(data: list[tuple[np.ndarray, str, str]], bins: int = 101) -&gt; None:      for d, label, color in data:         plt.hist(d, bins=bins, density=True, alpha=0.6, color=color, label=label)     plt.xlabel('Value')     plt.ylabel('Density')     plt.title('Histogram')     plt.grid(True)     plt.legend()     plt.tight_layout()     plt.show()  In\u00a0[3]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor alpha, beta, color in [(0.5, 0.5, \"red\"), (5.0, 1.0, \"blue\"), (1.0, 3.0, \"green\"), (2.0, 2.0, \"purple\"), (2.0, 5.0, \"orange\")]:\n\n    dist = distributions.beta(a=alpha, b=beta)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples, f'Beta({alpha}, {beta})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for alpha, beta, color in [(0.5, 0.5, \"red\"), (5.0, 1.0, \"blue\"), (1.0, 3.0, \"green\"), (2.0, 2.0, \"purple\"), (2.0, 5.0, \"orange\")]:      dist = distributions.beta(a=alpha, b=beta)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples, f'Beta({alpha}, {beta})', color))  plot_histogram(traces)  In\u00a0[4]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor p, n, color in [(0.5, 20, \"blue\"), (0.7, 20, \"green\"), (0.5, 40, \"red\")]:\n\n    dist = distributions.binomial(n=n, p=p)\n    distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))\n\n    traces.append((samples, f'Binomial({n}, {p})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for p, n, color in [(0.5, 20, \"blue\"), (0.7, 20, \"green\"), (0.5, 40, \"red\")]:      dist = distributions.binomial(n=n, p=p)     distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))      traces.append((samples, f'Binomial({n}, {p})', color))  plot_histogram(traces)  In\u00a0[5]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor lamda, color in [(0.5, \"red\"), (1.0, \"green\"), (1.5, \"lightblue\")]:\n\n    dist = distributions.exponential(scale=1/lamda)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt; 8], f'Exponential(1/{lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for lamda, color in [(0.5, \"red\"), (1.0, \"green\"), (1.5, \"lightblue\")]:      dist = distributions.exponential(scale=1/lamda)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt; 8], f'Exponential(1/{lamda})', color))  plot_histogram(traces)  In\u00a0[6]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor alpha, theta, color in [(1.0, 2.0, \"red\"), (2.0, 2.0, \"orange\"), (3.0, 2.0, \"yellow\"), (5.0, 1.0, \"green\"), (9.0, 0.5, \"black\"), (7.5, 1.0, \"blue\"), (0.5, 1.0, \"purple\")]:\n\n    dist = distributions.gamma(shape=alpha, scale=theta)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt; 0.25) &amp; (samples &lt;= 15)], f'Gamma({alpha}, {theta})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for alpha, theta, color in [(1.0, 2.0, \"red\"), (2.0, 2.0, \"orange\"), (3.0, 2.0, \"yellow\"), (5.0, 1.0, \"green\"), (9.0, 0.5, \"black\"), (7.5, 1.0, \"blue\"), (0.5, 1.0, \"purple\")]:      dist = distributions.gamma(shape=alpha, scale=theta)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt; 0.25) &amp; (samples &lt;= 15)], f'Gamma({alpha}, {theta})', color))  plot_histogram(traces)  In\u00a0[7]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, s, color in [(5, 2, \"blue\"), (9, 3, \"green\"), (9, 4, \"red\"), (6, 2, \"lightblue\"), (2, 1, \"purple\")]:\n\n    dist = distributions.logistic(loc=mu, scale=s)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 25)], f'Logistic({mu}, {s})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, s, color in [(5, 2, \"blue\"), (9, 3, \"green\"), (9, 4, \"red\"), (6, 2, \"lightblue\"), (2, 1, \"purple\")]:      dist = distributions.logistic(loc=mu, scale=s)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 25)], f'Logistic({mu}, {s})', color))  plot_histogram(traces)  In\u00a0[8]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, sigma, color in [(0, 1, \"blue\"), (0, 0.5, \"green\"), (0, 0.25, \"red\")]:\n\n    dist = distributions.lognormal(mean=mu, sigma=sigma)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt;= 3], f'Lognormal({mu}, {sigma})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, sigma, color in [(0, 1, \"blue\"), (0, 0.5, \"green\"), (0, 0.25, \"red\")]:      dist = distributions.lognormal(mean=mu, sigma=sigma)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt;= 3], f'Lognormal({mu}, {sigma})', color))  plot_histogram(traces)  In\u00a0[9]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, sigmasq, color in [(0, 0.2, \"blue\"), (0, 1.0, \"red\"), (0, 5.0, \"orange\"), (-2, 0.5, \"green\")]:\n\n    dist = distributions.normal(loc=mu, scale=np.sqrt(sigmasq))\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 5)], f'Normal({mu}, {np.sqrt(sigmasq)})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, sigmasq, color in [(0, 0.2, \"blue\"), (0, 1.0, \"red\"), (0, 5.0, \"orange\"), (-2, 0.5, \"green\")]:      dist = distributions.normal(loc=mu, scale=np.sqrt(sigmasq))     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 5)], f'Normal({mu}, {np.sqrt(sigmasq)})', color))  plot_histogram(traces)  In\u00a0[10]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor lamda, color in [(1, \"orange\"), (4, \"purple\"), (10, \"lightblue\")]:\n\n    dist = distributions.poisson(lam=lamda)\n    distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))\n\n    traces.append((samples[samples &lt;= 20], f'Poisson({lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for lamda, color in [(1, \"orange\"), (4, \"purple\"), (10, \"lightblue\")]:      dist = distributions.poisson(lam=lamda)     distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))      traces.append((samples[samples &lt;= 20], f'Poisson({lamda})', color))  plot_histogram(traces)  In\u00a0[11]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor low, high, color in [(0.0, 1.0, \"red\"), (0.25, 1.25, \"orange\"), (0.0, 2.0, \"green\"), (-1.0, 1.0,\"blue\"), (2.71828, 3.14159, \"indigo\"), (1.30, 4.20, \"violet\")]:\n\n    dist = distributions.uniform(low=low, high=high)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples, f'Uniform({low}, {high})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for low, high, color in [(0.0, 1.0, \"red\"), (0.25, 1.25, \"orange\"), (0.0, 2.0, \"green\"), (-1.0, 1.0,\"blue\"), (2.71828, 3.14159, \"indigo\"), (1.30, 4.20, \"violet\")]:      dist = distributions.uniform(low=low, high=high)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples, f'Uniform({low}, {high})', color))  plot_histogram(traces)  In\u00a0[12]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor k, lamda, color in [(0.5, 1.0, \"blue\"), (1.0, 1.0, \"red\"), (1.5, 1.0, \"purple\"), (5.0, 1.0, \"green\")]:\n\n    dist = distributions.weibull(a=k, lam=lamda)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt;= 2.5], f'Weibull({k}, {lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for k, lamda, color in [(0.5, 1.0, \"blue\"), (1.0, 1.0, \"red\"), (1.5, 1.0, \"purple\"), (5.0, 1.0, \"green\")]:      dist = distributions.weibull(a=k, lam=lamda)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt;= 2.5], f'Weibull({k}, {lamda})', color))  plot_histogram(traces)"},{"location":"tutorials/notebooks/distributions/#numba-compatible-distributions","title":"Numba Compatible Distributions\u00b6","text":"<p>Test each of the Numba compatible distributions.</p>"},{"location":"tutorials/notebooks/distributions/#beta","title":"Beta\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#binomial","title":"Binomial\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#exponential","title":"Exponential\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#gamma","title":"Gamma\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#logistic","title":"Logistic\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#lognormal","title":"LogNormal\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#multinomial","title":"Multinomial\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#negativebinomial","title":"NegativeBinomial\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#normal","title":"Normal\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#poisson","title":"Poisson\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#uniform","title":"Uniform\u00b6","text":""},{"location":"tutorials/notebooks/distributions/#weibull","title":"Weibull\u00b6","text":""}]}