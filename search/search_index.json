{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>LASER (Lightweight Agent Spatial modeling for ERadication) is a framework for building agent-based infectious disease models with an emphasis on spatial modeling and efficient computation at scale.</p> <p><code>laser-generic</code> builds on top of <code>laser-core</code>, offering a set of ready-to-use, generic disease model components (e.g., SI, SIS, SIR dynamics, births, deaths, vaccination).</p> <ul> <li>Free software: MIT license</li> </ul>"},{"location":"#new-model-components","title":"New model components","text":"<p><code>laser-generic</code> adds additional modeling components to those developed for <code>laser-core</code>. They include:</p>"},{"location":"#infection-transmission","title":"Infection &amp; transmission","text":"<ul> <li><code>Infection()</code> / <code>Infection_SIS()</code> \u2013 intrahost progression for SI and SIS models.</li> <li><code>Susceptibility()</code> \u2013 manages agent susceptibility.</li> <li><code>Exposure()</code> \u2013 models exposed (latent) state with timers.</li> <li><code>Transmission()</code> / <code>TransmissionSIR()</code> \u2013 interhost transmission dynamics.</li> <li><code>Infect_Agents_In_Patch()</code> / <code>Infect_Random_Agents()</code> \u2013 stochastic infection events.</li> </ul>"},{"location":"#births-demographics","title":"Births &amp; demographics","text":"<ul> <li><code>Births()</code> \u2013 demographic process, assigning DOB and node IDs.</li> <li><code>Births_ConstantPop()</code> \u2013 keeps population constant by matching births to deaths.</li> <li><code>Births_ConstantPop_VariableBirthRate()</code> \u2013 constant population but with variable crude birth rates.</li> </ul>"},{"location":"#immunization","title":"Immunization","text":"<ul> <li><code>ImmunizationCampaign()</code> \u2013 age-targeted, periodic campaigns.</li> <li><code>RoutineImmunization()</code> \u2013 ongoing routine immunization at target ages.</li> <li><code>immunize_in_age_window()</code> \u2013 helper to immunize within an age band.</li> </ul>"},{"location":"#initialization-seeding","title":"Initialization &amp; seeding","text":"<ul> <li><code>seed_infections_in_patch()</code> / <code>seed_infections_randomly()</code> / <code>seed_infections_randomly_SI()</code> \u2013 seed infections at start.</li> <li><code>set_initial_susceptibility_in_patch()</code> / <code>set_initial_susceptibility_randomly()</code> \u2013 initialize susceptibility.</li> </ul>"},{"location":"#utilities","title":"Utilities","text":"<ul> <li><code>calc_capacity()</code> \u2013 computes population capacity given births and ticks.</li> <li><code>calc_distances()</code> \u2013 helper for spatial coupling via geocoordinates.</li> <li><code>get_default_parameters()</code> \u2013 returns baseline parameters.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install laser-generic\n</code></pre> <p>You can also install the in-development version with:</p> <pre><code>pip install https://github.com/InstituteforDiseaseModeling/laser-generic/archive/main.zip\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>https://institutefordiseasemodeling.github.io/laser-generic</p>"},{"location":"#development","title":"Development","text":"<p>To run all the tests run:</p> <pre><code>tox\n</code></pre> <p>Note, to combine the coverage data from all the tox environments run:</p> <p>Windows: <pre><code>set PYTEST_ADDOPTS=--cov-append\n tox\n</code></pre></p> <p>Other: <pre><code>PYTEST_ADDOPTS=--cov-append tox\n</code></pre></p>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li> <p> Tutorials</p> <p>An interactive tour of key features.</p> <p> Tutorials</p> </li> <li> <p> Reference</p> <p>Full details on all classes and functions.</p> <p> API reference</p> </li> <li> <p> What's new</p> <p>See what's in the latest releases.</p> <p> What's new</p> </li> <li> <p> Glossary</p> <p>Look up unfamiliar terms.</p> <p> Glossary</p> </li> </ul>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Christopher Lorton - https://www.idmod.org</li> <li>Jonathan Bloedow - https://www.idmod.org</li> <li>Katherine Rosenfeld - https://www.idmod.org</li> <li>Kevin McCarthy - https://www.idmod.org</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#top-level-modules","title":"Top-level modules","text":"<p>This module defines a <code>Model</code> class for simulating classic \"generic\" compartmental disease models (SI, SIS, SIR, SEIR, ...). The model supports simple demographics (e.g., births, deaths, aging) and can simulate either a single population patch or multiple patches with an arbitrary connection structure.</p> <p>Imports: - datetime: For handling date and time operations. - click: For command-line interface utilities. - numpy as np: For numerical operations. - pandas as pd: For data handling and tabular reports. - laser_core.laserframe: Provides the LaserFrame class for structured data arrays. - laser_core.propertyset: Provides the PropertySet class for simulation parameters. - laser_core.random: Provides random number generator seeding utilities. - matplotlib: For plotting results. - tqdm: For progress bar visualization during runs.</p>"},{"location":"api/#laser.generic.model.Model","title":"<code>Model(scenario, parameters, name='generic')</code>","text":"<p>A LASER simulation model for generic disease dynamics.</p> <p>The <code>Model</code> manages:   - Patch-level populations and their attributes.   - Agent-level population initialization.   - Integration of components (e.g., Births, Infection, Immunization).   - Execution of simulation ticks via <code>run()</code>.   - Recording of metrics and plotting/visualization utilities.</p> <p>Typical usage: <pre><code>scenario = pd.DataFrame({\"population\": [1000, 500], \"latitude\": [...], \"longitude\": [...]})\nparams = PropertySet({\"nticks\": 100, \"seed\": 123, \"verbose\": True})\nmodel = Model(scenario, params)\nmodel.components = [Births, Infection, ImmunizationCampaign]\nmodel.run()\nmodel.visualize(pdf=True)\n</code></pre></p> <p>Initialize the model with a scenario and simulation parameters.</p>"},{"location":"api/#laser.generic.model.Model--parameters","title":"Parameters","text":"<p>scenario : pd.DataFrame     Patch-level data. Must include at least:     - <code>population</code>: initial population per patch.     - <code>latitude</code>: latitude coordinate.     - <code>longitude</code>: longitude coordinate.     May also include optional columns like <code>geometry</code>. parameters : PropertySet     Simulation parameters. Must include:     - <code>nticks</code> (int): number of simulation ticks.     - <code>seed</code> (int, optional): RNG seed.     - <code>verbose</code> (bool, optional): enable verbose logging. name : str, optional     Name of the model. Default is \"generic\".</p>"},{"location":"api/#laser.generic.model.Model--side-effects","title":"Side Effects","text":"<ul> <li>Seeds the random number generator.</li> <li>Initializes patches and population.</li> </ul>"},{"location":"api/#laser.generic.model.Model.components","title":"<code>components</code>  <code>property</code> <code>writable</code>","text":"<p>Retrieve the list of model components currently configured.</p>"},{"location":"api/#laser.generic.model.Model.components--returns","title":"Returns","text":"<p>list     List of component classes used in the model.</p>"},{"location":"api/#laser.generic.model.Model.__call__","title":"<code>__call__(model, tick)</code>","text":"<p>Advance patch populations one tick forward.</p> <p>Copies population counts from tick <code>t</code> to tick <code>t+1</code>. Components such as births or mortality may then update these values.</p>"},{"location":"api/#laser.generic.model.Model.__call__--parameters","title":"Parameters","text":"<p>model : Model     The current model instance. tick : int     Current tick index.</p>"},{"location":"api/#laser.generic.model.Model.plot","title":"<code>plot(fig=None)</code>","text":"<p>Yield three plots for model visualization:</p> <ol> <li>A scatter plot of scenario patches by location and population.</li> <li>A histogram of day-of-birth values for the initial population.    (requires that <code>population.dob</code> exists, e.g. via a Births component).</li> <li>A pie chart of cumulative update phase timings.</li> </ol>"},{"location":"api/#laser.generic.model.Model.plot--parameters","title":"Parameters","text":"<p>fig : Figure, optional     An existing matplotlib Figure. If None, a new figure is created.</p>"},{"location":"api/#laser.generic.model.Model.plot--yields","title":"Yields","text":"<p>None     Each <code>yield</code> produces one plot, so iterating this generator     produces three figures sequentially.</p>"},{"location":"api/#laser.generic.model.Model.run","title":"<code>run()</code>","text":"<p>Execute the model simulation.</p> <p>For each tick (0..nticks-1):   - Run all censuses (recording metrics).   - Run all phases (update components).   - Record execution times per census/phase.</p> After completion <ul> <li>Records <code>self.metrics</code>, <code>self.tstart</code>, and <code>self.tfinish</code>.</li> <li>Prints a timing summary if verbose mode is enabled.</li> </ul>"},{"location":"api/#laser.generic.model.Model.run--attributes-set","title":"Attributes Set","text":"<p>tstart : datetime     Start time of execution. tfinish : datetime     End time of execution. metrics : list     List of timing metrics (per tick, per phase).</p>"},{"location":"api/#laser.generic.model.Model.visualize","title":"<code>visualize(pdf=True)</code>","text":"<p>Generate visualizations for all components.</p>"},{"location":"api/#laser.generic.model.Model.visualize--parameters","title":"Parameters","text":"<p>pdf : bool, optional     If True (default), save plots to a PDF file named     \" .pdf\".     If False, display plots interactively with <code>plt.show()</code>."},{"location":"api/#laser.generic.model.Model.visualize--side-effects","title":"Side Effects","text":"<ul> <li>Saves a PDF file when <code>pdf=True</code>.</li> <li>Calls <code>plt.show()</code> when <code>pdf=False</code>.</li> </ul> <p>This module provides utility functions for the laser-measles project.</p>"},{"location":"api/#laser.generic.utils.calc_capacity","title":"<code>calc_capacity(population, nticks, cbr, verbose=False)</code>","text":"<p>Estimate the maximum population size after a given number of ticks, assuming constant exponential growth driven by a crude birth rate (CBR) and no net mortality.</p> <p>This function is typically used to preallocate memory for agent arrays and patch-level data in simulations with population turnover. It assumes births and deaths are either absent or balanced, and that population grows exponentially based on the provided CBR.</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>uint32</code> <p>Initial population size at tick 0.</p> required <code>nticks</code> <code>uint32</code> <p>Number of ticks (simulation time steps) to simulate.</p> required <code>cbr</code> <code>float32</code> <p>Crude birth rate (per 1000 people per year).</p> required <code>verbose</code> <code>bool</code> <p>If True, prints estimated population growth using daily and annual methods.</p> <code>False</code> <p>Returns:</p> Type Description <code>uint32</code> <p>np.uint32: Estimated upper bound on population size at tick = nticks.</p> Notes <ul> <li>The primary growth formula used is daily compounding:     population * (1 + daily_rate) ** nticks   where daily_rate is derived from the annual CBR.</li> <li>An alternate estimate using annual compounding is also printed if <code>verbose=True</code>.</li> <li>This is a conservative estimator used to size internal data structures, not a predictor   of actual population dynamics (which may be capped or stochastic).</li> </ul>"},{"location":"api/#laser.generic.utils.calc_distances","title":"<code>calc_distances(latitudes, longitudes, verbose=False)</code>","text":"<p>Compute the full pairwise Haversine distance matrix between geographic locations.</p> <p>This function calculates the great-circle distances between all pairs of points defined by the input latitude and longitude arrays. Distances are computed using the Haversine formula (via the <code>distance()</code> function from laser_core.migration), and the result is returned as a square, symmetric matrix of distances in kilometers.</p> <p>Parameters:</p> Name Type Description Default <code>latitudes</code> <code>ndarray</code> <p>A 1D array of latitudes in decimal degrees. Must match the shape of <code>longitudes</code>.</p> required <code>longitudes</code> <code>ndarray</code> <p>A 1D array of longitudes in decimal degrees. Must match <code>latitudes</code>.</p> required <code>verbose</code> <code>bool</code> <p>If True, prints the top-left 4x4 corner of the distance matrix for inspection.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A square matrix (n x n) where the element at [i, j] is the distance in kilometers         between point <code>i</code> and point <code>j</code>.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>latitudes</code> is not 1D or if <code>latitudes</code> and <code>longitudes</code> do not have equal shape.</p> Notes <ul> <li>Output matrix is symmetric with zeros on the diagonal.</li> <li>Internally uses the Haversine formula via <code>distance(...)</code>.</li> <li>Computation scales as O(n\u00b2); not recommended for very large n unless optimized.</li> <li>Input coordinates should be in decimal degrees and within valid bounds:     lat \u2208 [-90, 90], lon \u2208 [-180, 180]</li> </ul>"},{"location":"api/#laser.generic.utils.get_default_parameters","title":"<code>get_default_parameters()</code>","text":"<p>Returns a default PropertySet with common parameters used across laser-generic models.</p> <p>Each parameter in the returned PropertySet is described below, along with its default value and rationale:</p> <pre><code>nticks (int, default=730): Number of simulation ticks (days). Default is 2 years (365*2), which is a typical duration for seasonal epidemic simulations.\nbeta (float, default=0.15): Transmission rate per contact. Chosen as a moderate value for SIR-type models to reflect realistic disease spread.\nbiweekly_beta_scalar (list of float, default=[1.0]*biweekly_steps): Scalar for beta for each biweekly period. Default is 1.0 for all periods, meaning no seasonal variation unless specified.\ncbr (float, default=0.03): Constant birth rate. Set to 0.03 to represent a typical annual birth rate in population models.\nexp_shape (float, default=2.0): Shape parameter for the exposed period distribution. Default chosen for moderate dispersion.\nexp_scale (float, default=2.0): Scale parameter for the exposed period distribution. Default chosen for moderate mean duration.\ninf_mean (float, default=4.0): Mean infectious period (days). Set to 4.0 to reflect typical infectious durations for diseases like measles.\ninf_sigma (float, default=1.0): Standard deviation of infectious period. Default is 1.0 for moderate variability.\nseasonality_factor (float, default=0.2): Amplitude of seasonal forcing. Chosen to allow moderate seasonal variation in transmission.\nseasonality_phase (float, default=0.0): Phase offset for seasonality. Default is 0.0, meaning no phase shift.\nimportation_count (int, default=1): Number of cases imported per importation event. Default is 1 for sporadic importation.\nimportation_period (int, default=30): Days between importation events. Default is 30 to represent monthly importation.\nimportation_start (int, default=0): Start day for importation events. Default is 0 (simulation start).\nimportation_end (int, default=730): End day for importation events. Default is 2 years (365*2).\nseed (int, default=123): Random seed for reproducibility. Default is 123.\nverbose (bool, default=False): If True, enables verbose output. Default is False for minimal output.\n</code></pre> <p>These values are chosen to be broadly reasonable for seasonal SIR-type models with importation.</p> <p>We need a function like this because even-though laser-core requires no particular param name, laser-generic code does presume certain parameters and there's no elegant way to just discover what those are. So we put them here.</p>"},{"location":"api/#laser.generic.utils.seed_infections_in_patch","title":"<code>seed_infections_in_patch(model, ipatch, ninfections=1)</code>","text":"<p>Seed initial infections in a specific patch of the population at the start of the simulation. This function randomly selects individuals from the specified patch and sets their infection timer to the mean infection duration, effectively marking them as infected. The process continues until the desired number of initial infections is reached.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model containing the population and parameters.</p> required <code>ipatch</code> <code>int</code> <p>The identifier of the patch where infections should be seeded.</p> required <code>ninfections</code> <code>int</code> <p>The number of initial infections to seed. Defaults to 100.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/#laser.generic.utils.seed_infections_randomly","title":"<code>seed_infections_randomly(model, ninfections=100)</code>","text":"<p>Randomly seed initial infections across the entire population.</p> <p>This function selects up to <code>ninfections</code> susceptible individuals at random from the full population. It marks them as infected by: - Setting their infection timer (<code>itimer</code>) to the model's mean infectious duration (<code>inf_mean</code>), - Setting their susceptibility to zero.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model, which must contain a <code>population</code> with    <code>susceptibility</code>, <code>itimer</code>, and <code>nodeid</code> arrays, and a <code>params</code> object with <code>inf_mean</code>.</p> required <code>ninfections</code> <code>int</code> <p>The number of individuals to infect. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The node IDs of the newly infected individuals.</p>"},{"location":"api/#laser.generic.utils.seed_infections_randomly_SI","title":"<code>seed_infections_randomly_SI(model, ninfections=100)</code>","text":"<p>Randomly seed initial infections for SI-style models without using timers.</p> <p>This function randomly selects <code>ninfections</code> individuals from the population who are currently susceptible and marks them as infected by setting their <code>susceptibility</code> to zero. It does not assign any infection timers, making it suitable for simple SI or SIR models where timers are not required.</p> <p>Unlike other seeding methods, this function explicitly ensures that only susceptible individuals are infected, even if the total population includes recovered or previously infected agents.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model, which must contain a <code>population</code> with    <code>count</code> and <code>susceptibility</code> attributes, and a PRNG in <code>model.prng</code>.</p> required <code>ninfections</code> <code>int</code> <p>Number of initial infections to seed. Defaults to 100.</p> <code>100</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/#laser.generic.utils.set_initial_susceptibility_in_patch","title":"<code>set_initial_susceptibility_in_patch(model, ipatch, susc_frac=1.0)</code>","text":"<p>Randomly assign susceptibility levels to individuals in a specific patch at the start of the simulation.</p> <p>This function sets a random fraction of individuals in the specified patch to be fully immune (susceptibility = 0), based on the given <code>susc_frac</code> value. The remaining individuals retain their default susceptibility.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model, which must contain a <code>population</code> object with    <code>susceptibility</code>, <code>nodeid</code>, and <code>count</code> attributes.</p> required <code>ipatch</code> <code>int</code> <p>The index of the patch in which to set susceptibility.</p> required <code>susc_frac</code> <code>float</code> <p>The fraction (0.0 to 1.0) of individuals in the patch                          to remain susceptible. Defaults to 1.0 (i.e., all remain susceptible).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/#laser.generic.utils.set_initial_susceptibility_randomly","title":"<code>set_initial_susceptibility_randomly(model, susc_frac=1.0)</code>","text":"<p>Randomly assign susceptibility levels to individuals in the population at the start of the simulation.</p> <p>This function sets a random fraction of the population to be fully immune (susceptibility = 0), based on the given <code>susc_frac</code> value. The rest retain their default susceptibility (typically 1.0).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Any</code> <p>The simulation model containing the population and parameters. The model must have    a <code>population</code> object with a <code>susceptibility</code> attribute and a <code>count</code> attribute.</p> required <code>susc_frac</code> <code>float</code> <p>The fraction (0.0 to 1.0) of the population to remain susceptible.                          Defaults to 1.0 (i.e., no initial immunity).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"api/#models","title":"Models","text":""},{"location":"api/#si","title":"SI","text":"<p>Components for an SI model.</p> <p>Agents transition from Susceptible to Infectious upon infection. Agents remain in the Infectious state indefinitely (no recovery).</p>"},{"location":"api/#laser.generic.models.SI.Infectious","title":"<code>Infectious(model)</code>","text":"<p>Infectious component for an SI model - no recovery.</p> <p>Agents remain in the Infectious state indefinitely (no recovery).</p>"},{"location":"api/#laser.generic.models.SI.Infectious.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.SI.Susceptible","title":"<code>Susceptible(model)</code>","text":"<p>Simple Susceptible component suitable for all models (SI/SIS/SIR/SIRS/SEIR/SEIRS).</p>"},{"location":"api/#laser.generic.models.SI.Transmission","title":"<code>Transmission(model)</code>","text":"<p>Transmission component for a model S -&gt; I and no recovery.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p>"},{"location":"api/#laser.generic.models.SI.VitalDynamics","title":"<code>VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SI/SIS model with just S and I states - includes births and deaths.</p>"},{"location":"api/#sis","title":"SIS","text":"<p>Export required components for an SIS model.</p> <p>Agents transition from Susceptible to Infectious upon infection and are infectious for a duration. Agents transition from Infectious back to Susceptible upon recovery.</p>"},{"location":"api/#laser.generic.models.SIS.Infectious","title":"<code>Infectious(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious component for an SIS model - includes infectious duration.</p> <p>Agents transition from Infectious back to Susceptible after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.SIS.Infectious.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.SIS.Susceptible","title":"<code>Susceptible(model)</code>","text":"<p>Simple Susceptible component suitable for all models (SI/SIS/SIR/SIRS/SEIR/SEIRS).</p>"},{"location":"api/#laser.generic.models.SIS.Transmission","title":"<code>Transmission(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission component for an SIS/SIR/SIRS model with S -&gt; I transition and infectious duration.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"api/#laser.generic.models.SIS.VitalDynamics","title":"<code>VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SI/SIS model with just S and I states - includes births and deaths.</p>"},{"location":"api/#sir","title":"SIR","text":"<p>Export required components for an SIR model.</p> <p>Agents transition from Susceptible to Infectious upon infection and are infectious for a duration. Agents transition from Infectious to Recovered upon recovery. Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"api/#laser.generic.models.SIR.Infectious","title":"<code>Infectious(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious component for an SIR/SEIR model - includes infectious duration, no waning immunity in recovered state.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.SIR.Infectious.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.SIR.Recovered","title":"<code>Recovered(model)</code>","text":"<p>Simple Recovered component for an SIR/SEIR model - no waning immunity.</p> <p>Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"api/#laser.generic.models.SIR.Susceptible","title":"<code>Susceptible(model)</code>","text":"<p>Simple Susceptible component suitable for all models (SI/SIS/SIR/SIRS/SEIR/SEIRS).</p>"},{"location":"api/#laser.generic.models.SIR.Transmission","title":"<code>Transmission(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission component for an SIS/SIR/SIRS model with S -&gt; I transition and infectious duration.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"api/#laser.generic.models.SIR.VitalDynamics","title":"<code>VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SIR/SIRS model with S, I, and R states - includes births and deaths.</p>"},{"location":"api/#sirs","title":"SIRS","text":"<p>Export required components for an SIRS model.</p> <p>Agents transition from Susceptible to Infectious upon infection. Agents transition from Infectious to Recovered upon recovery after the infectious duration. Agents transition from Recovered back to Susceptible upon waning immunity after the waning duration.</p>"},{"location":"api/#laser.generic.models.SIRS.Infectious","title":"<code>Infectious(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1)</code>","text":"<p>Infectious component for an SIRS/SEIRS model - includes infectious duration and waning immunity.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Set the waning immunity timer (rtimer) upon recovery. Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.SIRS.Infectious.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.SIRS.Recovered","title":"<code>Recovered(model, wandurdist, wandurmin=1)</code>","text":"<p>Recovered component for an SIRS/SEIRS model - includes waning immunity.</p> <p>Agents transition from Recovered back to Susceptible after the waning immunity period (rtimer). Tracks number of agents losing immunity each tick in <code>model.nodes.waned</code>.</p>"},{"location":"api/#laser.generic.models.SIRS.Susceptible","title":"<code>Susceptible(model)</code>","text":"<p>Simple Susceptible component suitable for all models (SI/SIS/SIR/SIRS/SEIR/SEIRS).</p>"},{"location":"api/#laser.generic.models.SIRS.Transmission","title":"<code>Transmission(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission component for an SIS/SIR/SIRS model with S -&gt; I transition and infectious duration.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"api/#laser.generic.models.SIRS.VitalDynamics","title":"<code>VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SIR/SIRS model with S, I, and R states - includes births and deaths.</p>"},{"location":"api/#seir","title":"SEIR","text":"<p>Export required components for an SEIR model.</p> <p>Agents transition from Susceptible to Exposed upon infection, with an incubation duration. Agents transition from Exposed to Infectious after the incubation period and are infectious for a duration. Agents transition from Infectious to Recovered after the infectious period. Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"api/#laser.generic.models.SEIR.Exposed","title":"<code>Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1)</code>","text":"<p>Simple Exposed component for an SEIR/SEIRS model - includes incubation period.</p> <p>Agents transition from Exposed to Infectious when their incubation timer (etimer) expires. Tracks number of agents becoming infectious each tick in <code>model.nodes.symptomatic</code>.</p>"},{"location":"api/#laser.generic.models.SEIR.Infectious","title":"<code>Infectious(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious component for an SIR/SEIR model - includes infectious duration, no waning immunity in recovered state.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.SEIR.Infectious.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.SEIR.Recovered","title":"<code>Recovered(model)</code>","text":"<p>Simple Recovered component for an SIR/SEIR model - no waning immunity.</p> <p>Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"api/#laser.generic.models.SEIR.Susceptible","title":"<code>Susceptible(model)</code>","text":"<p>Simple Susceptible component suitable for all models (SI/SIS/SIR/SIRS/SEIR/SEIRS).</p>"},{"location":"api/#laser.generic.models.SEIR.Transmission","title":"<code>Transmission(model, expdurdist, expdurmin=1)</code>","text":"<p>Transmission component for an SIER/SIERS model with S -&gt; E transition and incubation duration.</p> <p>Agents transition from Susceptible to Exposed based on force of infection. Sets newly exposed agents' infection timers (etimer) based on <code>expdurdist</code> and <code>expdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p> <p>Initializes the TransmissionSE component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <p>Minimum incubation duration.</p> <code>1</code>"},{"location":"api/#laser.generic.models.SEIR.VitalDynamics","title":"<code>VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SEIR/SEIRS model with S, E, I, and R states - includes births and deaths.</p>"},{"location":"api/#seirs","title":"SEIRS","text":"<p>Export required components for an SEIRS model.</p> <p>Agents transition from Susceptible to Exposed upon infection, with an incubation duration. Agents transition from Exposed to Infectious after the incubation period and are infectious for a duration. Agents transition from Infectious to Recovered after the infectious period. Agents transition from Recovered back to Susceptible upon waning immunity after the waning duration</p>"},{"location":"api/#laser.generic.models.SEIRS.Exposed","title":"<code>Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1)</code>","text":"<p>Simple Exposed component for an SEIR/SEIRS model - includes incubation period.</p> <p>Agents transition from Exposed to Infectious when their incubation timer (etimer) expires. Tracks number of agents becoming infectious each tick in <code>model.nodes.symptomatic</code>.</p>"},{"location":"api/#laser.generic.models.SEIRS.Infectious","title":"<code>Infectious(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1)</code>","text":"<p>Infectious component for an SIRS/SEIRS model - includes infectious duration and waning immunity.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Set the waning immunity timer (rtimer) upon recovery. Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.SEIRS.Infectious.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.SEIRS.Recovered","title":"<code>Recovered(model, wandurdist, wandurmin=1)</code>","text":"<p>Recovered component for an SIRS/SEIRS model - includes waning immunity.</p> <p>Agents transition from Recovered back to Susceptible after the waning immunity period (rtimer). Tracks number of agents losing immunity each tick in <code>model.nodes.waned</code>.</p>"},{"location":"api/#laser.generic.models.SEIRS.Susceptible","title":"<code>Susceptible(model)</code>","text":"<p>Simple Susceptible component suitable for all models (SI/SIS/SIR/SIRS/SEIR/SEIRS).</p>"},{"location":"api/#laser.generic.models.SEIRS.Transmission","title":"<code>Transmission(model, expdurdist, expdurmin=1)</code>","text":"<p>Transmission component for an SIER/SIERS model with S -&gt; E transition and incubation duration.</p> <p>Agents transition from Susceptible to Exposed based on force of infection. Sets newly exposed agents' infection timers (etimer) based on <code>expdurdist</code> and <code>expdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p> <p>Initializes the TransmissionSE component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <p>Minimum incubation duration.</p> <code>1</code>"},{"location":"api/#laser.generic.models.SEIRS.VitalDynamics","title":"<code>VitalDynamics(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SEIR/SEIRS model with S, E, I, and R states - includes births and deaths.</p>"},{"location":"api/#shared-model-utilities","title":"Shared model utilities","text":""},{"location":"api/#components","title":"Components","text":""},{"location":"api/#laser.generic.models.components.Exposed","title":"<code>Exposed(model, expdurdist, infdurdist, expdurmin=1, infdurmin=1)</code>","text":"<p>Simple Exposed component for an SEIR/SEIRS model - includes incubation period.</p> <p>Agents transition from Exposed to Infectious when their incubation timer (etimer) expires. Tracks number of agents becoming infectious each tick in <code>model.nodes.symptomatic</code>.</p>"},{"location":"api/#laser.generic.models.components.InfectiousIR","title":"<code>InfectiousIR(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious component for an SIR/SEIR model - includes infectious duration, no waning immunity in recovered state.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.components.InfectiousIR.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.components.InfectiousIRS","title":"<code>InfectiousIRS(model, infdurdist, wandurdist, infdurmin=1, wandurmin=1)</code>","text":"<p>Infectious component for an SIRS/SEIRS model - includes infectious duration and waning immunity.</p> <p>Agents transition from Infectious to Recovered after the infectious period (itimer). Set the waning immunity timer (rtimer) upon recovery. Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.components.InfectiousIRS.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.components.InfectiousIS","title":"<code>InfectiousIS(model, infdurdist, infdurmin=1)</code>","text":"<p>Infectious component for an SIS model - includes infectious duration.</p> <p>Agents transition from Infectious back to Susceptible after the infectious period (itimer). Tracks number of agents recovering each tick in <code>model.nodes.recovered</code>.</p>"},{"location":"api/#laser.generic.models.components.InfectiousIS.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.components.InfectiousSI","title":"<code>InfectiousSI(model)</code>","text":"<p>Infectious component for an SI model - no recovery.</p> <p>Agents remain in the Infectious state indefinitely (no recovery).</p>"},{"location":"api/#laser.generic.models.components.InfectiousSI.step","title":"<code>step(tick)</code>","text":"<p>Step function for the Infected component.</p> <p>Parameters:</p> Name Type Description Default <code>tick</code> <code>int</code> <p>The current tick of the simulation.</p> required"},{"location":"api/#laser.generic.models.components.Recovered","title":"<code>Recovered(model)</code>","text":"<p>Simple Recovered component for an SIR/SEIR model - no waning immunity.</p> <p>Agents remain in the Recovered state indefinitely (no waning immunity).</p>"},{"location":"api/#laser.generic.models.components.RecoveredRS","title":"<code>RecoveredRS(model, wandurdist, wandurmin=1)</code>","text":"<p>Recovered component for an SIRS/SEIRS model - includes waning immunity.</p> <p>Agents transition from Recovered back to Susceptible after the waning immunity period (rtimer). Tracks number of agents losing immunity each tick in <code>model.nodes.waned</code>.</p>"},{"location":"api/#laser.generic.models.components.Susceptible","title":"<code>Susceptible(model)</code>","text":"<p>Simple Susceptible component suitable for all models (SI/SIS/SIR/SIRS/SEIR/SEIRS).</p>"},{"location":"api/#laser.generic.models.components.TransmissionSE","title":"<code>TransmissionSE(model, expdurdist, expdurmin=1)</code>","text":"<p>Transmission component for an SIER/SIERS model with S -&gt; E transition and incubation duration.</p> <p>Agents transition from Susceptible to Exposed based on force of infection. Sets newly exposed agents' infection timers (etimer) based on <code>expdurdist</code> and <code>expdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p> <p>Initializes the TransmissionSE component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>expdurdist</code> <p>A function that returns the incubation duration for a given tick and node.</p> required <code>expdurmin</code> <p>Minimum incubation duration.</p> <code>1</code>"},{"location":"api/#laser.generic.models.components.TransmissionSI","title":"<code>TransmissionSI(model, infdurdist, infdurmin=1)</code>","text":"<p>Transmission component for an SIS/SIR/SIRS model with S -&gt; I transition and infectious duration.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Sets newly infectious agents' infection timers (itimer) based on <code>infdurdist</code> and <code>infdurmin</code>. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p> <p>Initializes the TransmissionSI component.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>infdurdist</code> <p>A function that returns the infectious duration for a given tick and node.</p> required <code>infdurmin</code> <p>Minimum infectious duration.</p> <code>1</code>"},{"location":"api/#laser.generic.models.components.TransmissionSIX","title":"<code>TransmissionSIX(model)</code>","text":"<p>Transmission component for a model S -&gt; I and no recovery.</p> <p>Agents transition from Susceptible to Infectious based on force of infection. Tracks number of new infections each tick in <code>model.nodes.incidence</code>.</p>"},{"location":"api/#laser.generic.models.components.VitalDynamicsBase","title":"<code>VitalDynamicsBase(model, birthrates, pyramid, survival, states=None)</code>","text":"<p>Base class for Vital Dynamics components (births and deaths).</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <p>The epidemiological model instance.</p> required <code>birthrates</code> <p>Array of birth rates, CBR, in effect for each tick and node.</p> required <code>pyramid</code> <code>AliasedDistribution</code> <p>Age pyramid distribution for sampling date of birth.</p> required <code>survival</code> <code>KaplanMeierEstimator</code> <p>Survival curve for sampling date of death.</p> required <code>states</code> <p>List of states to consider for population counts (default: [\"S\", \"E\", \"I\", \"R\"]).</p> <code>None</code> <p>Initializes the VitalDynamicsBase component.</p> <p>Args:</p> <pre><code>model: The epidemiological model instance.\nbirthrates: Array of birth rates, CBR, in effect for each tick and node.\npyramid (AliasedDistribution): Age pyramid distribution for sampling date of birth.\nsurvival (KaplanMeierEstimator): Survival curve for sampling date of death.\nstates: List of states to consider for population counts (default: [\"S\", \"E\", \"I\", \"R\"]).\n</code></pre>"},{"location":"api/#laser.generic.models.components.VitalDynamicsSEIR","title":"<code>VitalDynamicsSEIR(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SEIR/SEIRS model with S, E, I, and R states - includes births and deaths.</p>"},{"location":"api/#laser.generic.models.components.VitalDynamicsSI","title":"<code>VitalDynamicsSI(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SI/SIS model with just S and I states - includes births and deaths.</p>"},{"location":"api/#laser.generic.models.components.VitalDynamicsSIR","title":"<code>VitalDynamicsSIR(model, birthrates, pyramid, survival)</code>","text":"<p>               Bases: <code>VitalDynamicsBase</code></p> <p>Vital dynamics component for an SIR/SIRS model with S, I, and R states - includes births and deaths.</p>"},{"location":"api/#shared-enums-constants","title":"Shared Enums &amp; Constants","text":""},{"location":"contribute/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contribute/#bug-reports","title":"Bug reports","text":"<p>When reporting a bug please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contribute/#documentation-improvements","title":"Documentation improvements","text":"<p>laser-generic could always use more documentation, whether as part of the official laser-generic docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contribute/#feature-requests-and-feedback","title":"Feature requests and feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/InstituteforDiseaseModeling/laser-generic/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that code contributions are welcome :)</li> </ul>"},{"location":"contribute/#development","title":"Development","text":"<p>To set up <code>laser-generic</code> for local development:</p> <ol> <li>Fork <code>laser-generic</code> (look for the \"Fork\" button).</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone git@github.com:YOURGITHUBNAME/laser-generic.git\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes run all the checks and docs builder with one command:</li> </ol> <pre><code>tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contribute/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>If you need some code review or feedback while you're developing the code just make the pull request.</p> <p>For merging, you should:</p> <ol> <li>Include passing tests (run <code>tox</code>).</li> <li>Update documentation when there's new API, functionality etc.</li> <li>Add a note to <code>CHANGELOG.rst</code> about the changes.</li> <li>Add yourself to <code>AUTHORS.rst</code>.</li> </ol>"},{"location":"contribute/#tips","title":"Tips","text":"<p>To run a subset of tests:</p> <pre><code>tox -e envname -- pytest -k test_myfeature\n</code></pre> <p>To run all the test environments in parallel:</p> <pre><code>tox -p auto\n</code></pre>"},{"location":"get-started/","title":"Get started","text":"<p><code>laser-generic</code> is an implementation of the LASER agent-based modeling framework for modeling generic diseases, such as measles.</p>"},{"location":"get-started/#installation","title":"Installation","text":"<p>See the Overview for installation instructions.</p>"},{"location":"get-started/#usage","title":"Usage","text":"<p>To use the project:</p> <pre><code>import laser.generic\nlaser.generic.compute(...)\n</code></pre>"},{"location":"get-started/#build-a-model","title":"Build a model","text":"<p>This example will demonstrate how to build and run a simple, 25-patch SEIR-like model with vital dynamics (births).</p> <ol> <li> <p>Define the scenario.</p> <p>You must define a <code>scenario</code> DataFrame with one row per patch, each including a <code>population</code>, and optionally <code>latitude</code> and <code>longitude</code> for plotting or spatial coupling.</p> <p>This example defines a 5\u00d75 grid of patches with larger center and smaller outer nodes.</p> <pre><code>import pandas as pd\n\ndef make_city_scenario(n=5, spacing=1.0):\n    coords = [(i*spacing, j*spacing) for i in range(-(n//2), n//2+1)\n                                    for j in range(-(n//2), n//2+1)]\n    pops = []\n    for (x, y) in coords:\n        dist = abs(x) + abs(y)\n        if dist == 0:\n            pops.append(5000)    # city center\n        elif dist == 1:\n            pops.append(2000)    # suburbs\n        else:\n            pops.append(500)     # rural\n    return pd.DataFrame({\n        \"population\": pops,\n        \"latitude\": [y for (x, y) in coords],\n        \"longitude\": [x for (x, y) in coords],\n    })\n\nscenario = make_city_scenario()\n</code></pre> </li> <li> <p>Define the simulation parameters.</p> <p>LASER uses a <code>PropertySet</code> (like a dict) to define model-wide parameters. Start with defaults and override as needed.</p> <pre><code>from laser.generic.utils import get_default_parameters\n\nparams = get_default_parameters() | {\n    \"seed\": 42,\n    \"beta\": 0.3,         # transmission rate\n    \"inf_mean\": 5.0,     # mean infectious period\n    \"inf_sigma\": 1.0,    # stddev infectious period\n}\n\n# Optional importation settings\n# params |= {\n#     \"importation_period\": 10,\n#     \"importation_count\": 5,\n#     \"importation_start\": 0,\n#     \"importation_end\": 50,\n# }\n</code></pre> </li> <li> <p>Create the model.</p> <p>This initializes patch-level arrays and allocates the population frame.</p> <pre><code>from laser.generic.model import Model\n\nmodel = Model(scenario, params)\n</code></pre> </li> <li> <p>Attach components.</p> <p>Components are step functions called every tick. Attach those you want in order.</p> <pre><code>from laser.generic.transmission import Transmission\nfrom laser.generic.susceptibility import Susceptibility\nfrom laser.generic.exposure import Exposure\nfrom laser.generic.infection import Infection\nfrom laser.generic.importation import Infect_Random_Agents\nfrom laser.generic.births import Births\n\nmodel.components = [\n    Births,                # assigns dob\n    Susceptibility,        # creates .susceptibility property\n    Transmission,          # simulates infection pressure\n    Exposure,              # tracks latent infections\n    Infection,             # resolves infectious \u2192 recovered\n    Infect_Random_Agents,  # seeds infections over time\n]\n\n# Optional: ensure safe integer arithmetic\nimport numpy as np\nmodel.patches.populations = model.patches.populations.astype(np.int64)\n</code></pre> </li> <li> <p>Run the simulation.</p> <p>Once components are attached, run the simulation.</p> <pre><code>model.run()\n</code></pre> </li> <li> <p>Export patch-level time series.</p> <p>Use this helper to export all <code>(tick, patch, variable)</code> values into a long-format CSV or HDF file.</p> <pre><code>def export_patch_timeseries(model, filename=\"report.csv\", format=\"csv\"):\n    import pandas as pd\n    import numpy as np\n\n    npatches = len(model.patches)\n    vars = {}\n    for name in dir(model.patches):\n        arr = getattr(model.patches, name, None)\n        if isinstance(arr, np.ndarray) and arr.ndim == 2 and arr.shape[1] == npatches:\n            vars[name] = arr\n\n    records = []\n    maxtime = max(arr.shape[0] for arr in vars.values())\n    for t in range(maxtime):\n        for p in range(npatches):\n            row = {\"tick\": t, \"patch\": p}\n            for v, arr in vars.items():\n                if t &lt; arr.shape[0]:\n                    row[v] = arr[t, p]\n            records.append(row)\n\n    df = pd.DataFrame(records)\n\n    if format == \"csv\":\n        df.to_csv(filename, index=False)\n    elif format == \"h5\":\n        df.to_hdf(filename, key=\"laser\", mode=\"w\")\n    else:\n        raise ValueError(f\"Unsupported format: {format}\")\n\n    print(f\"Exported patch-level time series to {filename}\")\n    return df\n\n# Export to disk\ndf = export_patch_timeseries(model, \"patch_report.csv\", format=\"csv\")\n</code></pre> </li> <li> <p>Inspect or visualize output.</p> <p>LASER provides built-in visualizations: scenario maps, birth distributions, and timing pie charts.</p> <pre><code>model.visualize(pdf=False)\n\nprint(\"Simulation complete.\")\nprint(\"Patch populations over time (first 10 ticks):\")\nprint(model.patches.populations[:10, :])\nprint(\"Cases test over time (first 100 ticks):\")\nprint(model.patches.cases_test[:100, :])\n</code></pre> </li> </ol>"},{"location":"get-started/#tutorials","title":"Tutorials","text":"<p>Begin with the first tutorial SI model with no demographics for a very simple implementation of the LASER-generic model.</p>"},{"location":"glossary/","title":"Glossary","text":"<p>Including a glossary of terms can be helpful to users. Unlike Sphinx, MkDocs does not enable linking to specific terms.</p> Term Definition of term."},{"location":"whatsnew/","title":"Changelog","text":""},{"location":"whatsnew/#000-2024-11-19","title":"0.0.0 (2024-11-19)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"notebooks/","title":"Tutorials","text":"<p>The following Jupyter notebook tutorials walk through different workflows to configure the LASER-generic model, starting with a simple SI model with no demographics and adding more complexity with each tutorial to illustrate various features of the model.</p>"},{"location":"notebooks/01_SI_nobirths_logistic_growth/","title":"SI Model with no demographics","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom matplotlib import pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\nimport laser.generic.models.SI as SI\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from matplotlib import pyplot as plt from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic import laser.generic.models.SI as SI from laser.generic.models.model import Model from laser.generic.newutils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>np.__version__='2.3.4'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>pop = 1e6\ninit_inf = 1\n# Seattle: 47\u00b036'35\" -122\u00b019'59\"\nlatitude = 47+(36+(35/60))/60\nlongitude = -(122+(19+(59/60))/60)\nscenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\nparameters = PropertySet({\"seed\": 6, \"nticks\": 730, \"verbose\": True, \"beta\": 0.05})\n\n# Run until we get an outbreak\noutbreak = False\nwhile not outbreak:\n\n    parameters.seed += 1\n    model = Model(scenario, parameters)\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.Transmission(model),\n    ]\n\n    model.run()\n\n    outbreak = np.any(model.nodes.I[180] != 0)\n</pre> pop = 1e6 init_inf = 1 # Seattle: 47\u00b036'35\" -122\u00b019'59\" latitude = 47+(36+(35/60))/60 longitude = -(122+(19+(59/60))/60) scenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf parameters = PropertySet({\"seed\": 6, \"nticks\": 730, \"verbose\": True, \"beta\": 0.05})  # Run until we get an outbreak outbreak = False while not outbreak:      parameters.seed += 1     model = Model(scenario, parameters)     model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.Transmission(model),     ]      model.run()      outbreak = np.any(model.nodes.I[180] != 0)  <pre>/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/shapely/constructive.py:375: RuntimeWarning: invalid value encountered in centroid\n  return lib.centroid(geometry, **kwargs)\n</pre> <pre>\r1000000 agents in f1 nodes:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\r1000000 agents in f1 nodes:   0%|          | 1/730 [00:00&lt;05:11,  2.34it/s]</pre> <pre>\r1000000 agents in f1 nodes:   4%|\u258e         | 27/730 [00:00&lt;00:10, 66.86it/s]</pre> <pre>\r1000000 agents in f1 nodes:   7%|\u258b         | 54/730 [00:00&lt;00:05, 119.98it/s]</pre> <pre>\r1000000 agents in f1 nodes:  11%|\u2588         | 82/730 [00:00&lt;00:03, 162.29it/s]</pre> <pre>\r1000000 agents in f1 nodes:  15%|\u2588\u258d        | 109/730 [00:00&lt;00:03, 191.34it/s]</pre> <pre>\r1000000 agents in f1 nodes:  19%|\u2588\u2589        | 137/730 [00:00&lt;00:02, 214.62it/s]</pre> <pre>\r1000000 agents in f1 nodes:  22%|\u2588\u2588\u258f       | 164/730 [00:01&lt;00:02, 230.38it/s]</pre> <pre>\r1000000 agents in f1 nodes:  26%|\u2588\u2588\u258b       | 192/730 [00:01&lt;00:02, 242.64it/s]</pre> <pre>\r1000000 agents in f1 nodes:  30%|\u2588\u2588\u2588       | 220/730 [00:01&lt;00:02, 251.11it/s]</pre> <pre>\r1000000 agents in f1 nodes:  34%|\u2588\u2588\u2588\u258d      | 247/730 [00:01&lt;00:01, 255.50it/s]</pre> <pre>\r1000000 agents in f1 nodes:  38%|\u2588\u2588\u2588\u258a      | 276/730 [00:01&lt;00:01, 263.42it/s]</pre> <pre>\r1000000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 310/730 [00:01&lt;00:01, 285.78it/s]</pre> <pre>\r1000000 agents in f1 nodes:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 539/730 [00:01&lt;00:00, 877.22it/s]</pre> <pre>\r1000000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:01&lt;00:00, 429.50it/s]</pre> <pre>\n</pre> In\u00a0[3]: Copied! <pre>plt.plot(model.nodes.I, lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S, \"--\", lw=3)\nplt.plot(init_inf + np.insert(np.cumsum(model.nodes.incidence[:-1]), 0, 0), \":\", lw=2, color=\"black\")\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\n</pre> plt.plot(model.nodes.I, lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S, \"--\", lw=3) plt.plot(init_inf + np.insert(np.cumsum(model.nodes.incidence[:-1]), 0, 0), \":\", lw=2, color=\"black\") plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])  Out[3]: <pre>&lt;matplotlib.legend.Legend at 0x7f6d17fbc890&gt;</pre> <p>Introducing stochasticity into a model can have more effects on an individual model realization than just inducing noise around a mean trajectory - this simple model is a great example.  In the early stages of the outbreak, the infection count is low, and the timing of those first few infections dictates when the logistic growth really takes off.  This appears as a random time-shift in the entire outbreak trajectory.</p> <p>To illustrate this phenomenon, the below plot shows the model output, the expected logistic growth curve, and the expected logistic growth curve fit to the model with one free parameter -  an offset $t_0$.  The resulting plot should show good concordance between the model output and the expected logistic equation with the known model inputs $\\beta$ and population.</p> <p>The goodness of this fit will be turned into a strict pass/fail test down the line.</p> In\u00a0[4]: Copied! <pre>def SI_logistic(t, beta, size, t0):\n    return size / (1 + (size - 1) * np.exp(-beta * (t - t0)))\n\n\nplt.plot(model.nodes.I, lw=4)\n\nt = np.arange(model.params.nticks)\n\n\ndef objective(t0):\n    return np.sum((1 - SI_logistic(t, model.params.beta, pop, t0) / np.squeeze(model.nodes.I[1:])) ** 2)\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(t, SI_logistic(t, model.params.beta, pop, 0), \"--\", lw=2)\nplt.plot(t, SI_logistic(t, model.params.beta, pop, t0_opt), \"--\", lw=3, color=\"k\")\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\n</pre> def SI_logistic(t, beta, size, t0):     return size / (1 + (size - 1) * np.exp(-beta * (t - t0)))   plt.plot(model.nodes.I, lw=4)  t = np.arange(model.params.nticks)   def objective(t0):     return np.sum((1 - SI_logistic(t, model.params.beta, pop, t0) / np.squeeze(model.nodes.I[1:])) ** 2)   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(t, SI_logistic(t, model.params.beta, pop, 0), \"--\", lw=2) plt.plot(t, SI_logistic(t, model.params.beta, pop, t0_opt), \"--\", lw=3, color=\"k\") plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7f6d17d24da0&gt;</pre> In\u00a0[5]: Copied! <pre>%%capture\nnticks = 730\nt = np.arange(730)\npop = 1e5\n\nseeds = list(range(10))\nbetas = [0.01 * i for i in range(2, 12)]\noutput = pd.DataFrame(columns=[\"seed\", \"beta\", \"cases\", \"fitted_beta\", \"fitted_size\", \"fitted_t0\"])\n\n# scenario = pd.DataFrame(data=[[\"homenode\", pop, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])\nscenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\n\nfor seed, beta in zip(seeds, betas):\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta})\n    model = Model(scenario, parameters)\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.Transmission(model),\n    ]\n    # seed_infections_randomly_SI(model, ninfections=1)\n    model.run()\n    cases = [model.nodes.I[i][0] for i in range(nticks)]\n    popt, pcov = curve_fit(SI_logistic, t, cases, p0=[0.05, 1.1e5, 1])\n\n    output = pd.concat(\n        [\n            output,\n            pd.DataFrame.from_dict(\n                {\n                    \"seed\": seed,\n                    \"beta\": beta,\n                    \"cases\": [np.array(cases)],\n                    \"fitted_beta\": popt[0],\n                    \"fitted_size\": popt[1],\n                    \"fitted_t0\": popt[2],\n                }\n            ),\n        ],\n        ignore_index=True,\n    )\n</pre> %%capture nticks = 730 t = np.arange(730) pop = 1e5  seeds = list(range(10)) betas = [0.01 * i for i in range(2, 12)] output = pd.DataFrame(columns=[\"seed\", \"beta\", \"cases\", \"fitted_beta\", \"fitted_size\", \"fitted_t0\"])  # scenario = pd.DataFrame(data=[[\"homenode\", pop, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"]) scenario = grid(M=1,N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=latitude, origin_y=longitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf  for seed, beta in zip(seeds, betas):     parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta})     model = Model(scenario, parameters)     model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.Transmission(model),     ]     # seed_infections_randomly_SI(model, ninfections=1)     model.run()     cases = [model.nodes.I[i][0] for i in range(nticks)]     popt, pcov = curve_fit(SI_logistic, t, cases, p0=[0.05, 1.1e5, 1])      output = pd.concat(         [             output,             pd.DataFrame.from_dict(                 {                     \"seed\": seed,                     \"beta\": beta,                     \"cases\": [np.array(cases)],                     \"fitted_beta\": popt[0],                     \"fitted_size\": popt[1],                     \"fitted_t0\": popt[2],                 }             ),         ],         ignore_index=True,     ) In\u00a0[6]: Copied! <pre>plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlabel(\"True beta\")\nplt.ylabel(\"Fitted beta\")\nplt.figure()\nplt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"], \"o\")\nplt.xlabel(\"True beta\")\nplt.ylabel(\"Relative error in fitted beta\")\n</pre> plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlabel(\"True beta\") plt.ylabel(\"Fitted beta\") plt.figure() plt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"], \"o\") plt.xlabel(\"True beta\") plt.ylabel(\"Relative error in fitted beta\") Out[6]: <pre>Text(0, 0.5, 'Relative error in fitted beta')</pre> In\u00a0[7]: Copied! <pre>print(\n    \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05))\n)\n</pre> print(     \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05)) ) <pre>All fitted beta are within 5% of known beta: True\n</pre>"},{"location":"notebooks/01_SI_nobirths_logistic_growth/#si-model-with-no-demographics","title":"SI Model with no demographics\u00b6","text":"<p>We will begin with perhaps the simplest possible model of an infectious disease - the SI model without demography.  This model hsa two classes of individuals, the infective and the susceptible, and 1 parameter, $\\beta$, describing the per-timestep, per-infective person rate at which susceptibles transition to infectives.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} \\\\  \\dot{I} = \\frac{\\beta*S*I}{N} $$</p> <p>Noting that $S = N-I$, we can substitute $S$ in the second equation to get a standard form logistic equation</p> <p>$$ \\dot{I} = \\beta \\frac{(I-N)I}{N} = \\beta I (1 - \\frac{I}{N}) $$</p> <p>With solution $$ \\frac{N}{1+(\\frac{N}{I_0}-1)e^{-\\beta t}} $$</p> <p>To run the model in a discrete, constant time-step solver, the differential equation above is converted into a stochastic finite difference equation</p> <p>$$ \\Delta I = Bin(S_t, 1-exp^{-\\beta \\Delta t \\frac{I}{N}}) \\\\ S_{t+1} = S_t - \\Delta I \\\\ I_{t+1} = I_t + \\Delta I $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"notebooks/01_SI_nobirths_logistic_growth/#constuct-the-model","title":"Constuct the model\u00b6","text":"<p>In the first few cells, we import the <code>laser.generic.SI</code> model.  Then we construct a single-patch LASER model with two components: the Susceptible and Infected states, and the Transmission step in which Infecteds can infect Susceptibles. Finally, we initialize with a single infection and run.</p> <p>Note that LASER-generic has separate importable models for different generic model types (SI, SIS, SIR, SEIR, etc.).  Model code can be imported or copied over from one \"sub-package\" to another as desired, but maintaining this separation enables model-specific performance optimizations and cleaner code than requiring the components to \"know\" the global model configuration and change internal behvaior based on that (for example, whether agents in the <code>Infected</code> state need to cound down a timer or not; whether <code>Transmission</code> should send newly infected agents to the Infectious state as in the SI, SIS, SIR, or to an Exposed state as in an SEIR).</p>"},{"location":"notebooks/01_SI_nobirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.  We also confirm that $I_t = I_0 + \\sum_{t'=0}^t \\Delta I_{t'}$</p>"},{"location":"notebooks/01_SI_nobirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  We select a few values of $\\beta$, run the model, fit the outputs to the logistic equation, and compare the fitted value of $\\beta$ to the known value.  Because we are approximating continuously compounding growth, in the logistic equation, with a discrete time-step approximation, we expect the fitted values of $\\beta$ to be biased slightly downward - that is, the modeled trajectory is slightly slower than the continuous-time counterpart.  This error grows as $\\beta$ gets larger; the test fails if any of the fitted $\\beta$ values are more than 5% away from the known values.</p>"},{"location":"notebooks/01_SI_nobirths_logistic_growth/#constructing-the-model","title":"Constructing the model\u00b6","text":""},{"location":"notebooks/01_SI_nobirths_logistic_growth/#question-is-this-still-the-case-i-think-the-reporting-setup-should-now-always-be-recording-state-variables-like-s-i-etc-at-end-of-timestep-so-that-they-should-always-sum-to-n-there-is-a-question-of-whether-i_t-sum-of-delta-i-from-0-t-1-or-from-0-t","title":"Question - is this still the case?  I think the reporting setup should now always be recording state variables like S, I, etc. at end of timestep so that they should always sum to N.  There is a question of whether I_t = sum of delta I from 0 -&gt; t-1, or from 0-&gt;t.\u00b6","text":"<p>A note that order of the model components matters, because of how recording of relevant statistics into outputs occurs.  If transmission comes before susceptibility, then we have $N = S+I+\\Delta I$, because we record $I$, record $\\Delta I$, do transmission, then record $S$ after the transmission process occurs.  With susceptibility first, we record $S$, then record $I$, then do transmission (and record $\\Delta I$), and so we have $N = S+I$.</p>"},{"location":"notebooks/01_SI_nobirths_logistic_growth/#first-set-of-sanity-checks","title":"First set of sanity checks\u00b6","text":""},{"location":"notebooks/01_SI_nobirths_logistic_growth/#note-this-test-is-not-useful-we-should-look-at-s-i-and-incidence-for-consistency","title":"Note - this test is not useful, we should look at S, I, and incidence for consistency.\u00b6","text":""},{"location":"notebooks/01_SI_nobirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of $\\beta$  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>Because we are approximating continuously compounding growth by discrete-time compounding growth, we should expect the fitted $\\beta$  to consistently be slightly underestimated relative to the true $\\beta$ , with the relative difference growing as $\\beta$  gets larger.</p> <p>In the future, we could probably compute the expected error from this approximation.  But for now, to make this a pass-fail test, we will raise a flag if the fitted $\\beta$ is more than 5% different than the known $\\beta$.</p>"},{"location":"notebooks/02_SI_wbirths_logistic_growth/","title":"SI Model with constant-population demographics","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\n\nimport laser.generic.models.SI as SI\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import ValuesMap\nfrom laser.generic.newutils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic  import laser.generic.models.SI as SI from laser.generic.models.model import Model from laser.generic.newutils import ValuesMap from laser.generic.newutils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.4'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>pop = 1e6\ninit_inf = 1\n# Just for fun, use coordinates of Seattle, WA\nlatitude = 47+(36+(35/60))/60\nlongitude = -(122+(19+(59/60))/60)\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\nparameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.04, \"cbr\": 40.0})\n# Question - if I provide a scalar birth rate, should the demographics steps know to convert that to a ratemap behind the scenes?\nbirthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1).values\nmortality  = ValuesMap.from_scalar(0.0, nsteps=parameters.nticks, nnodes=1).values\n\n# Run until we see an outbreak\noutbreak = False\n\nwhile not outbreak:\n    parameters.seed += 1\n    model = Model(scenario, parameters, birthrates)\n\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.ConstantPopVitalDynamics(model, birthrates, mortality),\n        SI.Transmission(model),\n        ]\n\n    model.run()\n\n    outbreak = np.any(model.nodes.I[200] &gt; 0)\n</pre> pop = 1e6 init_inf = 1 # Just for fun, use coordinates of Seattle, WA latitude = 47+(36+(35/60))/60 longitude = -(122+(19+(59/60))/60) scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf parameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.04, \"cbr\": 40.0}) # Question - if I provide a scalar birth rate, should the demographics steps know to convert that to a ratemap behind the scenes? birthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1).values mortality  = ValuesMap.from_scalar(0.0, nsteps=parameters.nticks, nnodes=1).values  # Run until we see an outbreak outbreak = False  while not outbreak:     parameters.seed += 1     model = Model(scenario, parameters, birthrates)      model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.ConstantPopVitalDynamics(model, birthrates, mortality),         SI.Transmission(model),         ]      model.run()      outbreak = np.any(model.nodes.I[200] &gt; 0) <pre>\r1000000 agents in f1 nodes:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\r1000000 agents in f1 nodes:   0%|          | 1/730 [00:00&lt;06:48,  1.79it/s]</pre> <pre>\r1000000 agents in f1 nodes:   3%|\u258e         | 19/730 [00:00&lt;00:18, 37.84it/s]</pre> <pre>\r1000000 agents in f1 nodes:   5%|\u258c         | 37/730 [00:00&lt;00:09, 69.42it/s]</pre> <pre>\r1000000 agents in f1 nodes:   8%|\u258a         | 55/730 [00:00&lt;00:07, 95.83it/s]</pre> <pre>\r1000000 agents in f1 nodes:  10%|\u2588         | 73/730 [00:00&lt;00:05, 116.91it/s]</pre> <pre>\r1000000 agents in f1 nodes:  12%|\u2588\u258f        | 91/730 [00:01&lt;00:04, 132.03it/s]</pre> <pre>\r1000000 agents in f1 nodes:  15%|\u2588\u258d        | 109/730 [00:01&lt;00:04, 143.69it/s]</pre> <pre>\r1000000 agents in f1 nodes:  17%|\u2588\u258b        | 127/730 [00:01&lt;00:03, 153.18it/s]</pre> <pre>\r1000000 agents in f1 nodes:  20%|\u2588\u2589        | 145/730 [00:01&lt;00:03, 159.93it/s]</pre> <pre>\r1000000 agents in f1 nodes:  22%|\u2588\u2588\u258f       | 163/730 [00:01&lt;00:03, 164.75it/s]</pre> <pre>\r1000000 agents in f1 nodes:  25%|\u2588\u2588\u258d       | 181/730 [00:01&lt;00:03, 168.53it/s]</pre> <pre>\r1000000 agents in f1 nodes:  27%|\u2588\u2588\u258b       | 199/730 [00:01&lt;00:03, 168.60it/s]</pre> <pre>\r1000000 agents in f1 nodes:  30%|\u2588\u2588\u2589       | 217/730 [00:01&lt;00:02, 171.10it/s]</pre> <pre>\r1000000 agents in f1 nodes:  32%|\u2588\u2588\u2588\u258f      | 235/730 [00:01&lt;00:02, 173.01it/s]</pre> <pre>\r1000000 agents in f1 nodes:  35%|\u2588\u2588\u2588\u258d      | 253/730 [00:01&lt;00:02, 174.22it/s]</pre> <pre>\r1000000 agents in f1 nodes:  37%|\u2588\u2588\u2588\u258b      | 271/730 [00:02&lt;00:02, 175.51it/s]</pre> <pre>\r1000000 agents in f1 nodes:  40%|\u2588\u2588\u2588\u2589      | 289/730 [00:02&lt;00:02, 176.28it/s]</pre> <pre>\r1000000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 307/730 [00:02&lt;00:02, 177.26it/s]</pre> <pre>\r1000000 agents in f1 nodes:  45%|\u2588\u2588\u2588\u2588\u258d     | 326/730 [00:02&lt;00:02, 178.78it/s]</pre> <pre>\r1000000 agents in f1 nodes:  47%|\u2588\u2588\u2588\u2588\u258b     | 345/730 [00:02&lt;00:02, 180.25it/s]</pre> <pre>\r1000000 agents in f1 nodes:  50%|\u2588\u2588\u2588\u2588\u2588     | 365/730 [00:02&lt;00:01, 185.20it/s]</pre> <pre>\r1000000 agents in f1 nodes:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 390/730 [00:02&lt;00:01, 203.19it/s]</pre> <pre>\r1000000 agents in f1 nodes:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 425/730 [00:02&lt;00:01, 244.93it/s]</pre> <pre>\r1000000 agents in f1 nodes:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 468/730 [00:02&lt;00:00, 298.21it/s]</pre> <pre>\r1000000 agents in f1 nodes:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 513/730 [00:03&lt;00:00, 342.93it/s]</pre> <pre>\r1000000 agents in f1 nodes:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 559/730 [00:03&lt;00:00, 376.76it/s]</pre> <pre>\r1000000 agents in f1 nodes:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 605/730 [00:03&lt;00:00, 401.34it/s]</pre> <pre>\r1000000 agents in f1 nodes:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 651/730 [00:03&lt;00:00, 418.33it/s]</pre> <pre>\r1000000 agents in f1 nodes:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 698/730 [00:03&lt;00:00, 431.20it/s]</pre> <pre>\r1000000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:03&lt;00:00, 209.42it/s]</pre> <pre>\n</pre> In\u00a0[3]: Copied! <pre>plt.plot(model.nodes.I.astype(\"int\"), lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S, \"--\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\n\nprint(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all()))\n</pre> plt.plot(model.nodes.I.astype(\"int\"), lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S, \"--\", lw=3) plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])  print(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all())) <pre>S = N-I:  True\n</pre> <p>The below plot shows the model output, the expected logistic growth curve, and the expected logistic growth curve fit to the model with a free offset $t_0$ to account for stochasticity in when the outbreak takes off.  The resulting plot should show good concordance between the model output and the expected logistic equation with the known model inputs $\\beta$ and population. The goodness of this fit could be turned into a strict pass/fail test down the line.</p> In\u00a0[4]: Copied! <pre>def SI_logistic(t, beta, popsize, cbr, t0):\n    mu = (1 + cbr / 1000) ** (1 / 365) - 1\n    x = 1 - mu / beta\n    return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))\n\n\nt = np.arange(model.params.nticks)\n\n\ndef objective(t0):\n    return np.sum((1 - SI_logistic(t, model.params.beta, pop, model.params.cbr, t0) / np.squeeze(model.nodes.I[1:,:])) ** 2)\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(model.nodes.I, lw=4)\nplt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, 0), lw=3)\nplt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, t0_opt), \"r:\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\n</pre> def SI_logistic(t, beta, popsize, cbr, t0):     mu = (1 + cbr / 1000) ** (1 / 365) - 1     x = 1 - mu / beta     return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))   t = np.arange(model.params.nticks)   def objective(t0):     return np.sum((1 - SI_logistic(t, model.params.beta, pop, model.params.cbr, t0) / np.squeeze(model.nodes.I[1:,:])) ** 2)   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(model.nodes.I, lw=4) plt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, 0), lw=3) plt.plot(SI_logistic(t, model.params.beta, pop, model.params.cbr, t0_opt), \"r:\", lw=3) plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) Out[4]: <pre>&lt;matplotlib.legend.Legend at 0x7fad47abf860&gt;</pre> In\u00a0[5]: Copied! <pre># %%capture\nNTESTS = 10\nseeds = [42 + i for i in range(NTESTS)]\npop = 1e5\nnticks = 3650\nbetas = [0.05 + 0.005 * i for i in range(1, NTESTS+1)]\ncbrs = np.random.randint(15, 50, NTESTS)\n\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude)\ninit_inf = 5\nscenario[\"S\"] = scenario.population - init_inf\nscenario[\"I\"] = init_inf\n\nrows = []\nfor i, (seed, beta, cbr) in enumerate(zip(seeds, betas, cbrs)):\n\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"cbr\": cbr})\n    birthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)\n    mortality  = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)\n    model = Model(scenario, parameters, birthrates=birthrates.values)\n\n    model.components = [\n        SI.Susceptible(model),\n        SI.Infectious(model),\n        SI.ConstantPopVitalDynamics(model, birthrates.values, mortality.values),\n        SI.Transmission(model),\n        ]\n    model.run(label=f\"SI Model {i+1:2} of {NTESTS} (beta={beta:0.05f}, cbr={cbr:3})\")\n    cases = model.nodes.I[:-1, 0]\n    popt, pcov = curve_fit(\n        SI_logistic,\n        np.arange(nticks),\n        cases,\n        p0=[beta * (1 + 0.1 * np.random.normal()), pop, cbr * (1 + 0.1 * np.random.normal()), 1],\n        bounds=([0, pop - 1, 0, -100], [1, pop + 1, 600, 100]),\n    )\n    # Pandas complains about concatenating rows to an empty DataFrame, so build a list of dicts and convert at the end\n    rows.append({\n        \"seed\": seed,\n        \"beta\": beta,\n        \"cbr\": cbr,\n        \"cases\": np.array(cases),\n        \"fitted_beta\": popt[0],\n        \"fitted_size\": popt[1],\n        \"fitted_cbr\": popt[2],\n        \"fitted_t0\": popt[3],\n    })\n\noutput = pd.DataFrame(rows)\n</pre> # %%capture NTESTS = 10 seeds = [42 + i for i in range(NTESTS)] pop = 1e5 nticks = 3650 betas = [0.05 + 0.005 * i for i in range(1, NTESTS+1)] cbrs = np.random.randint(15, 50, NTESTS)  scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x, y:  pop,  origin_x=longitude, origin_y=latitude) init_inf = 5 scenario[\"S\"] = scenario.population - init_inf scenario[\"I\"] = init_inf  rows = [] for i, (seed, beta, cbr) in enumerate(zip(seeds, betas, cbrs)):      parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"cbr\": cbr})     birthrates = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)     mortality  = ValuesMap.from_scalar(parameters.cbr, nsteps=parameters.nticks, nnodes=1)     model = Model(scenario, parameters, birthrates=birthrates.values)      model.components = [         SI.Susceptible(model),         SI.Infectious(model),         SI.ConstantPopVitalDynamics(model, birthrates.values, mortality.values),         SI.Transmission(model),         ]     model.run(label=f\"SI Model {i+1:2} of {NTESTS} (beta={beta:0.05f}, cbr={cbr:3})\")     cases = model.nodes.I[:-1, 0]     popt, pcov = curve_fit(         SI_logistic,         np.arange(nticks),         cases,         p0=[beta * (1 + 0.1 * np.random.normal()), pop, cbr * (1 + 0.1 * np.random.normal()), 1],         bounds=([0, pop - 1, 0, -100], [1, pop + 1, 600, 100]),     )     # Pandas complains about concatenating rows to an empty DataFrame, so build a list of dicts and convert at the end     rows.append({         \"seed\": seed,         \"beta\": beta,         \"cbr\": cbr,         \"cases\": np.array(cases),         \"fitted_beta\": popt[0],         \"fitted_size\": popt[1],         \"fitted_cbr\": popt[2],         \"fitted_t0\": popt[3],     })  output = pd.DataFrame(rows)  <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):   4%|\u258d         | 148/3650 [00:00&lt;00:02, 1477.42it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  11%|\u2588         | 389/3650 [00:00&lt;00:01, 2025.16it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  19%|\u2588\u2589        | 688/3650 [00:00&lt;00:01, 2463.17it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  27%|\u2588\u2588\u258b       | 989/3650 [00:00&lt;00:00, 2676.24it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  35%|\u2588\u2588\u2588\u258c      | 1287/3650 [00:00&lt;00:00, 2784.51it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  43%|\u2588\u2588\u2588\u2588\u258e     | 1587/3650 [00:00&lt;00:00, 2857.28it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1887/3650 [00:00&lt;00:00, 2902.27it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 2189/3650 [00:00&lt;00:00, 2933.96it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2489/3650 [00:00&lt;00:00, 2953.04it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2785/3650 [00:01&lt;00:00, 2917.43it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 3085/3650 [00:01&lt;00:00, 2941.75it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47):  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 3385/3650 [00:01&lt;00:00, 2957.87it/s]</pre> <pre>\rSI Model  1 of 10 (beta=0.05500, cbr= 47): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2819.72it/s]</pre> <pre>\n</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):   4%|\u258d         | 148/3650 [00:00&lt;00:02, 1474.91it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  11%|\u2588         | 405/3650 [00:00&lt;00:01, 2117.16it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  19%|\u2588\u2589        | 707/3650 [00:00&lt;00:01, 2527.34it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  28%|\u2588\u2588\u258a       | 1010/3650 [00:00&lt;00:00, 2722.14it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  36%|\u2588\u2588\u2588\u258c      | 1313/3650 [00:00&lt;00:00, 2829.78it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  44%|\u2588\u2588\u2588\u2588\u258d     | 1613/3650 [00:00&lt;00:00, 2885.00it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1917/3650 [00:00&lt;00:00, 2933.03it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 2219/3650 [00:00&lt;00:00, 2960.44it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2521/3650 [00:00&lt;00:00, 2977.19it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2823/3650 [00:01&lt;00:00, 2988.81it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3124/3650 [00:01&lt;00:00, 2993.87it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26):  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 3425/3650 [00:01&lt;00:00, 2998.49it/s]</pre> <pre>\rSI Model  2 of 10 (beta=0.06000, cbr= 26): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2855.60it/s]</pre> <pre>\n</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):   4%|\u258d         | 148/3650 [00:00&lt;00:02, 1476.61it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  11%|\u2588\u258f        | 415/3650 [00:00&lt;00:01, 2177.64it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  20%|\u2588\u2589        | 718/3650 [00:00&lt;00:01, 2562.71it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  28%|\u2588\u2588\u258a       | 1021/3650 [00:00&lt;00:00, 2743.69it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  36%|\u2588\u2588\u2588\u258c      | 1323/3650 [00:00&lt;00:00, 2840.46it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  45%|\u2588\u2588\u2588\u2588\u258d     | 1627/3650 [00:00&lt;00:00, 2906.77it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1929/3650 [00:00&lt;00:00, 2943.48it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 2232/3650 [00:00&lt;00:00, 2968.63it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2534/3650 [00:00&lt;00:00, 2984.31it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2835/3650 [00:01&lt;00:00, 2991.33it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3139/3650 [00:01&lt;00:00, 3003.49it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21):  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 3441/3650 [00:01&lt;00:00, 3007.86it/s]</pre> <pre>\rSI Model  3 of 10 (beta=0.06500, cbr= 21): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2869.90it/s]</pre> <pre>\n</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):   4%|\u258d         | 149/3650 [00:00&lt;00:02, 1484.92it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  12%|\u2588\u258f        | 437/3650 [00:00&lt;00:01, 2303.72it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  20%|\u2588\u2588        | 739/3650 [00:00&lt;00:01, 2627.68it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  29%|\u2588\u2588\u258a       | 1041/3650 [00:00&lt;00:00, 2779.53it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  37%|\u2588\u2588\u2588\u258b      | 1344/3650 [00:00&lt;00:00, 2868.44it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  45%|\u2588\u2588\u2588\u2588\u258d     | 1634/3650 [00:00&lt;00:00, 2877.55it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1927/3650 [00:00&lt;00:00, 2892.01it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 2229/3650 [00:00&lt;00:00, 2929.69it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2530/3650 [00:00&lt;00:00, 2952.02it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2833/3650 [00:01&lt;00:00, 2973.51it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3135/3650 [00:01&lt;00:00, 2987.37it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38):  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 3434/3650 [00:01&lt;00:00, 2965.68it/s]</pre> <pre>\rSI Model  4 of 10 (beta=0.07000, cbr= 38): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2858.18it/s]</pre> <pre>\n</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):   4%|\u258d         | 148/3650 [00:00&lt;00:02, 1479.12it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  12%|\u2588\u258f        | 435/3650 [00:00&lt;00:01, 2292.66it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  20%|\u2588\u2588        | 736/3650 [00:00&lt;00:01, 2619.62it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  28%|\u2588\u2588\u258a       | 1037/3650 [00:00&lt;00:00, 2773.11it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  37%|\u2588\u2588\u2588\u258b      | 1338/3650 [00:00&lt;00:00, 2857.25it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  45%|\u2588\u2588\u2588\u2588\u258d     | 1639/3650 [00:00&lt;00:00, 2908.05it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1939/3650 [00:00&lt;00:00, 2935.65it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 2234/3650 [00:00&lt;00:00, 2939.67it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2536/3650 [00:00&lt;00:00, 2962.56it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2838/3650 [00:01&lt;00:00, 2979.51it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 3140/3650 [00:01&lt;00:00, 2991.45it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39):  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 3443/3650 [00:01&lt;00:00, 3002.30it/s]</pre> <pre>\rSI Model  5 of 10 (beta=0.07500, cbr= 39): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2872.44it/s]</pre> <pre>\n</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):   4%|\u258d         | 160/3650 [00:00&lt;00:02, 1596.82it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  13%|\u2588\u258e        | 460/3650 [00:00&lt;00:01, 2417.43it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  21%|\u2588\u2588        | 762/3650 [00:00&lt;00:01, 2691.93it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  29%|\u2588\u2588\u2589       | 1063/3650 [00:00&lt;00:00, 2816.77it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  37%|\u2588\u2588\u2588\u258b      | 1364/3650 [00:00&lt;00:00, 2885.06it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  46%|\u2588\u2588\u2588\u2588\u258c     | 1665/3650 [00:00&lt;00:00, 2924.67it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1966/3650 [00:00&lt;00:00, 2951.24it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 2268/3650 [00:00&lt;00:00, 2971.06it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2567/3650 [00:00&lt;00:00, 2974.34it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2869/3650 [00:01&lt;00:00, 2986.06it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3170/3650 [00:01&lt;00:00, 2992.40it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30):  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 3472/3650 [00:01&lt;00:00, 2997.88it/s]</pre> <pre>\rSI Model  6 of 10 (beta=0.08000, cbr= 30): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2891.95it/s]</pre> <pre>\n</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):   4%|\u258d         | 160/3650 [00:00&lt;00:02, 1595.54it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  13%|\u2588\u258e        | 459/3650 [00:00&lt;00:01, 2414.51it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  21%|\u2588\u2588        | 760/3650 [00:00&lt;00:01, 2685.58it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  29%|\u2588\u2588\u2589       | 1054/3650 [00:00&lt;00:00, 2784.35it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  37%|\u2588\u2588\u2588\u258b      | 1356/3650 [00:00&lt;00:00, 2868.65it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  45%|\u2588\u2588\u2588\u2588\u258c     | 1658/3650 [00:00&lt;00:00, 2917.25it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  54%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1959/3650 [00:00&lt;00:00, 2945.53it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 2261/3650 [00:00&lt;00:00, 2966.68it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2563/3650 [00:00&lt;00:00, 2981.43it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2862/3650 [00:01&lt;00:00, 2983.66it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3165/3650 [00:01&lt;00:00, 2994.75it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48):  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 3465/3650 [00:01&lt;00:00, 2989.55it/s]</pre> <pre>\rSI Model  7 of 10 (beta=0.08500, cbr= 48): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2884.26it/s]</pre> <pre>\n</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):   4%|\u258d         | 163/3650 [00:00&lt;00:02, 1625.20it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  13%|\u2588\u258e        | 462/3650 [00:00&lt;00:01, 2426.68it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  21%|\u2588\u2588        | 764/3650 [00:00&lt;00:01, 2696.35it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  29%|\u2588\u2588\u2589       | 1067/3650 [00:00&lt;00:00, 2826.14it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  38%|\u2588\u2588\u2588\u258a      | 1369/3650 [00:00&lt;00:00, 2893.11it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  46%|\u2588\u2588\u2588\u2588\u258c     | 1670/3650 [00:00&lt;00:00, 2932.60it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1971/3650 [00:00&lt;00:00, 2957.30it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 2274/3650 [00:00&lt;00:00, 2978.96it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2575/3650 [00:00&lt;00:00, 2987.02it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2878/3650 [00:01&lt;00:00, 2998.35it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3178/3650 [00:01&lt;00:00, 2997.61it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27):  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 3481/3650 [00:01&lt;00:00, 3004.24it/s]</pre> <pre>\rSI Model  8 of 10 (beta=0.09000, cbr= 27): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2899.46it/s]</pre> <pre>\n</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):   5%|\u258d         | 166/3650 [00:00&lt;00:02, 1659.16it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  13%|\u2588\u258e        | 467/3650 [00:00&lt;00:01, 2449.40it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  21%|\u2588\u2588        | 768/3650 [00:00&lt;00:01, 2702.74it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  29%|\u2588\u2588\u2589       | 1067/3650 [00:00&lt;00:00, 2814.52it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  38%|\u2588\u2588\u2588\u258a      | 1369/3650 [00:00&lt;00:00, 2887.01it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  46%|\u2588\u2588\u2588\u2588\u258c     | 1672/3650 [00:00&lt;00:00, 2933.40it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1974/3650 [00:00&lt;00:00, 2959.65it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 2275/3650 [00:00&lt;00:00, 2973.40it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2578/3650 [00:00&lt;00:00, 2990.19it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2880/3650 [00:01&lt;00:00, 2997.09it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3180/3650 [00:01&lt;00:00, 2988.21it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32):  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 3479/3650 [00:01&lt;00:00, 2963.26it/s]</pre> <pre>\rSI Model  9 of 10 (beta=0.09500, cbr= 32): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2883.94it/s]</pre> <pre>\n</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):   0%|          | 0/3650 [00:00&lt;?, ?it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):   5%|\u258d         | 171/3650 [00:00&lt;00:02, 1709.51it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  13%|\u2588\u258e        | 469/3650 [00:00&lt;00:01, 2455.50it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  21%|\u2588\u2588        | 770/3650 [00:00&lt;00:01, 2706.45it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  29%|\u2588\u2588\u2589       | 1072/3650 [00:00&lt;00:00, 2828.84it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  38%|\u2588\u2588\u2588\u258a      | 1374/3650 [00:00&lt;00:00, 2896.12it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  46%|\u2588\u2588\u2588\u2588\u258c     | 1676/3650 [00:00&lt;00:00, 2936.92it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1977/3650 [00:00&lt;00:00, 2959.85it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 2279/3650 [00:00&lt;00:00, 2977.00it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2579/3650 [00:00&lt;00:00, 2983.23it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2881/3650 [00:01&lt;00:00, 2992.36it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 3184/3650 [00:01&lt;00:00, 3002.23it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39):  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 3485/3650 [00:01&lt;00:00, 2999.74it/s]</pre> <pre>\rSI Model 10 of 10 (beta=0.10000, cbr= 39): 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3650/3650 [00:01&lt;00:00, 2902.10it/s]</pre> <pre>\n</pre> In\u00a0[6]: Copied! <pre>plt.figure()\nplt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlim(0.04, 0.12)\nplt.ylim(0.04, 0.12)\nplt.figure()\nplt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"fitted_beta\"], \"o\")\nplt.xlim(0.04, 0.12)\nplt.ylim(-0.1, 0.12)\nplt.figure()\nplt.plot(output[\"cbr\"], output[\"fitted_cbr\"], \"o\")\nplt.xlim(15, 50)\nplt.ylim(15, 50)\nplt.figure()\nplt.plot(output[\"cbr\"], (output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"fitted_cbr\"], \"o\")\nplt.xlim(15, 50)\nplt.ylim(-0.2, 0.2)\n</pre> plt.figure() plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlim(0.04, 0.12) plt.ylim(0.04, 0.12) plt.figure() plt.plot(output[\"beta\"], (output[\"beta\"] - output[\"fitted_beta\"]) / output[\"fitted_beta\"], \"o\") plt.xlim(0.04, 0.12) plt.ylim(-0.1, 0.12) plt.figure() plt.plot(output[\"cbr\"], output[\"fitted_cbr\"], \"o\") plt.xlim(15, 50) plt.ylim(15, 50) plt.figure() plt.plot(output[\"cbr\"], (output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"fitted_cbr\"], \"o\") plt.xlim(15, 50) plt.ylim(-0.2, 0.2) Out[6]: <pre>(-0.2, 0.2)</pre> In\u00a0[7]: Copied! <pre>print(\n    \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05))\n)\nprint(\"All fitted CBR are within 5% of known CBR: \" + str(np.all(np.abs((output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"cbr\"]) &lt; 0.05)))\n</pre> print(     \"All fitted beta are within 5% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.05)) ) print(\"All fitted CBR are within 5% of known CBR: \" + str(np.all(np.abs((output[\"cbr\"] - output[\"fitted_cbr\"]) / output[\"cbr\"]) &lt; 0.05))) <pre>All fitted beta are within 5% of known beta: True\nAll fitted CBR are within 5% of known CBR: False\n</pre> In\u00a0[8]: Copied! <pre>output\n</pre> output Out[8]: seed beta cbr cases fitted_beta fitted_size fitted_cbr fitted_t0 0 42 0.055 47 [5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 8, 9, 10, 11... 0.054300 100000.693855 45.117655 -30.628515 1 43 0.060 26 [5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, ... 0.059231 99999.775766 24.796546 -24.422073 2 44 0.065 21 [5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 9, 9, 10, 12... 0.064130 99999.649544 19.928978 -17.442545 3 45 0.070 38 [5, 8, 8, 8, 10, 10, 11, 11, 11, 11, 13, 14, 1... 0.069008 100000.974802 36.472548 -28.639329 4 46 0.075 39 [5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 7, 8, 8, 9, ... 0.073662 100000.374597 36.102279 -15.814324 5 47 0.080 30 [5, 6, 7, 7, 7, 8, 9, 9, 9, 10, 13, 14, 15, 18... 0.078307 100000.072769 27.947842 -27.901519 6 48 0.085 48 [5, 6, 7, 8, 8, 8, 8, 9, 9, 10, 11, 12, 12, 14... 0.083425 99999.001151 44.086087 -15.485017 7 49 0.090 27 [5, 5, 5, 5, 6, 7, 7, 7, 8, 8, 11, 12, 13, 13,... 0.087963 100000.580630 24.971519 -13.474283 8 50 0.095 32 [5, 5, 6, 6, 6, 6, 8, 8, 10, 12, 13, 14, 14, 1... 0.092155 100000.325303 29.393805 -13.163659 9 51 0.100 39 [5, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, ... 0.097292 100000.749784 36.101978 -7.321610 In\u00a0[9]: Copied! <pre>row = output.iloc[9]\ncases_row = row[\"cases\"]\nfitted_beta = row[\"fitted_beta\"]\nfitted_size = row[\"fitted_size\"]\nfitted_cbr = row[\"fitted_cbr\"]\nfitted_t0 = row[\"fitted_t0\"]\n\nplt.figure()\nplt.plot(cases_row, label=\"Case Trace\")\nplt.plot(SI_logistic(np.arange(nticks), fitted_beta, fitted_size, fitted_cbr, fitted_t0), label=\"Logistic Fit\", ls=\"--\")\nplt.legend()\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Cases\")\nplt.title(\"Case Trace and Logistic Fit for Row 0\")\n# plt.ylim(9.8e5, 1e6)\nplt.show()\n</pre> row = output.iloc[9] cases_row = row[\"cases\"] fitted_beta = row[\"fitted_beta\"] fitted_size = row[\"fitted_size\"] fitted_cbr = row[\"fitted_cbr\"] fitted_t0 = row[\"fitted_t0\"]  plt.figure() plt.plot(cases_row, label=\"Case Trace\") plt.plot(SI_logistic(np.arange(nticks), fitted_beta, fitted_size, fitted_cbr, fitted_t0), label=\"Logistic Fit\", ls=\"--\") plt.legend() plt.xlabel(\"Time (days)\") plt.ylabel(\"Cases\") plt.title(\"Case Trace and Logistic Fit for Row 0\") # plt.ylim(9.8e5, 1e6) plt.show() <p>Just an interesting note - because I kicked the simulations off with 3 infections rather than 1 (to ensure that the initial infection doesn't die before infecting someone), we consistently get a negative fit value for t0, and one that is a larger negative value for the lowest $\\beta$ values.</p>"},{"location":"notebooks/02_SI_wbirths_logistic_growth/#si-model-with-constant-population-demographics","title":"SI Model with constant-population demographics\u00b6","text":"<p>Building up from the SI model without demography, we next explore the addition of basic demographics - adding a birth rate &amp; an equivalent, age-independent mortality rate $\\mu$ to keep constant total population.  The disease model remains the SI model.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\mu I $$</p> <p>With a bit of manipulation as in the previous example, this can be worked back into the form of a generalized logistic growth differential equation $$ \\dot{I} = \\beta I (1-\\frac{\\mu}{\\beta}-\\frac{I}{N})$$</p> <p>With solution $$ \\frac{Nx}{1+(\\frac{Nx}{I_0}-1)e^{-\\beta x t}} \\\\ x = (1-\\frac{\\mu}{\\beta}) $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"notebooks/02_SI_wbirths_logistic_growth/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with four components: the <code>Susceptible</code> and <code>Infected</code> states, and the <code>Transmission</code>, and <code>ConstantPopVitalDynamics</code> \"flows\" between states.  Finally, we initialize with a single infection and run.  The <code>Susceptible</code>, <code>Infected</code> and <code>Transmission</code> components are described in the the model with no births.  <code>ConstantPopVitalDynamics</code> enables births and deaths while strictly enforcing constant population rather than having separate stochastic birth and death processes that induce population variance over time.  To do this, births are implemented by randomly choosing an existing agent and re-initializing them as a newborn; in this way, each birth of a new agent is exactly offset by the death of an existing one.</p>"},{"location":"notebooks/02_SI_wbirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.</p>"},{"location":"notebooks/02_SI_wbirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  First, we run a basic test on a single model, and show the result matches expectation with known inputs.  Then, as before, we select a few values of $\\beta$ and $\\mu$, run the model, fit the outputs to the logistic equation, and compare the fitted values of the parameters to the known value.  The equation above makes it clear that attempting to fit $\\beta, \\mu$ and N all together will be degenerate - the logistic equation has two parameters, not three; in this case those two are the products $N x$ and $\\beta x$.  Thus, we fix the total population size $N$ in the fit to focus on the more interesting $\\beta$ and $\\mu$ parameters.  And as before, because we are approximating continuously compounding growth, in the logistic equation, with a discrete time-step approximation, we expect the fitted values of $\\beta$ to be biased slightly downward - that is, the modeled trajectory is slightly slower than the continuous-time counterpart.  This error grows as $\\beta$ gets larger; the test fails if any of the fitted $\\beta$ values are more than 5% away from the known values.  Furthermore, if the outbreak is seeded by only one infection, it is possible that that one infection dies prior to infecting anyone else; we therefore seed with a few infections rather than one.</p>"},{"location":"notebooks/02_SI_wbirths_logistic_growth/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the relationships between susceptible, infected, and total population hold.  In the version with no births, we could also test that the infected = the sum of past incidence, but with births now playing a role that no longer holds.</p>"},{"location":"notebooks/02_SI_wbirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of $\\beta$ &amp; birth rate  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>Because we are approximating continuously compounding growth by discrete-time compounding growth, we should expect the fitted $\\beta$  to consistently be slightly underestimated relative to the true $\\beta$ , with the relative difference growing as $\\beta$  gets larger.</p> <p>In the future, we could probably compute the expected error from this approximation.  But for now, to make this a pass-fail test, we will raise a flag if the fitted parameters are more than 5% different than the known ones.</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/","title":"SIS Model with no demographics","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numba as nb\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.optimize import minimize\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numba as nb import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.optimize import minimize  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.4'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>from laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nimport laser.core.distributions as dists\nimport laser.generic.models.SIS as SIS\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import grid\n</pre> from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator import laser.core.distributions as dists import laser.generic.models.SIS as SIS from laser.generic.models.model import Model from laser.generic.newutils import grid <p>To make sure we don't accumulate lots of finite time-step error, make inf mean quite long in units of timestep</p> In\u00a0[3]: Copied! <pre>pop = 3e5\n\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 1\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\nparameters = PropertySet({\"seed\": 42, \"nticks\": 3000, \"beta\": 0.1, \"inf_mean\": 32})\n\ninfdurdist = dists.exponential(scale=parameters.inf_mean)\n\n# Sampling this pyramid will return indices in [0, 88] with equal probability.\npyramid = AliasedDistribution(np.full(89, 1_000))\n# The survival function will return the probability of surviving past each age.\nsurvival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\n</pre> pop = 3e5  scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 1 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected parameters = PropertySet({\"seed\": 42, \"nticks\": 3000, \"beta\": 0.1, \"inf_mean\": 32})  infdurdist = dists.exponential(scale=parameters.inf_mean)  # Sampling this pyramid will return indices in [0, 88] with equal probability. pyramid = AliasedDistribution(np.full(89, 1_000)) # The survival function will return the probability of surviving past each age. survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())  In\u00a0[4]: Copied! <pre># Run until we get an outbreak\noutbreak = False\nwhile not outbreak:\n    parameters.seed += 1\n    model = Model(scenario, parameters)\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run()\n    outbreak = np.any(model.nodes.I[200] &gt; 0)\n</pre> # Run until we get an outbreak outbreak = False while not outbreak:     parameters.seed += 1     model = Model(scenario, parameters)      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run()     outbreak = np.any(model.nodes.I[200] &gt; 0)  <pre>\r300000 agents in f1 nodes:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\r300000 agents in f1 nodes:   0%|          | 1/3000 [00:01&lt;1:09:33,  1.39s/it]</pre> <pre>\r300000 agents in f1 nodes:   3%|\u258e         | 76/3000 [00:01&lt;00:41, 70.40it/s] </pre> <pre>\r300000 agents in f1 nodes:   5%|\u258c         | 155/3000 [00:01&lt;00:18, 154.63it/s]</pre> <pre>\r300000 agents in f1 nodes:   8%|\u258a         | 234/3000 [00:01&lt;00:11, 245.37it/s]</pre> <pre>\r300000 agents in f1 nodes:  10%|\u2588         | 313/3000 [00:01&lt;00:07, 337.46it/s]</pre> <pre>\r300000 agents in f1 nodes:  13%|\u2588\u258e        | 391/3000 [00:01&lt;00:06, 423.55it/s]</pre> <pre>\r300000 agents in f1 nodes:  16%|\u2588\u258c        | 470/3000 [00:01&lt;00:05, 502.17it/s]</pre> <pre>\r300000 agents in f1 nodes:  18%|\u2588\u258a        | 549/3000 [00:02&lt;00:04, 569.38it/s]</pre> <pre>\r300000 agents in f1 nodes:  21%|\u2588\u2588        | 627/3000 [00:02&lt;00:03, 622.19it/s]</pre> <pre>\r300000 agents in f1 nodes:  24%|\u2588\u2588\u258e       | 706/3000 [00:02&lt;00:03, 664.61it/s]</pre> <pre>\r300000 agents in f1 nodes:  26%|\u2588\u2588\u258c       | 785/3000 [00:02&lt;00:03, 697.23it/s]</pre> <pre>\r300000 agents in f1 nodes:  29%|\u2588\u2588\u2589       | 863/3000 [00:02&lt;00:02, 720.25it/s]</pre> <pre>\r300000 agents in f1 nodes:  31%|\u2588\u2588\u2588\u258f      | 942/3000 [00:02&lt;00:02, 738.49it/s]</pre> <pre>\r300000 agents in f1 nodes:  34%|\u2588\u2588\u2588\u258d      | 1021/3000 [00:02&lt;00:02, 750.76it/s]</pre> <pre>\r300000 agents in f1 nodes:  37%|\u2588\u2588\u2588\u258b      | 1099/3000 [00:02&lt;00:02, 758.92it/s]</pre> <pre>\r300000 agents in f1 nodes:  39%|\u2588\u2588\u2588\u2589      | 1177/3000 [00:02&lt;00:02, 764.91it/s]</pre> <pre>\r300000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 1256/3000 [00:03&lt;00:02, 770.64it/s]</pre> <pre>\r300000 agents in f1 nodes:  44%|\u2588\u2588\u2588\u2588\u258d     | 1335/3000 [00:03&lt;00:02, 773.89it/s]</pre> <pre>\r300000 agents in f1 nodes:  47%|\u2588\u2588\u2588\u2588\u258b     | 1414/3000 [00:03&lt;00:02, 776.49it/s]</pre> <pre>\r300000 agents in f1 nodes:  50%|\u2588\u2588\u2588\u2588\u2589     | 1493/3000 [00:03&lt;00:01, 778.80it/s]</pre> <pre>\r300000 agents in f1 nodes:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1572/3000 [00:03&lt;00:01, 780.49it/s]</pre> <pre>\r300000 agents in f1 nodes:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1651/3000 [00:03&lt;00:01, 780.73it/s]</pre> <pre>\r300000 agents in f1 nodes:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1730/3000 [00:03&lt;00:01, 782.40it/s]</pre> <pre>\r300000 agents in f1 nodes:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1809/3000 [00:03&lt;00:01, 782.58it/s]</pre> <pre>\r300000 agents in f1 nodes:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1888/3000 [00:03&lt;00:01, 782.42it/s]</pre> <pre>\r300000 agents in f1 nodes:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1967/3000 [00:03&lt;00:01, 780.70it/s]</pre> <pre>\r300000 agents in f1 nodes:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2046/3000 [00:04&lt;00:01, 779.82it/s]</pre> <pre>\r300000 agents in f1 nodes:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2125/3000 [00:04&lt;00:01, 781.07it/s]</pre> <pre>\r300000 agents in f1 nodes:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2204/3000 [00:04&lt;00:01, 780.98it/s]</pre> <pre>\r300000 agents in f1 nodes:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2283/3000 [00:04&lt;00:00, 781.55it/s]</pre> <pre>\r300000 agents in f1 nodes:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2362/3000 [00:04&lt;00:00, 761.59it/s]</pre> <pre>\r300000 agents in f1 nodes:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2440/3000 [00:04&lt;00:00, 765.77it/s]</pre> <pre>\r300000 agents in f1 nodes:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2519/3000 [00:04&lt;00:00, 770.10it/s]</pre> <pre>\r300000 agents in f1 nodes:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2598/3000 [00:04&lt;00:00, 774.50it/s]</pre> <pre>\r300000 agents in f1 nodes:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2677/3000 [00:04&lt;00:00, 776.15it/s]</pre> <pre>\r300000 agents in f1 nodes:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2756/3000 [00:04&lt;00:00, 777.73it/s]</pre> <pre>\r300000 agents in f1 nodes:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2835/3000 [00:05&lt;00:00, 779.04it/s]</pre> <pre>\r300000 agents in f1 nodes:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2914/3000 [00:05&lt;00:00, 780.25it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2993/3000 [00:05&lt;00:00, 781.37it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:05&lt;00:00, 572.13it/s]</pre> <pre>\n</pre> <pre>\r300000 agents in f1 nodes:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\r300000 agents in f1 nodes:   3%|\u258e         | 79/3000 [00:00&lt;00:03, 781.64it/s]</pre> <pre>\r300000 agents in f1 nodes:   5%|\u258c         | 158/3000 [00:00&lt;00:03, 781.33it/s]</pre> <pre>\r300000 agents in f1 nodes:   8%|\u258a         | 237/3000 [00:00&lt;00:03, 782.73it/s]</pre> <pre>\r300000 agents in f1 nodes:  11%|\u2588         | 316/3000 [00:00&lt;00:03, 782.40it/s]</pre> <pre>\r300000 agents in f1 nodes:  13%|\u2588\u258e        | 395/3000 [00:00&lt;00:03, 783.39it/s]</pre> <pre>\r300000 agents in f1 nodes:  16%|\u2588\u258c        | 474/3000 [00:00&lt;00:03, 783.61it/s]</pre> <pre>\r300000 agents in f1 nodes:  18%|\u2588\u258a        | 553/3000 [00:00&lt;00:03, 783.37it/s]</pre> <pre>\r300000 agents in f1 nodes:  21%|\u2588\u2588        | 632/3000 [00:00&lt;00:03, 784.00it/s]</pre> <pre>\r300000 agents in f1 nodes:  24%|\u2588\u2588\u258e       | 711/3000 [00:00&lt;00:02, 775.69it/s]</pre> <pre>\r300000 agents in f1 nodes:  26%|\u2588\u2588\u258b       | 789/3000 [00:01&lt;00:02, 776.61it/s]</pre> <pre>\r300000 agents in f1 nodes:  29%|\u2588\u2588\u2589       | 867/3000 [00:01&lt;00:02, 776.85it/s]</pre> <pre>\r300000 agents in f1 nodes:  32%|\u2588\u2588\u2588\u258f      | 946/3000 [00:01&lt;00:02, 779.39it/s]</pre> <pre>\r300000 agents in f1 nodes:  34%|\u2588\u2588\u2588\u258d      | 1025/3000 [00:01&lt;00:02, 781.37it/s]</pre> <pre>\r300000 agents in f1 nodes:  37%|\u2588\u2588\u2588\u258b      | 1104/3000 [00:01&lt;00:02, 781.73it/s]</pre> <pre>\r300000 agents in f1 nodes:  39%|\u2588\u2588\u2588\u2589      | 1183/3000 [00:01&lt;00:02, 782.44it/s]</pre> <pre>\r300000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 1262/3000 [00:01&lt;00:02, 783.03it/s]</pre> <pre>\r300000 agents in f1 nodes:  45%|\u2588\u2588\u2588\u2588\u258d     | 1341/3000 [00:01&lt;00:02, 777.63it/s]</pre> <pre>\r300000 agents in f1 nodes:  47%|\u2588\u2588\u2588\u2588\u258b     | 1420/3000 [00:01&lt;00:02, 779.84it/s]</pre> <pre>\r300000 agents in f1 nodes:  50%|\u2588\u2588\u2588\u2588\u2589     | 1499/3000 [00:01&lt;00:01, 781.75it/s]</pre> <pre>\r300000 agents in f1 nodes:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1578/3000 [00:02&lt;00:01, 781.46it/s]</pre> <pre>\r300000 agents in f1 nodes:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1657/3000 [00:02&lt;00:01, 780.59it/s]</pre> <pre>\r300000 agents in f1 nodes:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1736/3000 [00:02&lt;00:01, 781.32it/s]</pre> <pre>\r300000 agents in f1 nodes:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1815/3000 [00:02&lt;00:01, 783.11it/s]</pre> <pre>\r300000 agents in f1 nodes:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1894/3000 [00:02&lt;00:01, 784.08it/s]</pre> <pre>\r300000 agents in f1 nodes:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1973/3000 [00:02&lt;00:01, 784.82it/s]</pre> <pre>\r300000 agents in f1 nodes:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2052/3000 [00:02&lt;00:01, 784.39it/s]</pre> <pre>\r300000 agents in f1 nodes:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2131/3000 [00:02&lt;00:01, 784.14it/s]</pre> <pre>\r300000 agents in f1 nodes:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2210/3000 [00:02&lt;00:01, 785.02it/s]</pre> <pre>\r300000 agents in f1 nodes:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2289/3000 [00:02&lt;00:00, 784.46it/s]</pre> <pre>\r300000 agents in f1 nodes:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2368/3000 [00:03&lt;00:00, 784.19it/s]</pre> <pre>\r300000 agents in f1 nodes:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2447/3000 [00:03&lt;00:00, 782.63it/s]</pre> <pre>\r300000 agents in f1 nodes:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2526/3000 [00:03&lt;00:00, 782.51it/s]</pre> <pre>\r300000 agents in f1 nodes:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2605/3000 [00:03&lt;00:00, 783.73it/s]</pre> <pre>\r300000 agents in f1 nodes:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2684/3000 [00:03&lt;00:00, 783.03it/s]</pre> <pre>\r300000 agents in f1 nodes:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2763/3000 [00:03&lt;00:00, 779.05it/s]</pre> <pre>\r300000 agents in f1 nodes:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2842/3000 [00:03&lt;00:00, 780.71it/s]</pre> <pre>\r300000 agents in f1 nodes:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2921/3000 [00:03&lt;00:00, 781.85it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:03&lt;00:00, 782.77it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:03&lt;00:00, 781.80it/s]</pre> <pre>\n</pre> <pre>\r300000 agents in f1 nodes:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\r300000 agents in f1 nodes:   3%|\u258e         | 79/3000 [00:00&lt;00:03, 784.33it/s]</pre> <pre>\r300000 agents in f1 nodes:   5%|\u258c         | 158/3000 [00:00&lt;00:03, 767.92it/s]</pre> <pre>\r300000 agents in f1 nodes:   8%|\u258a         | 237/3000 [00:00&lt;00:03, 774.15it/s]</pre> <pre>\r300000 agents in f1 nodes:  11%|\u2588         | 316/3000 [00:00&lt;00:03, 778.29it/s]</pre> <pre>\r300000 agents in f1 nodes:  13%|\u2588\u258e        | 395/3000 [00:00&lt;00:03, 780.20it/s]</pre> <pre>\r300000 agents in f1 nodes:  16%|\u2588\u258c        | 474/3000 [00:00&lt;00:03, 781.49it/s]</pre> <pre>\r300000 agents in f1 nodes:  18%|\u2588\u258a        | 553/3000 [00:00&lt;00:03, 781.66it/s]</pre> <pre>\r300000 agents in f1 nodes:  21%|\u2588\u2588        | 632/3000 [00:00&lt;00:03, 782.16it/s]</pre> <pre>\r300000 agents in f1 nodes:  24%|\u2588\u2588\u258e       | 711/3000 [00:00&lt;00:02, 783.26it/s]</pre> <pre>\r300000 agents in f1 nodes:  26%|\u2588\u2588\u258b       | 790/3000 [00:01&lt;00:02, 783.45it/s]</pre> <pre>\r300000 agents in f1 nodes:  29%|\u2588\u2588\u2589       | 869/3000 [00:01&lt;00:02, 783.94it/s]</pre> <pre>\r300000 agents in f1 nodes:  32%|\u2588\u2588\u2588\u258f      | 948/3000 [00:01&lt;00:02, 784.59it/s]</pre> <pre>\r300000 agents in f1 nodes:  34%|\u2588\u2588\u2588\u258d      | 1027/3000 [00:01&lt;00:02, 784.65it/s]</pre> <pre>\r300000 agents in f1 nodes:  37%|\u2588\u2588\u2588\u258b      | 1106/3000 [00:01&lt;00:02, 784.95it/s]</pre> <pre>\r300000 agents in f1 nodes:  40%|\u2588\u2588\u2588\u2589      | 1185/3000 [00:01&lt;00:02, 779.32it/s]</pre> <pre>\r300000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 1263/3000 [00:01&lt;00:02, 778.37it/s]</pre> <pre>\r300000 agents in f1 nodes:  45%|\u2588\u2588\u2588\u2588\u258d     | 1342/3000 [00:01&lt;00:02, 778.87it/s]</pre> <pre>\r300000 agents in f1 nodes:  47%|\u2588\u2588\u2588\u2588\u258b     | 1420/3000 [00:01&lt;00:02, 777.84it/s]</pre> <pre>\r300000 agents in f1 nodes:  50%|\u2588\u2588\u2588\u2588\u2589     | 1499/3000 [00:01&lt;00:01, 779.70it/s]</pre> <pre>\r300000 agents in f1 nodes:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1578/3000 [00:02&lt;00:01, 780.54it/s]</pre> <pre>\r300000 agents in f1 nodes:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1657/3000 [00:02&lt;00:01, 782.05it/s]</pre> <pre>\r300000 agents in f1 nodes:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1736/3000 [00:02&lt;00:01, 782.89it/s]</pre> <pre>\r300000 agents in f1 nodes:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1815/3000 [00:02&lt;00:01, 783.72it/s]</pre> <pre>\r300000 agents in f1 nodes:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1894/3000 [00:02&lt;00:01, 784.00it/s]</pre> <pre>\r300000 agents in f1 nodes:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1973/3000 [00:02&lt;00:01, 783.99it/s]</pre> <pre>\r300000 agents in f1 nodes:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2052/3000 [00:02&lt;00:01, 783.54it/s]</pre> <pre>\r300000 agents in f1 nodes:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2131/3000 [00:02&lt;00:01, 779.05it/s]</pre> <pre>\r300000 agents in f1 nodes:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2209/3000 [00:02&lt;00:01, 765.42it/s]</pre> <pre>\r300000 agents in f1 nodes:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2288/3000 [00:02&lt;00:00, 770.82it/s]</pre> <pre>\r300000 agents in f1 nodes:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2367/3000 [00:03&lt;00:00, 774.63it/s]</pre> <pre>\r300000 agents in f1 nodes:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2446/3000 [00:03&lt;00:00, 776.86it/s]</pre> <pre>\r300000 agents in f1 nodes:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2525/3000 [00:03&lt;00:00, 779.55it/s]</pre> <pre>\r300000 agents in f1 nodes:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2604/3000 [00:03&lt;00:00, 780.99it/s]</pre> <pre>\r300000 agents in f1 nodes:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2683/3000 [00:03&lt;00:00, 782.00it/s]</pre> <pre>\r300000 agents in f1 nodes:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2762/3000 [00:03&lt;00:00, 783.01it/s]</pre> <pre>\r300000 agents in f1 nodes:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2841/3000 [00:03&lt;00:00, 783.74it/s]</pre> <pre>\r300000 agents in f1 nodes:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2920/3000 [00:03&lt;00:00, 782.12it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2999/3000 [00:03&lt;00:00, 781.52it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:03&lt;00:00, 780.17it/s]</pre> <pre>\n</pre> <pre>\r300000 agents in f1 nodes:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\r300000 agents in f1 nodes:   2%|\u258e         | 75/3000 [00:00&lt;00:03, 741.43it/s]</pre> <pre>\r300000 agents in f1 nodes:   5%|\u258c         | 152/3000 [00:00&lt;00:03, 755.49it/s]</pre> <pre>\r300000 agents in f1 nodes:   8%|\u258a         | 228/3000 [00:00&lt;00:03, 726.70it/s]</pre> <pre>\r300000 agents in f1 nodes:  10%|\u2588         | 314/3000 [00:00&lt;00:03, 775.86it/s]</pre> <pre>\r300000 agents in f1 nodes:  13%|\u2588\u258e        | 401/3000 [00:00&lt;00:03, 805.96it/s]</pre> <pre>\r300000 agents in f1 nodes:  16%|\u2588\u258b        | 488/3000 [00:00&lt;00:03, 824.39it/s]</pre> <pre>\r300000 agents in f1 nodes:  19%|\u2588\u2589        | 575/3000 [00:00&lt;00:02, 836.16it/s]</pre> <pre>\r300000 agents in f1 nodes:  22%|\u2588\u2588\u258f       | 661/3000 [00:00&lt;00:02, 841.99it/s]</pre> <pre>\r300000 agents in f1 nodes:  25%|\u2588\u2588\u258d       | 747/3000 [00:00&lt;00:02, 847.12it/s]</pre> <pre>\r300000 agents in f1 nodes:  28%|\u2588\u2588\u258a       | 834/3000 [00:01&lt;00:02, 852.03it/s]</pre> <pre>\r300000 agents in f1 nodes:  31%|\u2588\u2588\u2588       | 920/3000 [00:01&lt;00:02, 854.39it/s]</pre> <pre>\r300000 agents in f1 nodes:  34%|\u2588\u2588\u2588\u258e      | 1006/3000 [00:01&lt;00:02, 855.38it/s]</pre> <pre>\r300000 agents in f1 nodes:  36%|\u2588\u2588\u2588\u258b      | 1092/3000 [00:01&lt;00:02, 853.70it/s]</pre> <pre>\r300000 agents in f1 nodes:  39%|\u2588\u2588\u2588\u2589      | 1178/3000 [00:01&lt;00:02, 855.58it/s]</pre> <pre>\r300000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 1265/3000 [00:01&lt;00:02, 857.27it/s]</pre> <pre>\r300000 agents in f1 nodes:  45%|\u2588\u2588\u2588\u2588\u258c     | 1351/3000 [00:01&lt;00:01, 857.61it/s]</pre> <pre>\r300000 agents in f1 nodes:  48%|\u2588\u2588\u2588\u2588\u258a     | 1438/3000 [00:01&lt;00:01, 858.41it/s]</pre> <pre>\r300000 agents in f1 nodes:  51%|\u2588\u2588\u2588\u2588\u2588     | 1524/3000 [00:01&lt;00:01, 846.36it/s]</pre> <pre>\r300000 agents in f1 nodes:  54%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1611/3000 [00:01&lt;00:01, 850.88it/s]</pre> <pre>\r300000 agents in f1 nodes:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1698/3000 [00:02&lt;00:01, 854.56it/s]</pre> <pre>\r300000 agents in f1 nodes:  60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1785/3000 [00:02&lt;00:01, 856.37it/s]</pre> <pre>\r300000 agents in f1 nodes:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1871/3000 [00:02&lt;00:01, 856.79it/s]</pre> <pre>\r300000 agents in f1 nodes:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1957/3000 [00:02&lt;00:01, 854.61it/s]</pre> <pre>\r300000 agents in f1 nodes:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2043/3000 [00:02&lt;00:01, 855.71it/s]</pre> <pre>\r300000 agents in f1 nodes:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2129/3000 [00:02&lt;00:01, 856.92it/s]</pre> <pre>\r300000 agents in f1 nodes:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2215/3000 [00:02&lt;00:00, 857.05it/s]</pre> <pre>\r300000 agents in f1 nodes:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2301/3000 [00:02&lt;00:00, 857.65it/s]</pre> <pre>\r300000 agents in f1 nodes:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2387/3000 [00:02&lt;00:00, 858.11it/s]</pre> <pre>\r300000 agents in f1 nodes:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2473/3000 [00:02&lt;00:00, 858.45it/s]</pre> <pre>\r300000 agents in f1 nodes:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2560/3000 [00:03&lt;00:00, 859.78it/s]</pre> <pre>\r300000 agents in f1 nodes:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2647/3000 [00:03&lt;00:00, 860.63it/s]</pre> <pre>\r300000 agents in f1 nodes:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2734/3000 [00:03&lt;00:00, 859.10it/s]</pre> <pre>\r300000 agents in f1 nodes:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2820/3000 [00:03&lt;00:00, 857.97it/s]</pre> <pre>\r300000 agents in f1 nodes:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2906/3000 [00:03&lt;00:00, 858.27it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2993/3000 [00:03&lt;00:00, 859.28it/s]</pre> <pre>\r300000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:03&lt;00:00, 846.23it/s]</pre> <pre>\n</pre> In\u00a0[5]: Copied! <pre>plt.plot(model.nodes.I, lw=4)\nN = model.nodes.S + model.nodes.I\nplt.plot(N - model.nodes.S.astype(\"int\"), \"--\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"])\nprint(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all()))\n</pre> plt.plot(model.nodes.I, lw=4) N = model.nodes.S + model.nodes.I plt.plot(N - model.nodes.S.astype(\"int\"), \"--\", lw=3) plt.yscale(\"log\") plt.legend([\"Population minus currently infected\", \"Susceptible\", \"Population minus cumulative infections (incidence)\"]) print(\"S = N-I:  \" + str(np.isclose(model.nodes.S, N - model.nodes.I).all())) <pre>S = N-I:  True\n</pre> In\u00a0[6]: Copied! <pre>def SIS_logistic(t, beta, popsize, gamma, t0):\n    x = 1 - gamma / beta\n    return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))\n\n\nt = np.arange(model.params.nticks+1)\n\n\ndef objective(t0):\n    return np.sum(\n        (1 - SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0) / np.squeeze(model.nodes.I)) ** 2\n    )\n\n\nresult = minimize(objective, x0=10)\nt0_opt = result.x[0]\n\nplt.plot(model.nodes.I, lw=4)\nplt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, 0), lw=3)\nplt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0_opt), \"r:\", lw=3)\nplt.yscale(\"log\")\nplt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"])\n</pre> def SIS_logistic(t, beta, popsize, gamma, t0):     x = 1 - gamma / beta     return popsize * x / (1 + (popsize * x - 1) * np.exp(-beta * x * (t - t0)))   t = np.arange(model.params.nticks+1)   def objective(t0):     return np.sum(         (1 - SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0) / np.squeeze(model.nodes.I)) ** 2     )   result = minimize(objective, x0=10) t0_opt = result.x[0]  plt.plot(model.nodes.I, lw=4) plt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, 0), lw=3) plt.plot(SIS_logistic(t, model.params.beta, pop, 1 / model.params.inf_mean, t0_opt), \"r:\", lw=3) plt.yscale(\"log\") plt.legend([\"Model output\", \"Logistic growth with known inputs, t0=0\", f\"Logistic growth with known inputs, best-fit t0 = {t0_opt:.1f}\"]) Out[6]: <pre>&lt;matplotlib.legend.Legend at 0x7fb3f6e81130&gt;</pre> In\u00a0[7]: Copied! <pre># %%capture\n\nNTESTS = 10\nnticks = 730\nt = np.arange(nticks)\nbetarange = [0.05, 0.2]\ngammarange = [1 / 300, 1 / 100]\nseeds = list(range(NTESTS))\npop = 1e5\nbetas = np.random.uniform(betarange[0], betarange[1], NTESTS)\ngammas = np.random.uniform(gammarange[0], gammarange[1], NTESTS)\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 3\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\n\nrows = []\nfor i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})\n\n    model = Model(scenario, parameters)\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n\n    # Sampling this pyramid will return indices in [0, 88] with equal probability.\n    _pyramid = AliasedDistribution(np.full(89, 1_000))\n    # The survival function will return the probability of surviving past each age.\n    _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed}, beta={beta:.3f}, gamma={gamma:.5f}\")\n    cases = model.nodes.I[1:,0]\n    popt, pcov = curve_fit(\n        SIS_logistic,\n        t,\n        cases,\n        p0=[np.mean(betarange), pop, np.mean(gammarange), 1],\n        bounds=([betarange[0] / 2, pop - 1, gammarange[0] / 2, -300], [betarange[1] * 2, pop + 1, gammarange[1] * 2, 300]),\n    )\n\n    rows.append(\n        {\n            \"seed\": seed,\n            \"beta\": beta,\n            \"gamma\": gamma,\n            \"cases\": [np.array(cases)],\n            \"fitted_beta\": popt[0],\n            \"fitted_gamma\": popt[2],\n            \"fitted_t0\": popt[3],\n        }\n    )\n\noutput = pd.DataFrame(rows)\n</pre> # %%capture  NTESTS = 10 nticks = 730 t = np.arange(nticks) betarange = [0.05, 0.2] gammarange = [1 / 300, 1 / 100] seeds = list(range(NTESTS)) pop = 1e5 betas = np.random.uniform(betarange[0], betarange[1], NTESTS) gammas = np.random.uniform(gammarange[0], gammarange[1], NTESTS) scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 3 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected  rows = [] for i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):     parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})      model = Model(scenario, parameters)      infdurdist = dists.exponential(scale=parameters.inf_mean)      # Sampling this pyramid will return indices in [0, 88] with equal probability.     _pyramid = AliasedDistribution(np.full(89, 1_000))     # The survival function will return the probability of surviving past each age.     _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed}, beta={beta:.3f}, gamma={gamma:.5f}\")     cases = model.nodes.I[1:,0]     popt, pcov = curve_fit(         SIS_logistic,         t,         cases,         p0=[np.mean(betarange), pop, np.mean(gammarange), 1],         bounds=([betarange[0] / 2, pop - 1, gammarange[0] / 2, -300], [betarange[1] * 2, pop + 1, gammarange[1] * 2, 300]),     )      rows.append(         {             \"seed\": seed,             \"beta\": beta,             \"gamma\": gamma,             \"cases\": [np.array(cases)],             \"fitted_beta\": popt[0],             \"fitted_gamma\": popt[2],             \"fitted_t0\": popt[3],         }     )  output = pd.DataFrame(rows)  <pre>\rSIS  1 of 10, seed=0, beta=0.060, gamma=0.00715:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.060, gamma=0.00715:   0%|          | 1/730 [00:00&lt;05:51,  2.07it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.060, gamma=0.00715:  25%|\u2588\u2588\u258c       | 185/730 [00:00&lt;00:01, 421.21it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.060, gamma=0.00715:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 481/730 [00:00&lt;00:00, 1044.82it/s]</pre> <pre>\rSIS  1 of 10, seed=0, beta=0.060, gamma=0.00715: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 964.88it/s] </pre> <pre>\n</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.172, gamma=0.00976:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.172, gamma=0.00976:   0%|          | 1/730 [00:00&lt;07:29,  1.62it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.172, gamma=0.00976:  39%|\u2588\u2588\u2588\u2589      | 287/730 [00:00&lt;00:00, 539.33it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.172, gamma=0.00976:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 683/730 [00:00&lt;00:00, 1263.41it/s]</pre> <pre>\rSIS  2 of 10, seed=1, beta=0.172, gamma=0.00976: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 879.68it/s] </pre> <pre>\n</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.149, gamma=0.00766:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.149, gamma=0.00766:   0%|          | 1/730 [00:00&lt;05:54,  2.05it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.149, gamma=0.00766:  40%|\u2588\u2588\u2588\u2588      | 292/730 [00:00&lt;00:00, 661.75it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.149, gamma=0.00766:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 703/730 [00:00&lt;00:00, 1505.47it/s]</pre> <pre>\rSIS  3 of 10, seed=2, beta=0.149, gamma=0.00766: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1050.82it/s]</pre> <pre>\n</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.069, gamma=0.00533:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.069, gamma=0.00533:   0%|          | 1/730 [00:00&lt;05:54,  2.06it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.069, gamma=0.00533:  26%|\u2588\u2588\u258c       | 187/730 [00:00&lt;00:01, 423.84it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.069, gamma=0.00533:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 560/730 [00:00&lt;00:00, 1232.95it/s]</pre> <pre>\rSIS  4 of 10, seed=3, beta=0.069, gamma=0.00533: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 998.61it/s] </pre> <pre>\n</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.113, gamma=0.00337:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.113, gamma=0.00337:   0%|          | 1/730 [00:00&lt;05:52,  2.07it/s]</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.113, gamma=0.00337:  39%|\u2588\u2588\u2588\u2589      | 287/730 [00:00&lt;00:00, 653.99it/s]</pre> <pre>\rSIS  5 of 10, seed=4, beta=0.113, gamma=0.00337: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1076.05it/s]</pre> <pre>\n</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.160, gamma=0.00891:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.160, gamma=0.00891:   0%|          | 1/730 [00:00&lt;05:51,  2.07it/s]</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.160, gamma=0.00891:  39%|\u2588\u2588\u2588\u2589      | 283/730 [00:00&lt;00:00, 646.03it/s]</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.160, gamma=0.00891:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 681/730 [00:00&lt;00:00, 1465.70it/s]</pre> <pre>\rSIS  6 of 10, seed=5, beta=0.160, gamma=0.00891: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1048.62it/s]</pre> <pre>\n</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.086, gamma=0.00672:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.086, gamma=0.00672:   0%|          | 1/730 [00:00&lt;05:53,  2.06it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.086, gamma=0.00672:  27%|\u2588\u2588\u258b       | 200/730 [00:00&lt;00:01, 454.04it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.086, gamma=0.00672:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 584/730 [00:00&lt;00:00, 1284.03it/s]</pre> <pre>\rSIS  7 of 10, seed=6, beta=0.086, gamma=0.00672: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1007.75it/s]</pre> <pre>\n</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.153, gamma=0.00568:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.153, gamma=0.00568:   0%|          | 1/730 [00:00&lt;05:55,  2.05it/s]</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.153, gamma=0.00568:  42%|\u2588\u2588\u2588\u2588\u258f     | 304/730 [00:00&lt;00:00, 688.28it/s]</pre> <pre>\rSIS  8 of 10, seed=7, beta=0.153, gamma=0.00568: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1066.63it/s]</pre> <pre>\n</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00470:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00470:   0%|          | 1/730 [00:00&lt;05:55,  2.05it/s]</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00470:  48%|\u2588\u2588\u2588\u2588\u258a     | 349/730 [00:00&lt;00:00, 790.27it/s]</pre> <pre>\rSIS  9 of 10, seed=8, beta=0.183, gamma=0.00470: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1084.25it/s]</pre> <pre>\n</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.086, gamma=0.00498:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.086, gamma=0.00498:   0%|          | 1/730 [00:00&lt;05:54,  2.05it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.086, gamma=0.00498:  27%|\u2588\u2588\u258b       | 200/730 [00:00&lt;00:01, 453.15it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.086, gamma=0.00498:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 611/730 [00:00&lt;00:00, 1347.97it/s]</pre> <pre>\rSIS 10 of 10, seed=9, beta=0.086, gamma=0.00498: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:00&lt;00:00, 1018.71it/s]</pre> <pre>\n</pre> In\u00a0[8]: Copied! <pre>plt.figure()\nplt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\")\nplt.xlim(betarange[0], betarange[1])\nplt.ylim(betarange[0], betarange[1])\nplt.figure()\nplt.plot(output[\"beta\"], 1 - output[\"beta\"] / output[\"fitted_beta\"], \"o\")\nplt.xlim(betarange[0], betarange[1])\nplt.ylim(-0.25, 0.25)\nplt.figure()\nplt.plot(output[\"gamma\"], output[\"fitted_gamma\"], \"o\")\nplt.xlim(gammarange[0], gammarange[1])\nplt.ylim(gammarange[0], gammarange[1])\nplt.figure()\nplt.plot(output[\"gamma\"], 1 - output[\"gamma\"] / output[\"fitted_gamma\"], \"o\")\nplt.xlim(gammarange[0], gammarange[1])\nplt.ylim(-0.25, 0.25)\n</pre> plt.figure() plt.plot(output[\"beta\"], output[\"fitted_beta\"], \"o\") plt.xlim(betarange[0], betarange[1]) plt.ylim(betarange[0], betarange[1]) plt.figure() plt.plot(output[\"beta\"], 1 - output[\"beta\"] / output[\"fitted_beta\"], \"o\") plt.xlim(betarange[0], betarange[1]) plt.ylim(-0.25, 0.25) plt.figure() plt.plot(output[\"gamma\"], output[\"fitted_gamma\"], \"o\") plt.xlim(gammarange[0], gammarange[1]) plt.ylim(gammarange[0], gammarange[1]) plt.figure() plt.plot(output[\"gamma\"], 1 - output[\"gamma\"] / output[\"fitted_gamma\"], \"o\") plt.xlim(gammarange[0], gammarange[1]) plt.ylim(-0.25, 0.25) Out[8]: <pre>(-0.25, 0.25)</pre> In\u00a0[9]: Copied! <pre>print(\n    \"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10))\n)\nprint(\n    \"All fitted gamma are within 20% of known gamma: \"\n    + str(np.all(np.abs((output[\"gamma\"] - output[\"fitted_gamma\"]) / output[\"gamma\"]) &lt; 0.20))\n)\n</pre> print(     \"All fitted beta are within 10% of known beta: \" + str(np.all(np.abs((output[\"beta\"] - output[\"fitted_beta\"]) / output[\"beta\"]) &lt; 0.10)) ) print(     \"All fitted gamma are within 20% of known gamma: \"     + str(np.all(np.abs((output[\"gamma\"] - output[\"fitted_gamma\"]) / output[\"gamma\"]) &lt; 0.20)) ) <pre>All fitted beta are within 10% of known beta: True\nAll fitted gamma are within 20% of known gamma: True\n</pre> In\u00a0[10]: Copied! <pre>output\n</pre> output Out[10]: seed beta gamma cases fitted_beta fitted_gamma fitted_t0 0 0 0.059927 0.007150 [[3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,... 0.058671 0.006824 -23.338027 1 1 0.172387 0.009755 [[3, 3, 3, 3, 4, 5, 5, 5, 6, 7, 8, 9, 10, 10, ... 0.163681 0.008496 1.781035 2 2 0.149044 0.007657 [[5, 6, 7, 7, 7, 8, 11, 12, 14, 18, 21, 25, 28... 0.142921 0.006833 -5.206978 3 3 0.068513 0.005332 [[3, 3, 3, 3, 4, 5, 5, 5, 5, 5, 5, 6, 6, 7, 7,... 0.067181 0.005063 -14.912965 4 4 0.112953 0.003375 [[3, 4, 5, 5, 5, 7, 8, 11, 13, 13, 15, 16, 20,... 0.109739 0.003090 -12.984211 5 5 0.159548 0.008914 [[4, 3, 4, 5, 7, 7, 8, 9, 10, 11, 11, 12, 13, ... 0.153890 0.007938 1.206187 6 6 0.085736 0.006716 [[3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 8, 9, 9, 9, 10... 0.083544 0.006279 -13.106274 7 7 0.152512 0.005685 [[3, 3, 3, 4, 5, 7, 8, 9, 10, 10, 13, 14, 16, ... 0.146490 0.005068 -4.408712 8 8 0.183397 0.004699 [[4, 6, 6, 7, 9, 12, 16, 20, 26, 28, 34, 37, 4... 0.175870 0.004103 -8.082767 9 9 0.086470 0.004979 [[4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 5, 5, 5,... 0.084806 0.004702 6.319673 In\u00a0[11]: Copied! <pre># %%capture\n\ngammas = [1 / infmean for infmean in [1, 1.5, 2, 2.5, 3, 6, 12, 18, 30, 45, 60, 90, 120, 180, 240, 300]]\nbetas = [3 * gamma for gamma in gammas]\n\nNTESTS = len(gammas)\nnticks = 3000\nseeds = list(range(NTESTS))\npop = 1e5\nfinal_expected = np.array([])\nfinal_observed = np.array([])\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0)\ninitial_infected = 20\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\n\nfor i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):\n    parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})\n\n    model = Model(scenario, parameters)\n\n    infdurdist = dists.exponential(scale=parameters.inf_mean)\n\n    # Sampling this pyramid will return indices in [0, 88] with equal probability.\n    _pyramid = AliasedDistribution(np.full(89, 1_000))\n    # The survival function will return the probability of surviving past each age.\n    _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\n\n    model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]\n\n    model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed:2}, beta={beta:.3f}, gamma={gamma:.5f}\")\n    final_observed = np.append(final_observed, model.nodes.I[-1,0])\n    final_expected = np.append(final_expected, pop * (1 - gamma / beta))\n</pre> # %%capture  gammas = [1 / infmean for infmean in [1, 1.5, 2, 2.5, 3, 6, 12, 18, 30, 45, 60, 90, 120, 180, 240, 300]] betas = [3 * gamma for gamma in gammas]  NTESTS = len(gammas) nticks = 3000 seeds = list(range(NTESTS)) pop = 1e5 final_expected = np.array([]) final_observed = np.array([]) scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=0, origin_y=0) initial_infected = 20 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected  for i, (seed, beta, gamma) in enumerate(zip(seeds, betas, gammas)):     parameters = PropertySet({\"seed\": seed, \"nticks\": nticks, \"verbose\": True, \"beta\": beta, \"inf_mean\": 1 / gamma})      model = Model(scenario, parameters)      infdurdist = dists.exponential(scale=parameters.inf_mean)      # Sampling this pyramid will return indices in [0, 88] with equal probability.     _pyramid = AliasedDistribution(np.full(89, 1_000))     # The survival function will return the probability of surviving past each age.     _survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())      model.components = [SIS.Susceptible(model), SIS.Infectious(model, infdurdist), SIS.Transmission(model, infdurdist)]      model.run(label=f\"SIS {i+1:2} of {NTESTS}, seed={seed:2}, beta={beta:.3f}, gamma={gamma:.5f}\")     final_observed = np.append(final_observed, model.nodes.I[-1,0])     final_expected = np.append(final_expected, pop * (1 - gamma / beta)) <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   0%|          | 1/3000 [00:00&lt;24:24,  2.05it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   2%|\u258f         | 49/3000 [00:00&lt;00:26, 110.01it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   3%|\u258e         | 94/3000 [00:00&lt;00:15, 192.32it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   5%|\u258d         | 139/3000 [00:00&lt;00:11, 257.71it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   6%|\u258c         | 184/3000 [00:00&lt;00:09, 308.51it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   8%|\u258a         | 229/3000 [00:00&lt;00:07, 346.52it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:   9%|\u2589         | 274/3000 [00:01&lt;00:07, 374.72it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  11%|\u2588         | 319/3000 [00:01&lt;00:06, 395.34it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  12%|\u2588\u258f        | 364/3000 [00:01&lt;00:06, 410.75it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  14%|\u2588\u258e        | 409/3000 [00:01&lt;00:06, 420.31it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  15%|\u2588\u258c        | 454/3000 [00:01&lt;00:05, 427.78it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  17%|\u2588\u258b        | 499/3000 [00:01&lt;00:05, 433.21it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  18%|\u2588\u258a        | 544/3000 [00:01&lt;00:05, 437.14it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  20%|\u2588\u2589        | 589/3000 [00:01&lt;00:05, 440.60it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  21%|\u2588\u2588        | 634/3000 [00:01&lt;00:05, 441.44it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  23%|\u2588\u2588\u258e       | 679/3000 [00:02&lt;00:05, 442.98it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  24%|\u2588\u2588\u258d       | 724/3000 [00:02&lt;00:05, 443.36it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  26%|\u2588\u2588\u258c       | 769/3000 [00:02&lt;00:05, 444.47it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  27%|\u2588\u2588\u258b       | 814/3000 [00:02&lt;00:04, 444.93it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  29%|\u2588\u2588\u258a       | 859/3000 [00:02&lt;00:04, 445.96it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  30%|\u2588\u2588\u2588       | 904/3000 [00:02&lt;00:04, 445.21it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  32%|\u2588\u2588\u2588\u258f      | 949/3000 [00:02&lt;00:04, 444.80it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  33%|\u2588\u2588\u2588\u258e      | 994/3000 [00:02&lt;00:04, 441.11it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  35%|\u2588\u2588\u2588\u258d      | 1039/3000 [00:02&lt;00:04, 441.70it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  36%|\u2588\u2588\u2588\u258c      | 1084/3000 [00:02&lt;00:04, 441.36it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  38%|\u2588\u2588\u2588\u258a      | 1129/3000 [00:03&lt;00:04, 443.03it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  39%|\u2588\u2588\u2588\u2589      | 1174/3000 [00:03&lt;00:04, 442.85it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  41%|\u2588\u2588\u2588\u2588      | 1219/3000 [00:03&lt;00:04, 443.20it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  42%|\u2588\u2588\u2588\u2588\u258f     | 1264/3000 [00:03&lt;00:03, 438.42it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  44%|\u2588\u2588\u2588\u2588\u258e     | 1309/3000 [00:03&lt;00:03, 439.73it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  45%|\u2588\u2588\u2588\u2588\u258c     | 1354/3000 [00:03&lt;00:03, 441.77it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  47%|\u2588\u2588\u2588\u2588\u258b     | 1399/3000 [00:03&lt;00:03, 442.91it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  48%|\u2588\u2588\u2588\u2588\u258a     | 1444/3000 [00:03&lt;00:03, 443.84it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  50%|\u2588\u2588\u2588\u2588\u2589     | 1489/3000 [00:03&lt;00:03, 444.59it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  51%|\u2588\u2588\u2588\u2588\u2588     | 1534/3000 [00:03&lt;00:03, 444.28it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1579/3000 [00:04&lt;00:03, 444.92it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1624/3000 [00:04&lt;00:03, 445.03it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1669/3000 [00:04&lt;00:02, 445.19it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1714/3000 [00:04&lt;00:02, 444.69it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  59%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1759/3000 [00:04&lt;00:02, 445.01it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1804/3000 [00:04&lt;00:02, 445.27it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1849/3000 [00:04&lt;00:02, 445.88it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1894/3000 [00:04&lt;00:02, 445.50it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1939/3000 [00:04&lt;00:02, 441.37it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1984/3000 [00:04&lt;00:02, 441.98it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2029/3000 [00:05&lt;00:02, 442.30it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2074/3000 [00:05&lt;00:02, 441.17it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2119/3000 [00:05&lt;00:01, 440.91it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2164/3000 [00:05&lt;00:01, 440.66it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2209/3000 [00:05&lt;00:01, 441.17it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2254/3000 [00:05&lt;00:01, 440.89it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2299/3000 [00:05&lt;00:01, 440.67it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2344/3000 [00:05&lt;00:01, 439.38it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2388/3000 [00:05&lt;00:01, 439.50it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2432/3000 [00:05&lt;00:01, 439.56it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2476/3000 [00:06&lt;00:01, 439.41it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2520/3000 [00:06&lt;00:01, 439.54it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2564/3000 [00:06&lt;00:00, 439.49it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2608/3000 [00:06&lt;00:00, 439.52it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2653/3000 [00:06&lt;00:00, 439.81it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2697/3000 [00:06&lt;00:00, 438.68it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2742/3000 [00:06&lt;00:00, 439.29it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 2786/3000 [00:06&lt;00:00, 439.34it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2831/3000 [00:06&lt;00:00, 440.28it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2876/3000 [00:06&lt;00:00, 440.74it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2921/3000 [00:07&lt;00:00, 440.63it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2966/3000 [00:07&lt;00:00, 440.90it/s]</pre> <pre>\rSIS  1 of 16, seed= 0, beta=3.000, gamma=1.00000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:07&lt;00:00, 413.49it/s]</pre> <pre>\n</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   0%|          | 1/3000 [00:00&lt;24:25,  2.05it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   2%|\u258f         | 62/3000 [00:00&lt;00:21, 139.56it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   4%|\u258d         | 120/3000 [00:00&lt;00:11, 246.24it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   6%|\u258c         | 178/3000 [00:00&lt;00:08, 330.91it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:   8%|\u258a         | 236/3000 [00:00&lt;00:06, 396.03it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  10%|\u2589         | 293/3000 [00:00&lt;00:06, 444.06it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  12%|\u2588\u258f        | 351/3000 [00:01&lt;00:05, 480.39it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  14%|\u2588\u258e        | 408/3000 [00:01&lt;00:05, 506.08it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  16%|\u2588\u258c        | 466/3000 [00:01&lt;00:04, 525.98it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  17%|\u2588\u258b        | 524/3000 [00:01&lt;00:04, 540.10it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  19%|\u2588\u2589        | 581/3000 [00:01&lt;00:04, 548.80it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  21%|\u2588\u2588\u258f       | 638/3000 [00:01&lt;00:04, 554.82it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  23%|\u2588\u2588\u258e       | 696/3000 [00:01&lt;00:04, 559.77it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  25%|\u2588\u2588\u258c       | 753/3000 [00:01&lt;00:03, 562.75it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  27%|\u2588\u2588\u258b       | 811/3000 [00:01&lt;00:03, 566.15it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  29%|\u2588\u2588\u2589       | 869/3000 [00:02&lt;00:03, 566.61it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  31%|\u2588\u2588\u2588       | 926/3000 [00:02&lt;00:03, 567.56it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  33%|\u2588\u2588\u2588\u258e      | 984/3000 [00:02&lt;00:03, 569.13it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  35%|\u2588\u2588\u2588\u258d      | 1042/3000 [00:02&lt;00:03, 569.68it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  37%|\u2588\u2588\u2588\u258b      | 1100/3000 [00:02&lt;00:03, 569.96it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  39%|\u2588\u2588\u2588\u258a      | 1158/3000 [00:02&lt;00:03, 570.13it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  41%|\u2588\u2588\u2588\u2588      | 1216/3000 [00:02&lt;00:03, 570.62it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  42%|\u2588\u2588\u2588\u2588\u258f     | 1274/3000 [00:02&lt;00:03, 571.26it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  44%|\u2588\u2588\u2588\u2588\u258d     | 1332/3000 [00:02&lt;00:02, 571.34it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  46%|\u2588\u2588\u2588\u2588\u258b     | 1390/3000 [00:02&lt;00:03, 534.96it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  48%|\u2588\u2588\u2588\u2588\u258a     | 1447/3000 [00:03&lt;00:02, 544.63it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  50%|\u2588\u2588\u2588\u2588\u2588     | 1504/3000 [00:03&lt;00:02, 551.82it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1561/3000 [00:03&lt;00:02, 557.02it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1619/3000 [00:03&lt;00:02, 561.46it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1677/3000 [00:03&lt;00:02, 564.16it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1734/3000 [00:03&lt;00:02, 565.29it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1792/3000 [00:03&lt;00:02, 566.75it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1850/3000 [00:03&lt;00:02, 568.29it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1908/3000 [00:03&lt;00:01, 569.10it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1965/3000 [00:03&lt;00:01, 568.32it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2022/3000 [00:04&lt;00:01, 568.39it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2079/3000 [00:04&lt;00:01, 567.43it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2137/3000 [00:04&lt;00:01, 568.53it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2194/3000 [00:04&lt;00:01, 568.37it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2251/3000 [00:04&lt;00:01, 567.44it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2308/3000 [00:04&lt;00:01, 568.09it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2365/3000 [00:04&lt;00:01, 567.61it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2422/3000 [00:04&lt;00:01, 568.01it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2479/3000 [00:04&lt;00:00, 568.26it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2536/3000 [00:04&lt;00:00, 568.18it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2593/3000 [00:05&lt;00:00, 566.98it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2650/3000 [00:05&lt;00:00, 567.09it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2707/3000 [00:05&lt;00:00, 567.94it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2764/3000 [00:05&lt;00:00, 568.17it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2821/3000 [00:05&lt;00:00, 561.87it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2878/3000 [00:05&lt;00:00, 561.08it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2935/3000 [00:05&lt;00:00, 563.50it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2993/3000 [00:05&lt;00:00, 565.89it/s]</pre> <pre>\rSIS  2 of 16, seed= 1, beta=2.000, gamma=0.66667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:05&lt;00:00, 519.52it/s]</pre> <pre>\n</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   0%|          | 1/3000 [00:00&lt;24:45,  2.02it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   3%|\u258e         | 82/3000 [00:00&lt;00:15, 182.69it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   5%|\u258c         | 158/3000 [00:00&lt;00:08, 321.97it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:   8%|\u258a         | 234/3000 [00:00&lt;00:06, 434.01it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  10%|\u2588         | 310/3000 [00:00&lt;00:05, 520.76it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  13%|\u2588\u258e        | 386/3000 [00:00&lt;00:04, 586.22it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  15%|\u2588\u258c        | 462/3000 [00:01&lt;00:03, 635.26it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  18%|\u2588\u258a        | 538/3000 [00:01&lt;00:03, 670.50it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  20%|\u2588\u2588        | 614/3000 [00:01&lt;00:03, 696.49it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  23%|\u2588\u2588\u258e       | 690/3000 [00:01&lt;00:03, 713.93it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  26%|\u2588\u2588\u258c       | 767/3000 [00:01&lt;00:03, 727.73it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  28%|\u2588\u2588\u258a       | 844/3000 [00:01&lt;00:02, 737.59it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  31%|\u2588\u2588\u2588       | 920/3000 [00:01&lt;00:02, 743.65it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  33%|\u2588\u2588\u2588\u258e      | 997/3000 [00:01&lt;00:02, 748.72it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  36%|\u2588\u2588\u2588\u258c      | 1073/3000 [00:01&lt;00:02, 751.33it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  38%|\u2588\u2588\u2588\u258a      | 1149/3000 [00:02&lt;00:02, 753.65it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  41%|\u2588\u2588\u2588\u2588      | 1226/3000 [00:02&lt;00:02, 755.66it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  43%|\u2588\u2588\u2588\u2588\u258e     | 1302/3000 [00:02&lt;00:02, 755.63it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  46%|\u2588\u2588\u2588\u2588\u258c     | 1378/3000 [00:02&lt;00:02, 756.59it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  48%|\u2588\u2588\u2588\u2588\u258a     | 1454/3000 [00:02&lt;00:02, 755.38it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  51%|\u2588\u2588\u2588\u2588\u2588     | 1531/3000 [00:02&lt;00:01, 756.95it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  54%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1607/3000 [00:02&lt;00:01, 757.45it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1683/3000 [00:02&lt;00:01, 757.68it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  59%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1759/3000 [00:02&lt;00:01, 753.70it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1835/3000 [00:02&lt;00:01, 754.47it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1911/3000 [00:03&lt;00:01, 755.97it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1987/3000 [00:03&lt;00:01, 756.93it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2064/3000 [00:03&lt;00:01, 758.29it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2140/3000 [00:03&lt;00:01, 758.18it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2216/3000 [00:03&lt;00:01, 756.50it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2292/3000 [00:03&lt;00:00, 757.14it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2368/3000 [00:03&lt;00:00, 757.47it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2444/3000 [00:03&lt;00:00, 758.13it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2521/3000 [00:03&lt;00:00, 758.89it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2597/3000 [00:03&lt;00:00, 758.14it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2673/3000 [00:04&lt;00:00, 758.53it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2749/3000 [00:04&lt;00:00, 758.34it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2825/3000 [00:04&lt;00:00, 758.02it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2901/3000 [00:04&lt;00:00, 758.18it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2977/3000 [00:04&lt;00:00, 757.45it/s]</pre> <pre>\rSIS  3 of 16, seed= 2, beta=1.500, gamma=0.50000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:04&lt;00:00, 674.44it/s]</pre> <pre>\n</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   0%|          | 1/3000 [00:00&lt;24:33,  2.03it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   3%|\u258e         | 94/3000 [00:00&lt;00:13, 210.57it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   6%|\u258c         | 181/3000 [00:00&lt;00:07, 369.88it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:   9%|\u2589         | 265/3000 [00:00&lt;00:05, 489.94it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  12%|\u2588\u258f        | 352/3000 [00:00&lt;00:04, 590.27it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  15%|\u2588\u258d        | 439/3000 [00:00&lt;00:03, 665.93it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  18%|\u2588\u258a        | 525/3000 [00:01&lt;00:03, 720.26it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  20%|\u2588\u2588        | 608/3000 [00:01&lt;00:03, 748.45it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  23%|\u2588\u2588\u258e       | 694/3000 [00:01&lt;00:02, 780.00it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  26%|\u2588\u2588\u258c       | 781/3000 [00:01&lt;00:02, 803.85it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  29%|\u2588\u2588\u2589       | 867/3000 [00:01&lt;00:02, 820.03it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  32%|\u2588\u2588\u2588\u258f      | 953/3000 [00:01&lt;00:02, 831.73it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  35%|\u2588\u2588\u2588\u258d      | 1040/3000 [00:01&lt;00:02, 840.97it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  38%|\u2588\u2588\u2588\u258a      | 1127/3000 [00:01&lt;00:02, 846.83it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  40%|\u2588\u2588\u2588\u2588      | 1214/3000 [00:01&lt;00:02, 851.76it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  43%|\u2588\u2588\u2588\u2588\u258e     | 1300/3000 [00:02&lt;00:01, 854.14it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  46%|\u2588\u2588\u2588\u2588\u258c     | 1386/3000 [00:02&lt;00:01, 855.88it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  49%|\u2588\u2588\u2588\u2588\u2589     | 1472/3000 [00:02&lt;00:01, 855.63it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1558/3000 [00:02&lt;00:01, 855.74it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1645/3000 [00:02&lt;00:01, 857.20it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1732/3000 [00:02&lt;00:01, 858.27it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1818/3000 [00:02&lt;00:01, 857.42it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1905/3000 [00:02&lt;00:01, 858.43it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 1992/3000 [00:02&lt;00:01, 859.19it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2078/3000 [00:02&lt;00:01, 859.03it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2165/3000 [00:03&lt;00:00, 859.81it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2251/3000 [00:03&lt;00:00, 859.62it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2337/3000 [00:03&lt;00:00, 858.27it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2423/3000 [00:03&lt;00:00, 858.08it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2509/3000 [00:03&lt;00:00, 858.22it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2596/3000 [00:03&lt;00:00, 859.72it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2682/3000 [00:03&lt;00:00, 857.72it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 2769/3000 [00:03&lt;00:00, 858.92it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2855/3000 [00:03&lt;00:00, 848.05it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2940/3000 [00:03&lt;00:00, 846.68it/s]</pre> <pre>\rSIS  4 of 16, seed= 3, beta=1.200, gamma=0.40000: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:03&lt;00:00, 752.19it/s]</pre> <pre>\n</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   0%|          | 1/3000 [00:00&lt;32:44,  1.53it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   3%|\u258e         | 104/3000 [00:00&lt;00:15, 185.55it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:   7%|\u258b         | 201/3000 [00:00&lt;00:08, 344.93it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  10%|\u2589         | 299/3000 [00:00&lt;00:05, 487.33it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  13%|\u2588\u258e        | 397/3000 [00:01&lt;00:04, 606.33it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  16%|\u2588\u258b        | 495/3000 [00:01&lt;00:03, 700.90it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  20%|\u2588\u2589        | 593/3000 [00:01&lt;00:03, 775.53it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  23%|\u2588\u2588\u258e       | 691/3000 [00:01&lt;00:02, 830.22it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  26%|\u2588\u2588\u258b       | 788/3000 [00:01&lt;00:02, 869.49it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  30%|\u2588\u2588\u2589       | 886/3000 [00:01&lt;00:02, 899.26it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  33%|\u2588\u2588\u2588\u258e      | 984/3000 [00:01&lt;00:02, 921.19it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  36%|\u2588\u2588\u2588\u258c      | 1082/3000 [00:01&lt;00:02, 937.89it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  39%|\u2588\u2588\u2588\u2589      | 1179/3000 [00:01&lt;00:01, 947.30it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  43%|\u2588\u2588\u2588\u2588\u258e     | 1276/3000 [00:01&lt;00:01, 944.22it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  46%|\u2588\u2588\u2588\u2588\u258c     | 1374/3000 [00:02&lt;00:01, 953.54it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  49%|\u2588\u2588\u2588\u2588\u2589     | 1472/3000 [00:02&lt;00:01, 959.05it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1569/3000 [00:02&lt;00:01, 952.41it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1666/3000 [00:02&lt;00:01, 957.00it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1764/3000 [00:02&lt;00:01, 961.76it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1861/3000 [00:02&lt;00:01, 964.03it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1958/3000 [00:02&lt;00:01, 947.64it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2054/3000 [00:02&lt;00:00, 950.23it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2152/3000 [00:02&lt;00:00, 956.49it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2249/3000 [00:02&lt;00:00, 959.14it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 2347/3000 [00:03&lt;00:00, 963.15it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2445/3000 [00:03&lt;00:00, 965.64it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 2543/3000 [00:03&lt;00:00, 967.78it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2640/3000 [00:03&lt;00:00, 933.06it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2737/3000 [00:03&lt;00:00, 943.10it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2835/3000 [00:03&lt;00:00, 951.81it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2932/3000 [00:03&lt;00:00, 956.00it/s]</pre> <pre>\rSIS  5 of 16, seed= 4, beta=1.000, gamma=0.33333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:03&lt;00:00, 796.77it/s]</pre> <pre>\n</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:   0%|          | 1/3000 [00:00&lt;24:27,  2.04it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:   5%|\u258d         | 147/3000 [00:00&lt;00:08, 330.97it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  10%|\u2589         | 289/3000 [00:00&lt;00:04, 595.97it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  14%|\u2588\u258d        | 430/3000 [00:00&lt;00:03, 805.90it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  19%|\u2588\u2589        | 572/3000 [00:00&lt;00:02, 970.42it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  24%|\u2588\u2588\u258d       | 715/3000 [00:00&lt;00:02, 1096.01it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  29%|\u2588\u2588\u258a       | 858/3000 [00:01&lt;00:01, 1188.42it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  33%|\u2588\u2588\u2588\u258e      | 1000/3000 [00:01&lt;00:01, 1254.75it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  38%|\u2588\u2588\u2588\u258a      | 1142/3000 [00:01&lt;00:01, 1302.03it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  43%|\u2588\u2588\u2588\u2588\u258e     | 1284/3000 [00:01&lt;00:01, 1335.83it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  48%|\u2588\u2588\u2588\u2588\u258a     | 1426/3000 [00:01&lt;00:01, 1360.63it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1568/3000 [00:01&lt;00:01, 1378.00it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1710/3000 [00:01&lt;00:00, 1388.80it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1852/3000 [00:01&lt;00:00, 1392.85it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 1993/3000 [00:01&lt;00:00, 1397.50it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2136/3000 [00:01&lt;00:00, 1404.54it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2278/3000 [00:02&lt;00:00, 1407.40it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2420/3000 [00:02&lt;00:00, 1408.90it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 2563/3000 [00:02&lt;00:00, 1412.26it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2705/3000 [00:02&lt;00:00, 1413.98it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2847/3000 [00:02&lt;00:00, 1415.48it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 2989/3000 [00:02&lt;00:00, 1414.40it/s]</pre> <pre>\rSIS  6 of 16, seed= 5, beta=0.500, gamma=0.16667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1150.81it/s]</pre> <pre>\n</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:   0%|          | 1/3000 [00:00&lt;24:45,  2.02it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:   6%|\u258c         | 175/3000 [00:00&lt;00:07, 390.80it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  12%|\u2588\u258f        | 353/3000 [00:00&lt;00:03, 726.46it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  18%|\u2588\u258a        | 530/3000 [00:00&lt;00:02, 993.84it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  24%|\u2588\u2588\u258e       | 708/3000 [00:00&lt;00:01, 1203.33it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  30%|\u2588\u2588\u2589       | 886/3000 [00:00&lt;00:01, 1361.69it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  35%|\u2588\u2588\u2588\u258c      | 1063/3000 [00:01&lt;00:01, 1477.17it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  41%|\u2588\u2588\u2588\u2588      | 1235/3000 [00:01&lt;00:01, 1544.97it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  47%|\u2588\u2588\u2588\u2588\u258b     | 1409/3000 [00:01&lt;00:00, 1599.48it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1585/3000 [00:01&lt;00:00, 1645.37it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  59%|\u2588\u2588\u2588\u2588\u2588\u258a    | 1762/3000 [00:01&lt;00:00, 1682.09it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1939/3000 [00:01&lt;00:00, 1707.76it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 2117/3000 [00:01&lt;00:00, 1727.44it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2294/3000 [00:01&lt;00:00, 1738.59it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2471/3000 [00:01&lt;00:00, 1747.86it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2649/3000 [00:01&lt;00:00, 1754.91it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2826/3000 [00:02&lt;00:00, 1758.17it/s]</pre> <pre>\rSIS  7 of 16, seed= 6, beta=0.250, gamma=0.08333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1364.78it/s]</pre> <pre>\n</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:   0%|          | 1/3000 [00:00&lt;24:32,  2.04it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:   6%|\u258c         | 183/3000 [00:00&lt;00:06, 411.63it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  12%|\u2588\u258f        | 373/3000 [00:00&lt;00:03, 773.56it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  19%|\u2588\u2589        | 564/3000 [00:00&lt;00:02, 1065.75it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  25%|\u2588\u2588\u258c       | 755/3000 [00:00&lt;00:01, 1292.26it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  32%|\u2588\u2588\u2588\u258f      | 946/3000 [00:00&lt;00:01, 1462.63it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  38%|\u2588\u2588\u2588\u258a      | 1137/3000 [00:01&lt;00:01, 1588.08it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  44%|\u2588\u2588\u2588\u2588\u258d     | 1328/3000 [00:01&lt;00:00, 1679.39it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  51%|\u2588\u2588\u2588\u2588\u2588     | 1519/3000 [00:01&lt;00:00, 1744.78it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1709/3000 [00:01&lt;00:00, 1790.28it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 1900/3000 [00:01&lt;00:00, 1823.40it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2090/3000 [00:01&lt;00:00, 1843.86it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2279/3000 [00:01&lt;00:00, 1850.06it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2469/3000 [00:01&lt;00:00, 1864.44it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2660/3000 [00:01&lt;00:00, 1876.82it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2851/3000 [00:01&lt;00:00, 1886.17it/s]</pre> <pre>\rSIS  8 of 16, seed= 7, beta=0.167, gamma=0.05556: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1446.06it/s]</pre> <pre>\n</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:   0%|          | 1/3000 [00:00&lt;24:50,  2.01it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:   6%|\u258c         | 185/3000 [00:00&lt;00:06, 411.84it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  13%|\u2588\u258e        | 388/3000 [00:00&lt;00:03, 801.89it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  20%|\u2588\u2589        | 591/3000 [00:00&lt;00:02, 1116.01it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  26%|\u2588\u2588\u258b       | 794/3000 [00:00&lt;00:01, 1360.02it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  33%|\u2588\u2588\u2588\u258e      | 997/3000 [00:00&lt;00:01, 1545.08it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  40%|\u2588\u2588\u2588\u2588      | 1201/3000 [00:01&lt;00:01, 1684.05it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  47%|\u2588\u2588\u2588\u2588\u258b     | 1396/3000 [00:01&lt;00:00, 1759.79it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1598/3000 [00:01&lt;00:00, 1832.94it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1800/3000 [00:01&lt;00:00, 1887.08it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 2003/3000 [00:01&lt;00:00, 1928.49it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2207/3000 [00:01&lt;00:00, 1959.77it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2411/3000 [00:01&lt;00:00, 1981.14it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2614/3000 [00:01&lt;00:00, 1993.69it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2818/3000 [00:01&lt;00:00, 2005.18it/s]</pre> <pre>\rSIS  9 of 16, seed= 8, beta=0.100, gamma=0.03333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1506.44it/s]</pre> <pre>\n</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:   0%|          | 1/3000 [00:00&lt;33:16,  1.50it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:   6%|\u258b         | 189/3000 [00:00&lt;00:08, 333.32it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  13%|\u2588\u258e        | 385/3000 [00:00&lt;00:03, 660.53it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  20%|\u2588\u2589        | 595/3000 [00:00&lt;00:02, 981.83it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  27%|\u2588\u2588\u258b       | 804/3000 [00:01&lt;00:01, 1248.92it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  34%|\u2588\u2588\u2588\u258d      | 1013/3000 [00:01&lt;00:01, 1464.00it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  41%|\u2588\u2588\u2588\u2588      | 1223/3000 [00:01&lt;00:01, 1634.39it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  48%|\u2588\u2588\u2588\u2588\u258a     | 1433/3000 [00:01&lt;00:00, 1761.53it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1643/3000 [00:01&lt;00:00, 1856.26it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1852/3000 [00:01&lt;00:00, 1921.85it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2059/3000 [00:01&lt;00:00, 1963.90it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2267/3000 [00:01&lt;00:00, 1997.79it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2477/3000 [00:01&lt;00:00, 2025.78it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2687/3000 [00:01&lt;00:00, 2047.74it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2896/3000 [00:02&lt;00:00, 2057.85it/s]</pre> <pre>\rSIS 10 of 16, seed= 9, beta=0.067, gamma=0.02222: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1415.44it/s]</pre> <pre>\n</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:   0%|          | 1/3000 [00:00&lt;24:58,  2.00it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:   6%|\u258b         | 192/3000 [00:00&lt;00:06, 426.08it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  12%|\u2588\u258e        | 375/3000 [00:00&lt;00:03, 764.14it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  20%|\u2588\u2589        | 587/3000 [00:00&lt;00:02, 1110.95it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  27%|\u2588\u2588\u258b       | 801/3000 [00:00&lt;00:01, 1385.62it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  34%|\u2588\u2588\u2588\u258d      | 1016/3000 [00:01&lt;00:01, 1595.22it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  41%|\u2588\u2588\u2588\u2588      | 1228/3000 [00:01&lt;00:01, 1743.25it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  48%|\u2588\u2588\u2588\u2588\u258a     | 1442/3000 [00:01&lt;00:00, 1856.16it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 1655/3000 [00:01&lt;00:00, 1935.86it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1869/3000 [00:01&lt;00:00, 1994.38it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2084/3000 [00:01&lt;00:00, 2038.17it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 2298/3000 [00:01&lt;00:00, 2066.82it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2510/3000 [00:01&lt;00:00, 2077.57it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2723/3000 [00:01&lt;00:00, 2092.57it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2936/3000 [00:01&lt;00:00, 2102.19it/s]</pre> <pre>\rSIS 11 of 16, seed=10, beta=0.050, gamma=0.01667: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1551.31it/s]</pre> <pre>\n</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:   0%|          | 1/3000 [00:00&lt;24:54,  2.01it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:   6%|\u258b         | 193/3000 [00:00&lt;00:06, 429.32it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  13%|\u2588\u258e        | 381/3000 [00:00&lt;00:03, 779.54it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  19%|\u2588\u2589        | 566/3000 [00:00&lt;00:02, 1053.96it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  26%|\u2588\u2588\u258c       | 778/3000 [00:00&lt;00:01, 1339.35it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  33%|\u2588\u2588\u2588\u258e      | 994/3000 [00:00&lt;00:01, 1565.24it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  40%|\u2588\u2588\u2588\u2588      | 1210/3000 [00:01&lt;00:01, 1732.88it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  48%|\u2588\u2588\u2588\u2588\u258a     | 1425/3000 [00:01&lt;00:00, 1852.59it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 1640/3000 [00:01&lt;00:00, 1939.26it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 1855/3000 [00:01&lt;00:00, 2000.29it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 2070/3000 [00:01&lt;00:00, 2044.47it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2285/3000 [00:01&lt;00:00, 2075.43it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 2500/3000 [00:01&lt;00:00, 2097.33it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 2716/3000 [00:01&lt;00:00, 2113.30it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 2930/3000 [00:01&lt;00:00, 2120.20it/s]</pre> <pre>\rSIS 12 of 16, seed=11, beta=0.033, gamma=0.01111: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1551.39it/s]</pre> <pre>\n</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:   0%|          | 1/3000 [00:00&lt;24:44,  2.02it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:   6%|\u258b         | 192/3000 [00:00&lt;00:06, 429.15it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  13%|\u2588\u258e        | 380/3000 [00:00&lt;00:03, 780.04it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  19%|\u2588\u258a        | 557/3000 [00:00&lt;00:02, 1032.95it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  25%|\u2588\u2588\u258c       | 755/3000 [00:00&lt;00:01, 1286.04it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  32%|\u2588\u2588\u2588\u258f      | 971/3000 [00:00&lt;00:01, 1526.41it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  39%|\u2588\u2588\u2588\u2589      | 1184/3000 [00:01&lt;00:01, 1684.71it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  46%|\u2588\u2588\u2588\u2588\u258c     | 1378/3000 [00:01&lt;00:00, 1723.65it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1593/3000 [00:01&lt;00:00, 1844.64it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1812/3000 [00:01&lt;00:00, 1942.83it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2030/3000 [00:01&lt;00:00, 2010.49it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 2247/3000 [00:01&lt;00:00, 2055.49it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2465/3000 [00:01&lt;00:00, 2090.47it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2684/3000 [00:01&lt;00:00, 2117.56it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2903/3000 [00:01&lt;00:00, 2136.74it/s]</pre> <pre>\rSIS 13 of 16, seed=12, beta=0.025, gamma=0.00833: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1535.10it/s]</pre> <pre>\n</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:   0%|          | 1/3000 [00:00&lt;24:46,  2.02it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:   6%|\u258b         | 194/3000 [00:00&lt;00:06, 433.18it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  13%|\u2588\u258e        | 388/3000 [00:00&lt;00:03, 797.60it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  19%|\u2588\u2589        | 578/3000 [00:00&lt;00:02, 1079.87it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  25%|\u2588\u2588\u258c       | 764/3000 [00:00&lt;00:01, 1288.17it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  31%|\u2588\u2588\u2588\u258f      | 944/3000 [00:00&lt;00:01, 1429.90it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  38%|\u2588\u2588\u2588\u258a      | 1153/3000 [00:01&lt;00:01, 1615.15it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  46%|\u2588\u2588\u2588\u2588\u258c     | 1372/3000 [00:01&lt;00:00, 1779.49it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 1592/3000 [00:01&lt;00:00, 1901.47it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 1812/3000 [00:01&lt;00:00, 1988.81it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 2031/3000 [00:01&lt;00:00, 2047.80it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 2252/3000 [00:01&lt;00:00, 2094.79it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 2467/3000 [00:01&lt;00:00, 2091.50it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 2686/3000 [00:01&lt;00:00, 2119.09it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 2907/3000 [00:01&lt;00:00, 2143.58it/s]</pre> <pre>\rSIS 14 of 16, seed=13, beta=0.017, gamma=0.00556: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1542.62it/s]</pre> <pre>\n</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:   0%|          | 1/3000 [00:00&lt;33:56,  1.47it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:   6%|\u258b         | 194/3000 [00:00&lt;00:08, 336.53it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  13%|\u2588\u258e        | 388/3000 [00:00&lt;00:03, 655.23it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  19%|\u2588\u2589        | 581/3000 [00:00&lt;00:02, 937.16it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  26%|\u2588\u2588\u258c       | 771/3000 [00:01&lt;00:01, 1167.30it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  32%|\u2588\u2588\u2588\u258f      | 948/3000 [00:01&lt;00:01, 1320.90it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  38%|\u2588\u2588\u2588\u258a      | 1127/3000 [00:01&lt;00:01, 1445.84it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  44%|\u2588\u2588\u2588\u2588\u258d     | 1326/3000 [00:01&lt;00:01, 1595.61it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  51%|\u2588\u2588\u2588\u2588\u2588\u258f    | 1543/3000 [00:01&lt;00:00, 1756.45it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 1765/3000 [00:01&lt;00:00, 1888.38it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 1986/3000 [00:01&lt;00:00, 1979.75it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 2209/3000 [00:01&lt;00:00, 2051.51it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 2430/3000 [00:01&lt;00:00, 2097.60it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 2649/3000 [00:01&lt;00:00, 2123.16it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 2874/3000 [00:02&lt;00:00, 2159.28it/s]</pre> <pre>\rSIS 15 of 16, seed=14, beta=0.013, gamma=0.00417: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:02&lt;00:00, 1402.28it/s]</pre> <pre>\n</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:   0%|          | 0/3000 [00:00&lt;?, ?it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:   0%|          | 1/3000 [00:00&lt;24:51,  2.01it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:   6%|\u258b         | 193/3000 [00:00&lt;00:06, 429.66it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  13%|\u2588\u258e        | 386/3000 [00:00&lt;00:03, 791.92it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  19%|\u2588\u2589        | 580/3000 [00:00&lt;00:02, 1086.32it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  26%|\u2588\u2588\u258c       | 773/3000 [00:00&lt;00:01, 1311.21it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  32%|\u2588\u2588\u2588\u258f      | 964/3000 [00:00&lt;00:01, 1475.26it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  38%|\u2588\u2588\u2588\u258a      | 1151/3000 [00:01&lt;00:01, 1586.22it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  44%|\u2588\u2588\u2588\u2588\u258d     | 1334/3000 [00:01&lt;00:01, 1651.84it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  51%|\u2588\u2588\u2588\u2588\u2588     | 1517/3000 [00:01&lt;00:00, 1698.29it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 1717/3000 [00:01&lt;00:00, 1786.64it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 1934/3000 [00:01&lt;00:00, 1898.02it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 2155/3000 [00:01&lt;00:00, 1990.08it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 2375/3000 [00:01&lt;00:00, 2052.24it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 2598/3000 [00:01&lt;00:00, 2102.79it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 2820/3000 [00:01&lt;00:00, 2134.81it/s]</pre> <pre>\rSIS 16 of 16, seed=15, beta=0.010, gamma=0.00333: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3000/3000 [00:01&lt;00:00, 1512.67it/s]</pre> <pre>\n</pre> In\u00a0[12]: Copied! <pre>plt.plot(gammas, np.abs(1 - final_observed / final_expected), \"o\")\nplt.xlabel(r\"$\\gamma$\")\nplt.ylabel(\"$| 1 - \\\\frac{I(\\\\infty)_{obs}}{I(\\\\infty)_{exp}} |$\")\nplt.title(r\"Error in equilibrium infected fraction increases roughly linearly in $\\gamma \\Delta t$\")\n</pre> plt.plot(gammas, np.abs(1 - final_observed / final_expected), \"o\") plt.xlabel(r\"$\\gamma$\") plt.ylabel(\"$| 1 - \\\\frac{I(\\\\infty)_{obs}}{I(\\\\infty)_{exp}} |$\") plt.title(r\"Error in equilibrium infected fraction increases roughly linearly in $\\gamma \\Delta t$\") Out[12]: <pre>Text(0.5, 1.0, 'Error in equilibrium infected fraction increases roughly linearly in $\\\\gamma \\\\Delta t$')</pre>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#sis-model-with-no-demographics","title":"SIS Model with no demographics\u00b6","text":"<p>Moving on from the SI model to something slighlty more complex, we will add a state transition from infected back to susceptible, with no period of immunity - this is the SIS model.  It turns out that the equations governing this will be analogous to the SI model with demography - rather than births &amp; mortality providing routes to add susceptibles and subtract infectives, this transition from infective -&gt; susceptible will provide essentially the same mechanism.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\gamma I\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I $$</p> <p>As before, subbing $S = N-I$ into the second equation gives us</p> <p>$$ \\dot{I} = \\beta I ( 1-\\frac{\\gamma}{\\beta}-\\frac{I}{N})$$</p> <p>And comparing against the SI model with births, it is clear this equation is of the same form, with solution $$ \\frac{Nx}{1+(\\frac{Nx}{I_0}-1)e^{-\\beta x t}} \\\\ x = (1-\\frac{\\gamma}{\\beta}) $$</p> <p>This notebook tests the implementation and behavior of the model as follows:</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with three components: <code>Susceptibility</code>, <code>Transmission</code>, and <code>Infection_SIS</code> - this component will require a new agent property <code>itimer</code>, and upon expiration of <code>itimer</code> agents will return to the susceptible state.  Finally, we initialize with a single infection and run.  The <code>Susceptibility</code> and <code>Transmission</code> components are previously described.</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test ensures certain basic constraints are being obeyed by the model.  We confirm that at each timestep, $S_t=N_t-I_t$.</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#scientific-test","title":"Scientific test\u00b6","text":"<p>Finally, we come to the scientific test.  As before, we first test on a single instance of the model and show that the expected output is recovered.  Then, we select a few values of $\\beta$ and $\\gamma$, run the model, fit the outputs to the logistic equation, and compare the fitted value of $\\beta$ and $\\gamma$ to the known values; all of the considerations noted in the SI with births model, in terms of how to approach this fit, are echoed again here.  Of particular concern is the approximation of an exponential transition from infected back to susceptible - as we are doing a first-order finite timestep integration here, that approximation will probably produce an error linear in $\\gamma \\Delta t$ between the analytic result and the modeled result.  In fact, in a lot of real disease models, we have compartment dwell times in the exposed and infective states that are only a handful of $\\Delta t$ long, but when doing real epi modeling and calibrating model parameters to uncertain data, this is generally not likely to be a dominant source of bias, uncertainty, etc.  But when comparing specifically against an analytic result, it can become significant.</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the relationships between susceptible, infected, and total population hold.</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#this-calculation-isnt-informative-we-should-look-at-s-i-and-incidence-to-check-consistency","title":"This calculation isn't informative. We should look at S, I, and incidence to check consistency.\u00b6","text":""},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#single-simulation-check","title":"Single-simulation check\u00b6","text":"<p>As before, starting with a single infection induces some stochasticity in terms of when the outbreak really starts to take off, and so we fit the expected behavior with a free offset parameter below.</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#scientific-testing","title":"Scientific testing\u00b6","text":"<p>Finally, we run the model for a range of $\\beta$ &amp; $\\gamma$  parameters, we freely fit the model output to the logistic equation, and we compare the known input parameters against the parameters fitted from output.</p> <p>We will use only relatively large values of $\\gamma$ for this procedure.  The reason why will become clear in a second test, where we demonstrate that there is an error between the expected final size and the modeled final size, and that this error shrinks with $\\gamma \\Delta t$, as we would expect a first-order approximation error to.</p> <p>To make this a pass-fail test, we will raise a flag if the fitted parameters are more than 5% different than the known ones.</p>"},{"location":"notebooks/03_SIS_nobirths_logistic_growth/#quick-demonstration-of-first-order-error-accumulation","title":"Quick demonstration of first-order error accumulation\u00b6","text":"<p>As noted before, for $\\gamma \\Delta t$ large, first-order integration like we are doing here can accumulate substantial error.  Calculating exactly how error will accumulate in an integrator for a dynamic process like this is beyond the scope here, and probably depends on a lot of details.  E.g., the ordering of steps - in a given step, does the <code>transmission</code> update from S-&gt;I state occur before or after the <code>infection</code> update that sends agents from I-&gt;S?  Do we use midpoint methods, timer countdowns, or take advantage of the unique memorylessness of the exponential distribution to simply remove a random fraction each time?  All that is beyond scope here, but just want to demonstrate that the error in the equilibrium value $I(t \\rightarrow \\infty)$ becomes large when the mean infectious period $\\frac{1}{\\gamma}$ is on the same order as $\\Delta t$</p>"},{"location":"notebooks/04_SIR_nobirths_outbreak_size/","title":"Outbreak size in the SIR model (Kermack-McKendrick relation)","text":"In\u00a0[1]: Copied! <pre>import itertools\n\nimport matplotlib.pyplot as plt\nimport numba as nb\nimport numpy as np\nimport pandas as pd\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import fsolve\nfrom scipy.special import lambertw\n\nimport laser.core\nimport laser.generic\nimport laser.core.distributions as dists\nfrom laser.generic.models import SIR\nfrom laser.generic.models.model import Model\nfrom laser.generic.newutils import ValuesMap\nfrom laser.generic.newutils import grid\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import itertools  import matplotlib.pyplot as plt import numba as nb import numpy as np import pandas as pd from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.core.propertyset import PropertySet from scipy.optimize import fsolve from scipy.special import lambertw  import laser.core import laser.generic import laser.core.distributions as dists from laser.generic.models import SIR from laser.generic.models.model import Model from laser.generic.newutils import ValuesMap from laser.generic.newutils import grid  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.4'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>def create_single_node_model(population: int, init_inf: int = 0, init_rec: int = 0, parameters: PropertySet = None) -&gt; Model:\n\n    scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: population, origin_x=0, origin_y=0)\n    scenario[\"S\"] = scenario.population - (init_inf + init_rec)\n    assert np.all(scenario[\"S\"] &gt;= 0), \"Initial susceptible population cannot be negative.\"\n    scenario[\"I\"] = init_inf\n    scenario[\"R\"] = init_rec\n\n    params = parameters or PropertySet({\"seed\": 20251017, \"nticks\": 365, \"beta\": 4.0/3.0, \"inf_mean\": 7.0, \"cbr\": 0.0, \"cdr\": 0.0})\n    for key in [\"beta\", \"inf_mean\"]:\n        assert key in params, f\"Parameter '{key}' must be specified.\"\n\n    model = Model(scenario, params)\n\n    infdurdist = dists.exponential(scale=params.inf_mean)\n\n    model.components = [SIR.Susceptible(model), SIR.Recovered(model), SIR.Infectious(model, infdurdist), SIR.Transmission(model, infdurdist)]\n\n    return model\n</pre> def create_single_node_model(population: int, init_inf: int = 0, init_rec: int = 0, parameters: PropertySet = None) -&gt; Model:      scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: population, origin_x=0, origin_y=0)     scenario[\"S\"] = scenario.population - (init_inf + init_rec)     assert np.all(scenario[\"S\"] &gt;= 0), \"Initial susceptible population cannot be negative.\"     scenario[\"I\"] = init_inf     scenario[\"R\"] = init_rec      params = parameters or PropertySet({\"seed\": 20251017, \"nticks\": 365, \"beta\": 4.0/3.0, \"inf_mean\": 7.0, \"cbr\": 0.0, \"cdr\": 0.0})     for key in [\"beta\", \"inf_mean\"]:         assert key in params, f\"Parameter '{key}' must be specified.\"      model = Model(scenario, params)      infdurdist = dists.exponential(scale=params.inf_mean)      model.components = [SIR.Susceptible(model), SIR.Recovered(model), SIR.Infectious(model, infdurdist), SIR.Transmission(model, infdurdist)]      return model In\u00a0[3]: Copied! <pre>pop = 1e5\ninitial_infected = 3\n# R0 = beta * inf_mean = 0.2 * 15 = 3.0 - expected attack fraction is just under 80%\nparameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.2, \"inf_mean\": 15})\n\n# Run simulations until we get an outbreak\noutbreak = False\nwhile not outbreak:\n\n    parameters.seed += 1\n    model = create_single_node_model(\n        population=pop,\n        init_inf=initial_infected,\n        init_rec=0,\n        parameters=parameters,\n    )\n\n    model.run()\n    outbreak = np.any(model.nodes.R[200] &gt;= 10)\n\nplt.plot(model.nodes.I)\n</pre> pop = 1e5 initial_infected = 3 # R0 = beta * inf_mean = 0.2 * 15 = 3.0 - expected attack fraction is just under 80% parameters = PropertySet({\"seed\": 2, \"nticks\": 730, \"verbose\": True, \"beta\": 0.2, \"inf_mean\": 15})  # Run simulations until we get an outbreak outbreak = False while not outbreak:      parameters.seed += 1     model = create_single_node_model(         population=pop,         init_inf=initial_infected,         init_rec=0,         parameters=parameters,     )      model.run()     outbreak = np.any(model.nodes.R[200] &gt;= 10)  plt.plot(model.nodes.I) <pre>\r100000 agents in f1 nodes:   0%|          | 0/730 [00:00&lt;?, ?it/s]</pre> <pre>\r100000 agents in f1 nodes:   0%|          | 1/730 [00:01&lt;16:38,  1.37s/it]</pre> <pre>\r100000 agents in f1 nodes:  42%|\u2588\u2588\u2588\u2588\u258f     | 303/730 [00:01&lt;00:01, 285.86it/s]</pre> <pre>\r100000 agents in f1 nodes: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 730/730 [00:01&lt;00:00, 468.30it/s]</pre> <pre>\n</pre> Out[3]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fda74e3e780&gt;]</pre> In\u00a0[4]: Copied! <pre># Estimate the outbreak size (attack fraction) using the final size equation\nR0 = parameters.beta * parameters.inf_mean\nS0 = (pop - initial_infected) / pop\nS_inf = -1 / R0 * lambertw(-R0 * S0 * np.exp(-R0)).real\nA = 1 - S_inf  # Attack fraction\nfinal_R = A * pop + initial_infected\n\nplt.plot(model.nodes.S, color=\"blue\")\nplt.plot(model.nodes.I, color=\"red\")\nplt.plot(model.nodes.R, color=\"green\")\nplt.plot(model.nodes.recovered, color=\"orange\", linestyle=\"dashed\")\nplt.axhline(final_R, color=\"darkgray\", linestyle=\"dashed\")\nplt.legend([\"S\", \"I\", \"R\", \"recoveries\", \"Est. R(\u221e)\"])\nplt.xlabel(\"Days\")\nplt.ylabel(\"Number of People\")\nplt.title(\"SIR Model with No Births or Deaths\")\nplt.show()\n</pre> # Estimate the outbreak size (attack fraction) using the final size equation R0 = parameters.beta * parameters.inf_mean S0 = (pop - initial_infected) / pop S_inf = -1 / R0 * lambertw(-R0 * S0 * np.exp(-R0)).real A = 1 - S_inf  # Attack fraction final_R = A * pop + initial_infected  plt.plot(model.nodes.S, color=\"blue\") plt.plot(model.nodes.I, color=\"red\") plt.plot(model.nodes.R, color=\"green\") plt.plot(model.nodes.recovered, color=\"orange\", linestyle=\"dashed\") plt.axhline(final_R, color=\"darkgray\", linestyle=\"dashed\") plt.legend([\"S\", \"I\", \"R\", \"recoveries\", \"Est. R(\u221e)\"]) plt.xlabel(\"Days\") plt.ylabel(\"Number of People\") plt.title(\"SIR Model with No Births or Deaths\") plt.show()  In\u00a0[5]: Copied! <pre>print(\"S+I+R = N:  \" + str(np.isclose(model.nodes.S + model.nodes.I + model.nodes.R, pop).all()))\nprint(\"S = N - sum(deltaI): \" + str(np.isclose(pop - np.squeeze(model.nodes.S)[1:], initial_infected+np.cumsum(model.nodes.incidence)[:-1]).all()))  # Account for 1 timestep offset here\nprint(\"R = sum(deltaR): \" + str(np.isclose(np.squeeze(model.nodes.R)[1:], np.cumsum(model.nodes.recovered)[:-1]).all()))  # Account for 1 timestep offset here\n</pre> print(\"S+I+R = N:  \" + str(np.isclose(model.nodes.S + model.nodes.I + model.nodes.R, pop).all())) print(\"S = N - sum(deltaI): \" + str(np.isclose(pop - np.squeeze(model.nodes.S)[1:], initial_infected+np.cumsum(model.nodes.incidence)[:-1]).all()))  # Account for 1 timestep offset here print(\"R = sum(deltaR): \" + str(np.isclose(np.squeeze(model.nodes.R)[1:], np.cumsum(model.nodes.recovered)[:-1]).all()))  # Account for 1 timestep offset here  <pre>S+I+R = N:  True\nS = N - sum(deltaI): True\nR = sum(deltaR): True\n</pre> In\u00a0[6]: Copied! <pre>def KM_limit(z, R0, S0, I0):\n    if R0 * S0 &lt; 1:\n        return 0\n    else:\n        return z - S0 * (1 - np.exp(-R0 * (z + I0)))\n</pre> def KM_limit(z, R0, S0, I0):     if R0 * S0 &lt; 1:         return 0     else:         return z - S0 * (1 - np.exp(-R0 * (z + I0))) In\u00a0[7]: Copied! <pre># %%capture\n\npopulation = 1e5\ninf_mean = 20\ninit_inf = 20\n\nR0s = np.concatenate((np.linspace(0.2, 1.0, 5), np.linspace(1.5, 10.0, 18)))\nS0s = [1.0, 0.8, 0.6, 0.4, 0.2]\noutput = pd.DataFrame(list(itertools.product(R0s, S0s)), columns=[\"R0\", \"S0\"])\noutput[\"I_inf_exp\"] = [\n    fsolve(KM_limit, 0.5 * (R0 * S0 &gt;= 1), args=(R0, S0, init_inf / population))[0] for R0, S0 in zip(output[\"R0\"], output[\"S0\"])\n]\noutput[\"S_inf_exp\"] = output[\"S0\"] - output[\"I_inf_exp\"]\noutput[\"I_inf_obs\"] = np.nan\noutput[\"S_inf_obs\"] = np.nan\n\n\nfor index, row in output.iterrows():\n\n    parameters = PropertySet({\"seed\": 2, \"nticks\": 1460, \"verbose\": True, \"inf_mean\": inf_mean, \"beta\": row[\"R0\"] / inf_mean})\n    model = create_single_node_model(\n        population=population,\n        init_inf=init_inf,\n        init_rec=int((1 - row[\"S0\"]) * population),\n        parameters=parameters,\n    )\n\n    model.run(f\"SIR Model {index+1:3}/{len(output)}\")\n\n    output.loc[index, \"I_inf_obs\"] = (\n        np.sum(model.nodes.incidence) + init_inf\n    ) / population  # incidence doesn't count the imported infections\n    output.loc[index, \"S_inf_obs\"] = model.nodes.S[-1] / population\n</pre> # %%capture  population = 1e5 inf_mean = 20 init_inf = 20  R0s = np.concatenate((np.linspace(0.2, 1.0, 5), np.linspace(1.5, 10.0, 18))) S0s = [1.0, 0.8, 0.6, 0.4, 0.2] output = pd.DataFrame(list(itertools.product(R0s, S0s)), columns=[\"R0\", \"S0\"]) output[\"I_inf_exp\"] = [     fsolve(KM_limit, 0.5 * (R0 * S0 &gt;= 1), args=(R0, S0, init_inf / population))[0] for R0, S0 in zip(output[\"R0\"], output[\"S0\"]) ] output[\"S_inf_exp\"] = output[\"S0\"] - output[\"I_inf_exp\"] output[\"I_inf_obs\"] = np.nan output[\"S_inf_obs\"] = np.nan   for index, row in output.iterrows():      parameters = PropertySet({\"seed\": 2, \"nticks\": 1460, \"verbose\": True, \"inf_mean\": inf_mean, \"beta\": row[\"R0\"] / inf_mean})     model = create_single_node_model(         population=population,         init_inf=init_inf,         init_rec=int((1 - row[\"S0\"]) * population),         parameters=parameters,     )      model.run(f\"SIR Model {index+1:3}/{len(output)}\")      output.loc[index, \"I_inf_obs\"] = (         np.sum(model.nodes.incidence) + init_inf     ) / population  # incidence doesn't count the imported infections     output.loc[index, \"S_inf_obs\"] = model.nodes.S[-1] / population <pre>\rSIR Model   1/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   1/115:   0%|          | 1/1460 [00:00&lt;11:42,  2.08it/s]</pre> <pre>\rSIR Model   1/115:  13%|\u2588\u258e        | 188/1460 [00:00&lt;00:02, 429.08it/s]</pre> <pre>\rSIR Model   1/115:  26%|\u2588\u2588\u258c       | 380/1460 [00:00&lt;00:01, 795.79it/s]</pre> <pre>\rSIR Model   1/115:  39%|\u2588\u2588\u2588\u2589      | 572/1460 [00:00&lt;00:00, 1088.03it/s]</pre> <pre>\rSIR Model   1/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 760/1460 [00:00&lt;00:00, 1301.63it/s]</pre> <pre>\rSIR Model   1/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 953/1460 [00:00&lt;00:00, 1474.75it/s]</pre> <pre>\rSIR Model   1/115:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 1146/1460 [00:01&lt;00:00, 1602.71it/s]</pre> <pre>\rSIR Model   1/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1338/1460 [00:01&lt;00:00, 1694.22it/s]</pre> <pre>\rSIR Model   1/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:01&lt;00:00, 1170.55it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   2/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   2/115:  14%|\u2588\u258e        | 200/1460 [00:00&lt;00:00, 1996.08it/s]</pre> <pre>\rSIR Model   2/115:  27%|\u2588\u2588\u258b       | 400/1460 [00:00&lt;00:00, 1996.18it/s]</pre> <pre>\rSIR Model   2/115:  41%|\u2588\u2588\u2588\u2588      | 601/1460 [00:00&lt;00:00, 1998.24it/s]</pre> <pre>\rSIR Model   2/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 803/1460 [00:00&lt;00:00, 2006.29it/s]</pre> <pre>\rSIR Model   2/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1005/1460 [00:00&lt;00:00, 2009.79it/s]</pre> <pre>\rSIR Model   2/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1207/1460 [00:00&lt;00:00, 2012.79it/s]</pre> <pre>\rSIR Model   2/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1409/1460 [00:00&lt;00:00, 2012.53it/s]</pre> <pre>\rSIR Model   2/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2005.77it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   3/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   3/115:  14%|\u2588\u258d        | 209/1460 [00:00&lt;00:00, 2080.87it/s]</pre> <pre>\rSIR Model   3/115:  29%|\u2588\u2588\u258a       | 419/1460 [00:00&lt;00:00, 2091.89it/s]</pre> <pre>\rSIR Model   3/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 629/1460 [00:00&lt;00:00, 2093.86it/s]</pre> <pre>\rSIR Model   3/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 840/1460 [00:00&lt;00:00, 2098.54it/s]</pre> <pre>\rSIR Model   3/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1051/1460 [00:00&lt;00:00, 2099.76it/s]</pre> <pre>\rSIR Model   3/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1261/1460 [00:00&lt;00:00, 1580.12it/s]</pre> <pre>\rSIR Model   3/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1840.31it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   4/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   4/115:  17%|\u2588\u258b        | 244/1460 [00:00&lt;00:00, 2436.95it/s]</pre> <pre>\rSIR Model   4/115:  33%|\u2588\u2588\u2588\u258e      | 488/1460 [00:00&lt;00:00, 2434.56it/s]</pre> <pre>\rSIR Model   4/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 732/1460 [00:00&lt;00:00, 2433.39it/s]</pre> <pre>\rSIR Model   4/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 976/1460 [00:00&lt;00:00, 2432.22it/s]</pre> <pre>\rSIR Model   4/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1220/1460 [00:00&lt;00:00, 2434.24it/s]</pre> <pre>\rSIR Model   4/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2415.55it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   5/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   5/115:  24%|\u2588\u2588\u258d       | 347/1460 [00:00&lt;00:00, 3464.56it/s]</pre> <pre>\rSIR Model   5/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 694/1460 [00:00&lt;00:00, 3437.59it/s]</pre> <pre>\rSIR Model   5/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1040/1460 [00:00&lt;00:00, 3447.12it/s]</pre> <pre>\rSIR Model   5/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1386/1460 [00:00&lt;00:00, 3451.61it/s]</pre> <pre>\rSIR Model   5/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3438.63it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   6/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   6/115:  13%|\u2588\u258e        | 193/1460 [00:00&lt;00:00, 1926.61it/s]</pre> <pre>\rSIR Model   6/115:  26%|\u2588\u2588\u258b       | 386/1460 [00:00&lt;00:00, 1921.51it/s]</pre> <pre>\rSIR Model   6/115:  40%|\u2588\u2588\u2588\u2589      | 579/1460 [00:00&lt;00:00, 1922.56it/s]</pre> <pre>\rSIR Model   6/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 772/1460 [00:00&lt;00:00, 1910.93it/s]</pre> <pre>\rSIR Model   6/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 964/1460 [00:00&lt;00:00, 1360.30it/s]</pre> <pre>\rSIR Model   6/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1154/1460 [00:00&lt;00:00, 1503.10it/s]</pre> <pre>\rSIR Model   6/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1346/1460 [00:00&lt;00:00, 1615.82it/s]</pre> <pre>\rSIR Model   6/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1660.79it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   7/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   7/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2009.07it/s]</pre> <pre>\rSIR Model   7/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 1996.17it/s]</pre> <pre>\rSIR Model   7/115:  41%|\u2588\u2588\u2588\u2588      | 602/1460 [00:00&lt;00:00, 1983.48it/s]</pre> <pre>\rSIR Model   7/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 802/1460 [00:00&lt;00:00, 1986.04it/s]</pre> <pre>\rSIR Model   7/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 1002/1460 [00:00&lt;00:00, 1988.93it/s]</pre> <pre>\rSIR Model   7/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1201/1460 [00:00&lt;00:00, 1989.01it/s]</pre> <pre>\rSIR Model   7/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1400/1460 [00:00&lt;00:00, 1986.90it/s]</pre> <pre>\rSIR Model   7/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1983.63it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   8/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   8/115:  15%|\u2588\u258d        | 214/1460 [00:00&lt;00:00, 2130.64it/s]</pre> <pre>\rSIR Model   8/115:  29%|\u2588\u2588\u2589       | 428/1460 [00:00&lt;00:00, 2123.63it/s]</pre> <pre>\rSIR Model   8/115:  44%|\u2588\u2588\u2588\u2588\u258d     | 641/1460 [00:00&lt;00:00, 2110.88it/s]</pre> <pre>\rSIR Model   8/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 853/1460 [00:00&lt;00:00, 2113.11it/s]</pre> <pre>\rSIR Model   8/115:  73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1066/1460 [00:00&lt;00:00, 2117.28it/s]</pre> <pre>\rSIR Model   8/115:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 1278/1460 [00:00&lt;00:00, 2117.26it/s]</pre> <pre>\rSIR Model   8/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2117.47it/s]</pre> <pre>\n</pre> <pre>\rSIR Model   9/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model   9/115:  17%|\u2588\u258b        | 245/1460 [00:00&lt;00:00, 2445.77it/s]</pre> <pre>\rSIR Model   9/115:  34%|\u2588\u2588\u2588\u258e      | 490/1460 [00:00&lt;00:00, 2430.49it/s]</pre> <pre>\rSIR Model   9/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 734/1460 [00:00&lt;00:00, 2394.70it/s]</pre> <pre>\rSIR Model   9/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 974/1460 [00:00&lt;00:00, 2367.58it/s]</pre> <pre>\rSIR Model   9/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1218/1460 [00:00&lt;00:00, 2390.22it/s]</pre> <pre>\rSIR Model   9/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2397.71it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  10/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  10/115:  24%|\u2588\u2588\u258e       | 345/1460 [00:00&lt;00:00, 3445.23it/s]</pre> <pre>\rSIR Model  10/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 690/1460 [00:00&lt;00:00, 3420.65it/s]</pre> <pre>\rSIR Model  10/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1034/1460 [00:00&lt;00:00, 3427.77it/s]</pre> <pre>\rSIR Model  10/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1377/1460 [00:00&lt;00:00, 3423.05it/s]</pre> <pre>\rSIR Model  10/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3414.93it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  11/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  11/115:  13%|\u2588\u258e        | 193/1460 [00:00&lt;00:00, 1927.52it/s]</pre> <pre>\rSIR Model  11/115:  26%|\u2588\u2588\u258b       | 386/1460 [00:00&lt;00:00, 1914.34it/s]</pre> <pre>\rSIR Model  11/115:  40%|\u2588\u2588\u2588\u2589      | 578/1460 [00:00&lt;00:00, 1892.07it/s]</pre> <pre>\rSIR Model  11/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 768/1460 [00:00&lt;00:00, 1875.17it/s]</pre> <pre>\rSIR Model  11/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 958/1460 [00:00&lt;00:00, 1883.98it/s]</pre> <pre>\rSIR Model  11/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1150/1460 [00:00&lt;00:00, 1894.62it/s]</pre> <pre>\rSIR Model  11/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1340/1460 [00:00&lt;00:00, 1890.47it/s]</pre> <pre>\rSIR Model  11/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1889.51it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  12/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  12/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2006.93it/s]</pre> <pre>\rSIR Model  12/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 2001.03it/s]</pre> <pre>\rSIR Model  12/115:  41%|\u2588\u2588\u2588\u2588\u258f     | 603/1460 [00:00&lt;00:00, 1997.48it/s]</pre> <pre>\rSIR Model  12/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 803/1460 [00:00&lt;00:00, 1995.14it/s]</pre> <pre>\rSIR Model  12/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1004/1460 [00:00&lt;00:00, 1997.08it/s]</pre> <pre>\rSIR Model  12/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1204/1460 [00:00&lt;00:00, 1993.16it/s]</pre> <pre>\rSIR Model  12/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1404/1460 [00:00&lt;00:00, 1986.12it/s]</pre> <pre>\rSIR Model  12/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1986.81it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  13/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  13/115:  14%|\u2588\u258d        | 211/1460 [00:00&lt;00:00, 2103.53it/s]</pre> <pre>\rSIR Model  13/115:  29%|\u2588\u2588\u2589       | 422/1460 [00:00&lt;00:00, 2089.66it/s]</pre> <pre>\rSIR Model  13/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 631/1460 [00:00&lt;00:00, 2037.80it/s]</pre> <pre>\rSIR Model  13/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 840/1460 [00:00&lt;00:00, 2055.81it/s]</pre> <pre>\rSIR Model  13/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1051/1460 [00:00&lt;00:00, 2075.07it/s]</pre> <pre>\rSIR Model  13/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1262/1460 [00:00&lt;00:00, 2085.64it/s]</pre> <pre>\rSIR Model  13/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2075.48it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  14/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  14/115:  17%|\u2588\u258b        | 243/1460 [00:00&lt;00:00, 2426.05it/s]</pre> <pre>\rSIR Model  14/115:  33%|\u2588\u2588\u2588\u258e      | 486/1460 [00:00&lt;00:00, 2420.25it/s]</pre> <pre>\rSIR Model  14/115:  50%|\u2588\u2588\u2588\u2588\u2589     | 729/1460 [00:00&lt;00:00, 2421.13it/s]</pre> <pre>\rSIR Model  14/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 972/1460 [00:00&lt;00:00, 2423.09it/s]</pre> <pre>\rSIR Model  14/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1216/1460 [00:00&lt;00:00, 2425.95it/s]</pre> <pre>\rSIR Model  14/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2426.36it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  15/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  15/115:  24%|\u2588\u2588\u258d       | 347/1460 [00:00&lt;00:00, 3461.33it/s]</pre> <pre>\rSIR Model  15/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 695/1460 [00:00&lt;00:00, 3468.25it/s]</pre> <pre>\rSIR Model  15/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1042/1460 [00:00&lt;00:00, 3459.89it/s]</pre> <pre>\rSIR Model  15/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1388/1460 [00:00&lt;00:00, 3457.92it/s]</pre> <pre>\rSIR Model  15/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3449.52it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  16/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  16/115:  13%|\u2588\u258e        | 191/1460 [00:00&lt;00:00, 1901.95it/s]</pre> <pre>\rSIR Model  16/115:  26%|\u2588\u2588\u258c       | 382/1460 [00:00&lt;00:00, 1898.81it/s]</pre> <pre>\rSIR Model  16/115:  39%|\u2588\u2588\u2588\u2589      | 573/1460 [00:00&lt;00:00, 1903.48it/s]</pre> <pre>\rSIR Model  16/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 765/1460 [00:00&lt;00:00, 1909.80it/s]</pre> <pre>\rSIR Model  16/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 958/1460 [00:00&lt;00:00, 1915.95it/s]</pre> <pre>\rSIR Model  16/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1151/1460 [00:00&lt;00:00, 1917.87it/s]</pre> <pre>\rSIR Model  16/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1344/1460 [00:00&lt;00:00, 1919.50it/s]</pre> <pre>\rSIR Model  16/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1912.51it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  17/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  17/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2002.03it/s]</pre> <pre>\rSIR Model  17/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 1976.52it/s]</pre> <pre>\rSIR Model  17/115:  41%|\u2588\u2588\u2588\u2588\u258f     | 603/1460 [00:00&lt;00:00, 1991.34it/s]</pre> <pre>\rSIR Model  17/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 804/1460 [00:00&lt;00:00, 1995.65it/s]</pre> <pre>\rSIR Model  17/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1006/1460 [00:00&lt;00:00, 2003.87it/s]</pre> <pre>\rSIR Model  17/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1208/1460 [00:00&lt;00:00, 2007.84it/s]</pre> <pre>\rSIR Model  17/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1410/1460 [00:00&lt;00:00, 2010.77it/s]</pre> <pre>\rSIR Model  17/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2001.00it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  18/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  18/115:  14%|\u2588\u258d        | 211/1460 [00:00&lt;00:00, 2109.91it/s]</pre> <pre>\rSIR Model  18/115:  29%|\u2588\u2588\u2589       | 422/1460 [00:00&lt;00:00, 2102.85it/s]</pre> <pre>\rSIR Model  18/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 633/1460 [00:00&lt;00:00, 2104.75it/s]</pre> <pre>\rSIR Model  18/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 845/1460 [00:00&lt;00:00, 2109.43it/s]</pre> <pre>\rSIR Model  18/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1057/1460 [00:00&lt;00:00, 2112.39it/s]</pre> <pre>\rSIR Model  18/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1269/1460 [00:00&lt;00:00, 2114.11it/s]</pre> <pre>\rSIR Model  18/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2110.90it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  19/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  19/115:  17%|\u2588\u258b        | 244/1460 [00:00&lt;00:00, 2437.69it/s]</pre> <pre>\rSIR Model  19/115:  33%|\u2588\u2588\u2588\u258e      | 488/1460 [00:00&lt;00:00, 2426.22it/s]</pre> <pre>\rSIR Model  19/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 731/1460 [00:00&lt;00:00, 2413.19it/s]</pre> <pre>\rSIR Model  19/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 974/1460 [00:00&lt;00:00, 2418.17it/s]</pre> <pre>\rSIR Model  19/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1217/1460 [00:00&lt;00:00, 2419.96it/s]</pre> <pre>\rSIR Model  19/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2422.59it/s]</pre> <pre>\rSIR Model  19/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2418.85it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  20/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  20/115:  24%|\u2588\u2588\u258e       | 345/1460 [00:00&lt;00:00, 3442.09it/s]</pre> <pre>\rSIR Model  20/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 690/1460 [00:00&lt;00:00, 3429.72it/s]</pre> <pre>\rSIR Model  20/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1033/1460 [00:00&lt;00:00, 3428.02it/s]</pre> <pre>\rSIR Model  20/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1376/1460 [00:00&lt;00:00, 3422.97it/s]</pre> <pre>\rSIR Model  20/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3413.41it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  21/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  21/115:  13%|\u2588\u258e        | 193/1460 [00:00&lt;00:00, 1923.48it/s]</pre> <pre>\rSIR Model  21/115:  26%|\u2588\u2588\u258b       | 386/1460 [00:00&lt;00:00, 1922.76it/s]</pre> <pre>\rSIR Model  21/115:  40%|\u2588\u2588\u2588\u2589      | 579/1460 [00:00&lt;00:00, 1924.94it/s]</pre> <pre>\rSIR Model  21/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 772/1460 [00:00&lt;00:00, 1924.12it/s]</pre> <pre>\rSIR Model  21/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 965/1460 [00:00&lt;00:00, 1924.91it/s]</pre> <pre>\rSIR Model  21/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1158/1460 [00:00&lt;00:00, 1923.13it/s]</pre> <pre>\rSIR Model  21/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1351/1460 [00:00&lt;00:00, 1915.11it/s]</pre> <pre>\rSIR Model  21/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1918.63it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  22/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  22/115:  14%|\u2588\u258d        | 202/1460 [00:00&lt;00:00, 2014.55it/s]</pre> <pre>\rSIR Model  22/115:  28%|\u2588\u2588\u258a       | 404/1460 [00:00&lt;00:00, 2017.59it/s]</pre> <pre>\rSIR Model  22/115:  42%|\u2588\u2588\u2588\u2588\u258f     | 606/1460 [00:00&lt;00:00, 2018.64it/s]</pre> <pre>\rSIR Model  22/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 809/1460 [00:00&lt;00:00, 2019.79it/s]</pre> <pre>\rSIR Model  22/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1011/1460 [00:00&lt;00:00, 2018.83it/s]</pre> <pre>\rSIR Model  22/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1213/1460 [00:00&lt;00:00, 2018.44it/s]</pre> <pre>\rSIR Model  22/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1415/1460 [00:00&lt;00:00, 2014.55it/s]</pre> <pre>\rSIR Model  22/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2012.96it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  23/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  23/115:  15%|\u2588\u258d        | 212/1460 [00:00&lt;00:00, 2110.86it/s]</pre> <pre>\rSIR Model  23/115:  29%|\u2588\u2588\u2589       | 424/1460 [00:00&lt;00:00, 2105.57it/s]</pre> <pre>\rSIR Model  23/115:  43%|\u2588\u2588\u2588\u2588\u258e     | 635/1460 [00:00&lt;00:00, 2104.63it/s]</pre> <pre>\rSIR Model  23/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 846/1460 [00:00&lt;00:00, 2101.58it/s]</pre> <pre>\rSIR Model  23/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1058/1460 [00:00&lt;00:00, 2105.75it/s]</pre> <pre>\rSIR Model  23/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1269/1460 [00:00&lt;00:00, 2102.91it/s]</pre> <pre>\rSIR Model  23/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2093.64it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  24/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  24/115:  17%|\u2588\u258b        | 244/1460 [00:00&lt;00:00, 2432.80it/s]</pre> <pre>\rSIR Model  24/115:  33%|\u2588\u2588\u2588\u258e      | 488/1460 [00:00&lt;00:00, 2424.64it/s]</pre> <pre>\rSIR Model  24/115:  50%|\u2588\u2588\u2588\u2588\u2588     | 731/1460 [00:00&lt;00:00, 2389.08it/s]</pre> <pre>\rSIR Model  24/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 973/1460 [00:00&lt;00:00, 2398.48it/s]</pre> <pre>\rSIR Model  24/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1217/1460 [00:00&lt;00:00, 2411.94it/s]</pre> <pre>\rSIR Model  24/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2417.52it/s]</pre> <pre>\rSIR Model  24/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2406.92it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  25/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  25/115:  24%|\u2588\u2588\u258e       | 345/1460 [00:00&lt;00:00, 3449.31it/s]</pre> <pre>\rSIR Model  25/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 690/1460 [00:00&lt;00:00, 3442.80it/s]</pre> <pre>\rSIR Model  25/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1035/1460 [00:00&lt;00:00, 3442.10it/s]</pre> <pre>\rSIR Model  25/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1380/1460 [00:00&lt;00:00, 3439.86it/s]</pre> <pre>\rSIR Model  25/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3400.86it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  26/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  26/115:  13%|\u2588\u258e        | 187/1460 [00:00&lt;00:00, 1795.35it/s]</pre> <pre>\rSIR Model  26/115:  26%|\u2588\u2588\u258c       | 374/1460 [00:00&lt;00:00, 1837.75it/s]</pre> <pre>\rSIR Model  26/115:  41%|\u2588\u2588\u2588\u2588      | 593/1460 [00:00&lt;00:00, 1996.69it/s]</pre> <pre>\rSIR Model  26/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 819/1460 [00:00&lt;00:00, 2098.47it/s]</pre> <pre>\rSIR Model  26/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1045/1460 [00:00&lt;00:00, 2153.58it/s]</pre> <pre>\rSIR Model  26/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1272/1460 [00:00&lt;00:00, 2190.52it/s]</pre> <pre>\rSIR Model  26/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2133.28it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  27/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  27/115:  13%|\u2588\u258e        | 190/1460 [00:00&lt;00:00, 1897.20it/s]</pre> <pre>\rSIR Model  27/115:  26%|\u2588\u2588\u258c       | 382/1460 [00:00&lt;00:00, 1904.99it/s]</pre> <pre>\rSIR Model  27/115:  39%|\u2588\u2588\u2588\u2589      | 573/1460 [00:00&lt;00:00, 1897.82it/s]</pre> <pre>\rSIR Model  27/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 771/1460 [00:00&lt;00:00, 1927.28it/s]</pre> <pre>\rSIR Model  27/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 972/1460 [00:00&lt;00:00, 1955.48it/s]</pre> <pre>\rSIR Model  27/115:  81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 1176/1460 [00:00&lt;00:00, 1981.31it/s]</pre> <pre>\rSIR Model  27/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1380/1460 [00:00&lt;00:00, 2000.25it/s]</pre> <pre>\rSIR Model  27/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1956.77it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  28/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  28/115:  13%|\u2588\u258e        | 197/1460 [00:00&lt;00:00, 1965.65it/s]</pre> <pre>\rSIR Model  28/115:  27%|\u2588\u2588\u258b       | 396/1460 [00:00&lt;00:00, 1977.42it/s]</pre> <pre>\rSIR Model  28/115:  41%|\u2588\u2588\u2588\u2588      | 596/1460 [00:00&lt;00:00, 1985.79it/s]</pre> <pre>\rSIR Model  28/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258d    | 796/1460 [00:00&lt;00:00, 1991.29it/s]</pre> <pre>\rSIR Model  28/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 996/1460 [00:00&lt;00:00, 1990.00it/s]</pre> <pre>\rSIR Model  28/115:  82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1196/1460 [00:00&lt;00:00, 1993.08it/s]</pre> <pre>\rSIR Model  28/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1397/1460 [00:00&lt;00:00, 1996.62it/s]</pre> <pre>\rSIR Model  28/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 1987.00it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  29/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  29/115:  16%|\u2588\u258c        | 233/1460 [00:00&lt;00:00, 2279.13it/s]</pre> <pre>\rSIR Model  29/115:  32%|\u2588\u2588\u2588\u258f      | 464/1460 [00:00&lt;00:00, 2292.84it/s]</pre> <pre>\rSIR Model  29/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 696/1460 [00:00&lt;00:00, 2301.55it/s]</pre> <pre>\rSIR Model  29/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 928/1460 [00:00&lt;00:00, 2307.39it/s]</pre> <pre>\rSIR Model  29/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1160/1460 [00:00&lt;00:00, 2310.16it/s]</pre> <pre>\rSIR Model  29/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1392/1460 [00:00&lt;00:00, 2311.59it/s]</pre> <pre>\rSIR Model  29/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2308.41it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  30/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  30/115:  22%|\u2588\u2588\u258f       | 325/1460 [00:00&lt;00:00, 3235.20it/s]</pre> <pre>\rSIR Model  30/115:  44%|\u2588\u2588\u2588\u2588\u258d     | 649/1460 [00:00&lt;00:00, 3215.35it/s]</pre> <pre>\rSIR Model  30/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 976/1460 [00:00&lt;00:00, 3227.03it/s]</pre> <pre>\rSIR Model  30/115:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1299/1460 [00:00&lt;00:00, 3227.53it/s]</pre> <pre>\rSIR Model  30/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3239.16it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  31/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  31/115:  12%|\u2588\u258f        | 173/1460 [00:00&lt;00:00, 1725.83it/s]</pre> <pre>\rSIR Model  31/115:  30%|\u2588\u2588\u2588       | 445/1460 [00:00&lt;00:00, 2306.95it/s]</pre> <pre>\rSIR Model  31/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 765/1460 [00:00&lt;00:00, 2711.41it/s]</pre> <pre>\rSIR Model  31/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1085/1460 [00:00&lt;00:00, 2901.05it/s]</pre> <pre>\rSIR Model  31/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1404/1460 [00:00&lt;00:00, 3003.96it/s]</pre> <pre>\rSIR Model  31/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2811.34it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  32/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  32/115:  13%|\u2588\u258e        | 185/1460 [00:00&lt;00:00, 1845.20it/s]</pre> <pre>\rSIR Model  32/115:  27%|\u2588\u2588\u258b       | 398/1460 [00:00&lt;00:00, 2004.28it/s]</pre> <pre>\rSIR Model  32/115:  46%|\u2588\u2588\u2588\u2588\u258b     | 676/1460 [00:00&lt;00:00, 2348.25it/s]</pre> <pre>\rSIR Model  32/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 954/1460 [00:00&lt;00:00, 2515.12it/s]</pre> <pre>\rSIR Model  32/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1233/1460 [00:00&lt;00:00, 2612.32it/s]</pre> <pre>\rSIR Model  32/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2515.28it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  33/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  33/115:  14%|\u2588\u258d        | 201/1460 [00:00&lt;00:00, 2000.65it/s]</pre> <pre>\rSIR Model  33/115:  28%|\u2588\u2588\u258a       | 402/1460 [00:00&lt;00:00, 2003.82it/s]</pre> <pre>\rSIR Model  33/115:  41%|\u2588\u2588\u2588\u2588\u258f     | 604/1460 [00:00&lt;00:00, 2009.23it/s]</pre> <pre>\rSIR Model  33/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 814/1460 [00:00&lt;00:00, 2044.46it/s]</pre> <pre>\rSIR Model  33/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1037/1460 [00:00&lt;00:00, 2109.42it/s]</pre> <pre>\rSIR Model  33/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1265/1460 [00:00&lt;00:00, 2164.30it/s]</pre> <pre>\rSIR Model  33/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2121.02it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  34/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  34/115:  15%|\u2588\u258c        | 226/1460 [00:00&lt;00:00, 2249.95it/s]</pre> <pre>\rSIR Model  34/115:  31%|\u2588\u2588\u2588\u258f      | 459/1460 [00:00&lt;00:00, 2292.13it/s]</pre> <pre>\rSIR Model  34/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 690/1460 [00:00&lt;00:00, 2298.89it/s]</pre> <pre>\rSIR Model  34/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 920/1460 [00:00&lt;00:00, 2297.53it/s]</pre> <pre>\rSIR Model  34/115:  79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1151/1460 [00:00&lt;00:00, 2299.66it/s]</pre> <pre>\rSIR Model  34/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1382/1460 [00:00&lt;00:00, 2302.66it/s]</pre> <pre>\rSIR Model  34/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2300.76it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  35/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  35/115:  23%|\u2588\u2588\u258e       | 329/1460 [00:00&lt;00:00, 3289.73it/s]</pre> <pre>\rSIR Model  35/115:  45%|\u2588\u2588\u2588\u2588\u258c     | 658/1460 [00:00&lt;00:00, 3276.07it/s]</pre> <pre>\rSIR Model  35/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 986/1460 [00:00&lt;00:00, 3276.05it/s]</pre> <pre>\rSIR Model  35/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1319/1460 [00:00&lt;00:00, 3296.86it/s]</pre> <pre>\rSIR Model  35/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3294.61it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  36/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  36/115:  16%|\u2588\u258c        | 236/1460 [00:00&lt;00:00, 2357.30it/s]</pre> <pre>\rSIR Model  36/115:  45%|\u2588\u2588\u2588\u2588\u258c     | 663/1460 [00:00&lt;00:00, 3481.25it/s]</pre> <pre>\rSIR Model  36/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1088/1460 [00:00&lt;00:00, 3828.73it/s]</pre> <pre>\rSIR Model  36/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3768.64it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  37/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  37/115:  14%|\u2588\u258d        | 209/1460 [00:00&lt;00:00, 2087.15it/s]</pre> <pre>\rSIR Model  37/115:  39%|\u2588\u2588\u2588\u2589      | 576/1460 [00:00&lt;00:00, 3014.29it/s]</pre> <pre>\rSIR Model  37/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 956/1460 [00:00&lt;00:00, 3371.23it/s]</pre> <pre>\rSIR Model  37/115:  92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1336/1460 [00:00&lt;00:00, 3539.10it/s]</pre> <pre>\rSIR Model  37/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3363.92it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  38/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  38/115:  14%|\u2588\u258d        | 211/1460 [00:00&lt;00:00, 2108.73it/s]</pre> <pre>\rSIR Model  38/115:  29%|\u2588\u2588\u2589       | 426/1460 [00:00&lt;00:00, 2129.06it/s]</pre> <pre>\rSIR Model  38/115:  49%|\u2588\u2588\u2588\u2588\u2589     | 715/1460 [00:00&lt;00:00, 2473.00it/s]</pre> <pre>\rSIR Model  38/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1010/1460 [00:00&lt;00:00, 2658.93it/s]</pre> <pre>\rSIR Model  38/115:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1297/1460 [00:00&lt;00:00, 2734.58it/s]</pre> <pre>\rSIR Model  38/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2632.21it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  39/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  39/115:  17%|\u2588\u258b        | 243/1460 [00:00&lt;00:00, 2426.16it/s]</pre> <pre>\rSIR Model  39/115:  33%|\u2588\u2588\u2588\u258e      | 486/1460 [00:00&lt;00:00, 2420.12it/s]</pre> <pre>\rSIR Model  39/115:  50%|\u2588\u2588\u2588\u2588\u2589     | 729/1460 [00:00&lt;00:00, 2420.39it/s]</pre> <pre>\rSIR Model  39/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 973/1460 [00:00&lt;00:00, 2425.25it/s]</pre> <pre>\rSIR Model  39/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1217/1460 [00:00&lt;00:00, 2429.07it/s]</pre> <pre>\rSIR Model  39/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2426.19it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  40/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  40/115:  23%|\u2588\u2588\u258e       | 330/1460 [00:00&lt;00:00, 3284.01it/s]</pre> <pre>\rSIR Model  40/115:  46%|\u2588\u2588\u2588\u2588\u258c     | 670/1460 [00:00&lt;00:00, 3348.44it/s]</pre> <pre>\rSIR Model  40/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1015/1460 [00:00&lt;00:00, 3390.63it/s]</pre> <pre>\rSIR Model  40/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1359/1460 [00:00&lt;00:00, 3407.97it/s]</pre> <pre>\rSIR Model  40/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3383.76it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  41/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  41/115:  20%|\u2588\u2588        | 294/1460 [00:00&lt;00:00, 2938.55it/s]</pre> <pre>\rSIR Model  41/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 781/1460 [00:00&lt;00:00, 4070.24it/s]</pre> <pre>\rSIR Model  41/115:  87%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1270/1460 [00:00&lt;00:00, 4441.63it/s]</pre> <pre>\rSIR Model  41/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4289.93it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  42/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  42/115:  17%|\u2588\u258b        | 242/1460 [00:00&lt;00:00, 2416.28it/s]</pre> <pre>\rSIR Model  42/115:  46%|\u2588\u2588\u2588\u2588\u258b     | 678/1460 [00:00&lt;00:00, 3557.86it/s]</pre> <pre>\rSIR Model  42/115:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 1121/1460 [00:00&lt;00:00, 3954.66it/s]</pre> <pre>\rSIR Model  42/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3863.74it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  43/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  43/115:  15%|\u2588\u258d        | 215/1460 [00:00&lt;00:00, 2145.75it/s]</pre> <pre>\rSIR Model  43/115:  38%|\u2588\u2588\u2588\u258a      | 562/1460 [00:00&lt;00:00, 2920.49it/s]</pre> <pre>\rSIR Model  43/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 933/1460 [00:00&lt;00:00, 3277.38it/s]</pre> <pre>\rSIR Model  43/115:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1302/1460 [00:00&lt;00:00, 3437.97it/s]</pre> <pre>\rSIR Model  43/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3284.46it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  44/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  44/115:  17%|\u2588\u258b        | 245/1460 [00:00&lt;00:00, 2448.75it/s]</pre> <pre>\rSIR Model  44/115:  34%|\u2588\u2588\u2588\u258d      | 499/1460 [00:00&lt;00:00, 2497.16it/s]</pre> <pre>\rSIR Model  44/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 780/1460 [00:00&lt;00:00, 2638.13it/s]</pre> <pre>\rSIR Model  44/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1076/1460 [00:00&lt;00:00, 2762.29it/s]</pre> <pre>\rSIR Model  44/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1370/1460 [00:00&lt;00:00, 2826.08it/s]</pre> <pre>\rSIR Model  44/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 2742.87it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  45/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  45/115:  23%|\u2588\u2588\u258e       | 342/1460 [00:00&lt;00:00, 3418.16it/s]</pre> <pre>\rSIR Model  45/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 684/1460 [00:00&lt;00:00, 3403.67it/s]</pre> <pre>\rSIR Model  45/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1026/1460 [00:00&lt;00:00, 3407.47it/s]</pre> <pre>\rSIR Model  45/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1367/1460 [00:00&lt;00:00, 3336.97it/s]</pre> <pre>\rSIR Model  45/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3356.03it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  46/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  46/115:  23%|\u2588\u2588\u258e       | 341/1460 [00:00&lt;00:00, 3406.25it/s]</pre> <pre>\rSIR Model  46/115:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 858/1460 [00:00&lt;00:00, 4441.91it/s]</pre> <pre>\rSIR Model  46/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1379/1460 [00:00&lt;00:00, 4790.13it/s]</pre> <pre>\rSIR Model  46/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4601.45it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  47/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  47/115:  20%|\u2588\u2588        | 293/1460 [00:00&lt;00:00, 2928.95it/s]</pre> <pre>\rSIR Model  47/115:  53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 769/1460 [00:00&lt;00:00, 4000.95it/s]</pre> <pre>\rSIR Model  47/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1254/1460 [00:00&lt;00:00, 4386.52it/s]</pre> <pre>\rSIR Model  47/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4250.16it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  48/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  48/115:  16%|\u2588\u258c        | 235/1460 [00:00&lt;00:00, 2348.52it/s]</pre> <pre>\rSIR Model  48/115:  45%|\u2588\u2588\u2588\u2588\u258c     | 659/1460 [00:00&lt;00:00, 3457.53it/s]</pre> <pre>\rSIR Model  48/115:  75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1088/1460 [00:00&lt;00:00, 3836.75it/s]</pre> <pre>\rSIR Model  48/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3772.49it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  49/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  49/115:  17%|\u2588\u258b        | 247/1460 [00:00&lt;00:00, 2467.20it/s]</pre> <pre>\rSIR Model  49/115:  38%|\u2588\u2588\u2588\u258a      | 550/1460 [00:00&lt;00:00, 2794.18it/s]</pre> <pre>\rSIR Model  49/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 903/1460 [00:00&lt;00:00, 3126.85it/s]</pre> <pre>\rSIR Model  49/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1257/1460 [00:00&lt;00:00, 3286.94it/s]</pre> <pre>\rSIR Model  49/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3181.68it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  50/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  50/115:  24%|\u2588\u2588\u258d       | 347/1460 [00:00&lt;00:00, 3463.92it/s]</pre> <pre>\rSIR Model  50/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 694/1460 [00:00&lt;00:00, 3451.31it/s]</pre> <pre>\rSIR Model  50/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1040/1460 [00:00&lt;00:00, 3452.62it/s]</pre> <pre>\rSIR Model  50/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1386/1460 [00:00&lt;00:00, 3441.50it/s]</pre> <pre>\rSIR Model  50/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3435.29it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  51/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  51/115:  25%|\u2588\u2588\u258c       | 372/1460 [00:00&lt;00:00, 3716.54it/s]</pre> <pre>\rSIR Model  51/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 904/1460 [00:00&lt;00:00, 4658.63it/s]</pre> <pre>\rSIR Model  51/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1429/1460 [00:00&lt;00:00, 4927.83it/s]</pre> <pre>\rSIR Model  51/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4754.25it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  52/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  52/115:  24%|\u2588\u2588\u258d       | 349/1460 [00:00&lt;00:00, 3485.51it/s]</pre> <pre>\rSIR Model  52/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 853/1460 [00:00&lt;00:00, 4394.97it/s]</pre> <pre>\rSIR Model  52/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1365/1460 [00:00&lt;00:00, 4724.45it/s]</pre> <pre>\rSIR Model  52/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4563.27it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  53/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  53/115:  20%|\u2588\u2589        | 288/1460 [00:00&lt;00:00, 2875.80it/s]</pre> <pre>\rSIR Model  53/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 758/1460 [00:00&lt;00:00, 3943.89it/s]</pre> <pre>\rSIR Model  53/115:  84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1226/1460 [00:00&lt;00:00, 4278.56it/s]</pre> <pre>\rSIR Model  53/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4160.90it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  54/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  54/115:  18%|\u2588\u258a        | 258/1460 [00:00&lt;00:00, 2572.48it/s]</pre> <pre>\rSIR Model  54/115:  44%|\u2588\u2588\u2588\u2588\u258e     | 636/1460 [00:00&lt;00:00, 3280.60it/s]</pre> <pre>\rSIR Model  54/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1030/1460 [00:00&lt;00:00, 3577.81it/s]</pre> <pre>\rSIR Model  54/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1423/1460 [00:00&lt;00:00, 3715.63it/s]</pre> <pre>\rSIR Model  54/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3549.16it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  55/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  55/115:  24%|\u2588\u2588\u258e       | 346/1460 [00:00&lt;00:00, 3450.29it/s]</pre> <pre>\rSIR Model  55/115:  47%|\u2588\u2588\u2588\u2588\u258b     | 692/1460 [00:00&lt;00:00, 3441.62it/s]</pre> <pre>\rSIR Model  55/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1037/1460 [00:00&lt;00:00, 3405.65it/s]</pre> <pre>\rSIR Model  55/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1383/1460 [00:00&lt;00:00, 3424.76it/s]</pre> <pre>\rSIR Model  55/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3418.08it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  56/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  56/115:  26%|\u2588\u2588\u258b       | 386/1460 [00:00&lt;00:00, 3856.16it/s]</pre> <pre>\rSIR Model  56/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 923/1460 [00:00&lt;00:00, 4741.77it/s]</pre> <pre>\rSIR Model  56/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1458/1460 [00:00&lt;00:00, 5018.40it/s]</pre> <pre>\rSIR Model  56/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4839.67it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  57/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  57/115:  26%|\u2588\u2588\u258c       | 377/1460 [00:00&lt;00:00, 3767.87it/s]</pre> <pre>\rSIR Model  57/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 911/1460 [00:00&lt;00:00, 4687.93it/s]</pre> <pre>\rSIR Model  57/115:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1444/1460 [00:00&lt;00:00, 4980.68it/s]</pre> <pre>\rSIR Model  57/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4794.14it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  58/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  58/115:  23%|\u2588\u2588\u258e       | 331/1460 [00:00&lt;00:00, 3308.11it/s]</pre> <pre>\rSIR Model  58/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 818/1460 [00:00&lt;00:00, 4226.13it/s]</pre> <pre>\rSIR Model  58/115:  90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1315/1460 [00:00&lt;00:00, 4562.28it/s]</pre> <pre>\rSIR Model  58/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4414.53it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  59/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  59/115:  20%|\u2588\u2589        | 286/1460 [00:00&lt;00:00, 2854.24it/s]</pre> <pre>\rSIR Model  59/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 706/1460 [00:00&lt;00:00, 3644.59it/s]</pre> <pre>\rSIR Model  59/115:  77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 1127/1460 [00:00&lt;00:00, 3901.52it/s]</pre> <pre>\rSIR Model  59/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3842.33it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  60/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  60/115:  24%|\u2588\u2588\u258d       | 348/1460 [00:00&lt;00:00, 3472.43it/s]</pre> <pre>\rSIR Model  60/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 696/1460 [00:00&lt;00:00, 3473.30it/s]</pre> <pre>\rSIR Model  60/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1044/1460 [00:00&lt;00:00, 3455.64it/s]</pre> <pre>\rSIR Model  60/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1393/1460 [00:00&lt;00:00, 3467.08it/s]</pre> <pre>\rSIR Model  60/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3454.11it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  61/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  61/115:  28%|\u2588\u2588\u258a       | 406/1460 [00:00&lt;00:00, 4056.66it/s]</pre> <pre>\rSIR Model  61/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 948/1460 [00:00&lt;00:00, 4856.97it/s]</pre> <pre>\rSIR Model  61/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4976.27it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  62/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  62/115:  27%|\u2588\u2588\u258b       | 399/1460 [00:00&lt;00:00, 3984.29it/s]</pre> <pre>\rSIR Model  62/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 935/1460 [00:00&lt;00:00, 4791.89it/s]</pre> <pre>\rSIR Model  62/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4905.49it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  63/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  63/115:  24%|\u2588\u2588\u258d       | 353/1460 [00:00&lt;00:00, 3523.43it/s]</pre> <pre>\rSIR Model  63/115:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 865/1460 [00:00&lt;00:00, 4459.58it/s]</pre> <pre>\rSIR Model  63/115:  94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1375/1460 [00:00&lt;00:00, 4750.42it/s]</pre> <pre>\rSIR Model  63/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4589.39it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  64/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  64/115:  20%|\u2588\u2588        | 295/1460 [00:00&lt;00:00, 2945.11it/s]</pre> <pre>\rSIR Model  64/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 757/1460 [00:00&lt;00:00, 3925.09it/s]</pre> <pre>\rSIR Model  64/115:  83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1217/1460 [00:00&lt;00:00, 4230.07it/s]</pre> <pre>\rSIR Model  64/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4126.62it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  65/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  65/115:  24%|\u2588\u2588\u258d       | 347/1460 [00:00&lt;00:00, 3462.20it/s]</pre> <pre>\rSIR Model  65/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 695/1460 [00:00&lt;00:00, 3467.04it/s]</pre> <pre>\rSIR Model  65/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1047/1460 [00:00&lt;00:00, 3491.14it/s]</pre> <pre>\rSIR Model  65/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1401/1460 [00:00&lt;00:00, 3508.17it/s]</pre> <pre>\rSIR Model  65/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3488.79it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  66/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  66/115:  29%|\u2588\u2588\u2589       | 426/1460 [00:00&lt;00:00, 4254.54it/s]</pre> <pre>\rSIR Model  66/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 963/1460 [00:00&lt;00:00, 4908.81it/s]</pre> <pre>\rSIR Model  66/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5048.70it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  67/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  67/115:  28%|\u2588\u2588\u258a       | 411/1460 [00:00&lt;00:00, 4105.62it/s]</pre> <pre>\rSIR Model  67/115:  65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 947/1460 [00:00&lt;00:00, 4842.13it/s]</pre> <pre>\rSIR Model  67/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4955.78it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  68/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  68/115:  26%|\u2588\u2588\u258c       | 379/1460 [00:00&lt;00:00, 3783.44it/s]</pre> <pre>\rSIR Model  68/115:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 892/1460 [00:00&lt;00:00, 4571.82it/s]</pre> <pre>\rSIR Model  68/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1406/1460 [00:00&lt;00:00, 4829.45it/s]</pre> <pre>\rSIR Model  68/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4676.92it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  69/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  69/115:  23%|\u2588\u2588\u258e       | 338/1460 [00:00&lt;00:00, 3374.32it/s]</pre> <pre>\rSIR Model  69/115:  56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 813/1460 [00:00&lt;00:00, 4179.46it/s]</pre> <pre>\rSIR Model  69/115:  88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 1289/1460 [00:00&lt;00:00, 4440.40it/s]</pre> <pre>\rSIR Model  69/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4329.96it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  70/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  70/115:  24%|\u2588\u2588\u258d       | 348/1460 [00:00&lt;00:00, 3477.93it/s]</pre> <pre>\rSIR Model  70/115:  48%|\u2588\u2588\u2588\u2588\u258a     | 707/1460 [00:00&lt;00:00, 3538.17it/s]</pre> <pre>\rSIR Model  70/115:  74%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1076/1460 [00:00&lt;00:00, 3603.69it/s]</pre> <pre>\rSIR Model  70/115:  99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1450/1460 [00:00&lt;00:00, 3655.81it/s]</pre> <pre>\rSIR Model  70/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3608.65it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  71/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  71/115:  30%|\u2588\u2588\u2589       | 437/1460 [00:00&lt;00:00, 4363.67it/s]</pre> <pre>\rSIR Model  71/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 990/1460 [00:00&lt;00:00, 5042.69it/s]</pre> <pre>\rSIR Model  71/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5148.77it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  72/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  72/115:  29%|\u2588\u2588\u2589       | 421/1460 [00:00&lt;00:00, 4202.43it/s]</pre> <pre>\rSIR Model  72/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 964/1460 [00:00&lt;00:00, 4920.75it/s]</pre> <pre>\rSIR Model  72/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5033.85it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  73/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  73/115:  28%|\u2588\u2588\u258a       | 405/1460 [00:00&lt;00:00, 4048.63it/s]</pre> <pre>\rSIR Model  73/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 940/1460 [00:00&lt;00:00, 4809.44it/s]</pre> <pre>\rSIR Model  73/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4891.95it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  74/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  74/115:  25%|\u2588\u2588\u258d       | 358/1460 [00:00&lt;00:00, 3579.17it/s]</pre> <pre>\rSIR Model  74/115:  59%|\u2588\u2588\u2588\u2588\u2588\u258a    | 857/1460 [00:00&lt;00:00, 4404.72it/s]</pre> <pre>\rSIR Model  74/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1355/1460 [00:00&lt;00:00, 4666.00it/s]</pre> <pre>\rSIR Model  74/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4527.43it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  75/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  75/115:  24%|\u2588\u2588\u258d       | 356/1460 [00:00&lt;00:00, 3555.49it/s]</pre> <pre>\rSIR Model  75/115:  51%|\u2588\u2588\u2588\u2588\u2588     | 746/1460 [00:00&lt;00:00, 3753.42it/s]</pre> <pre>\rSIR Model  75/115:  78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 1145/1460 [00:00&lt;00:00, 3859.62it/s]</pre> <pre>\rSIR Model  75/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3849.29it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  76/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  76/115:  31%|\u2588\u2588\u2588       | 446/1460 [00:00&lt;00:00, 4455.97it/s]</pre> <pre>\rSIR Model  76/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1014/1460 [00:00&lt;00:00, 5171.99it/s]</pre> <pre>\rSIR Model  76/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5195.39it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  77/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  77/115:  30%|\u2588\u2588\u2589       | 433/1460 [00:00&lt;00:00, 4324.00it/s]</pre> <pre>\rSIR Model  77/115:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 866/1460 [00:00&lt;00:00, 3267.70it/s]</pre> <pre>\rSIR Model  77/115:  98%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a| 1424/1460 [00:00&lt;00:00, 4163.50it/s]</pre> <pre>\rSIR Model  77/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4020.81it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  78/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  78/115:  29%|\u2588\u2588\u2589       | 421/1460 [00:00&lt;00:00, 4205.43it/s]</pre> <pre>\rSIR Model  78/115:  66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 970/1460 [00:00&lt;00:00, 4960.51it/s]</pre> <pre>\rSIR Model  78/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5016.73it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  79/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  79/115:  26%|\u2588\u2588\u258c       | 378/1460 [00:00&lt;00:00, 3778.26it/s]</pre> <pre>\rSIR Model  79/115:  60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 881/1460 [00:00&lt;00:00, 4511.66it/s]</pre> <pre>\rSIR Model  79/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1383/1460 [00:00&lt;00:00, 4740.55it/s]</pre> <pre>\rSIR Model  79/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4610.91it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  80/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  80/115:  24%|\u2588\u2588\u258d       | 356/1460 [00:00&lt;00:00, 3556.59it/s]</pre> <pre>\rSIR Model  80/115:  52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 760/1460 [00:00&lt;00:00, 3840.12it/s]</pre> <pre>\rSIR Model  80/115:  80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 1170/1460 [00:00&lt;00:00, 3957.96it/s]</pre> <pre>\rSIR Model  80/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 3937.24it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  81/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  81/115:  31%|\u2588\u2588\u2588       | 455/1460 [00:00&lt;00:00, 4544.44it/s]</pre> <pre>\rSIR Model  81/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1022/1460 [00:00&lt;00:00, 5202.55it/s]</pre> <pre>\rSIR Model  81/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5249.57it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  82/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  82/115:  30%|\u2588\u2588\u2588       | 444/1460 [00:00&lt;00:00, 4436.97it/s]</pre> <pre>\rSIR Model  82/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1007/1460 [00:00&lt;00:00, 5137.81it/s]</pre> <pre>\rSIR Model  82/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5202.08it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  83/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  83/115:  30%|\u2588\u2588\u2589       | 432/1460 [00:00&lt;00:00, 4316.53it/s]</pre> <pre>\rSIR Model  83/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 977/1460 [00:00&lt;00:00, 4977.87it/s]</pre> <pre>\rSIR Model  83/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5024.46it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  84/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  84/115:  27%|\u2588\u2588\u258b       | 401/1460 [00:00&lt;00:00, 4002.52it/s]</pre> <pre>\rSIR Model  84/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 899/1460 [00:00&lt;00:00, 4570.10it/s]</pre> <pre>\rSIR Model  84/115:  95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1388/1460 [00:00&lt;00:00, 4714.71it/s]</pre> <pre>\rSIR Model  84/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4075.11it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  85/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  85/115:  25%|\u2588\u2588\u258c       | 368/1460 [00:00&lt;00:00, 3678.97it/s]</pre> <pre>\rSIR Model  85/115:  55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 808/1460 [00:00&lt;00:00, 4101.55it/s]</pre> <pre>\rSIR Model  85/115:  86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1252/1460 [00:00&lt;00:00, 4252.05it/s]</pre> <pre>\rSIR Model  85/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4180.85it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  86/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  86/115:  32%|\u2588\u2588\u2588\u258f      | 469/1460 [00:00&lt;00:00, 4685.06it/s]</pre> <pre>\rSIR Model  86/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1025/1460 [00:00&lt;00:00, 5194.80it/s]</pre> <pre>\rSIR Model  86/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5250.99it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  87/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  87/115:  31%|\u2588\u2588\u2588       | 456/1460 [00:00&lt;00:00, 4553.25it/s]</pre> <pre>\rSIR Model  87/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1017/1460 [00:00&lt;00:00, 5173.43it/s]</pre> <pre>\rSIR Model  87/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5221.92it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  88/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  88/115:  31%|\u2588\u2588\u2588       | 448/1460 [00:00&lt;00:00, 4478.55it/s]</pre> <pre>\rSIR Model  88/115:  68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 999/1460 [00:00&lt;00:00, 5080.08it/s]</pre> <pre>\rSIR Model  88/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5163.94it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  89/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  89/115:  28%|\u2588\u2588\u258a       | 412/1460 [00:00&lt;00:00, 4117.09it/s]</pre> <pre>\rSIR Model  89/115:  64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 941/1460 [00:00&lt;00:00, 4802.64it/s]</pre> <pre>\rSIR Model  89/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4900.08it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  90/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  90/115:  26%|\u2588\u2588\u258b       | 386/1460 [00:00&lt;00:00, 3857.41it/s]</pre> <pre>\rSIR Model  90/115:  58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 843/1460 [00:00&lt;00:00, 4272.91it/s]</pre> <pre>\rSIR Model  90/115:  89%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589 | 1301/1460 [00:00&lt;00:00, 4409.32it/s]</pre> <pre>\rSIR Model  90/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4344.56it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  91/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  91/115:  32%|\u2588\u2588\u2588\u258f      | 468/1460 [00:00&lt;00:00, 4674.32it/s]</pre> <pre>\rSIR Model  91/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1040/1460 [00:00&lt;00:00, 5287.37it/s]</pre> <pre>\rSIR Model  91/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5338.44it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  92/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  92/115:  32%|\u2588\u2588\u2588\u258f      | 463/1460 [00:00&lt;00:00, 4625.00it/s]</pre> <pre>\rSIR Model  92/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1025/1460 [00:00&lt;00:00, 5206.06it/s]</pre> <pre>\rSIR Model  92/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5259.76it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  93/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  93/115:  31%|\u2588\u2588\u2588       | 454/1460 [00:00&lt;00:00, 4533.27it/s]</pre> <pre>\rSIR Model  93/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1021/1460 [00:00&lt;00:00, 5196.65it/s]</pre> <pre>\rSIR Model  93/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5255.09it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  94/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  94/115:  29%|\u2588\u2588\u2589       | 430/1460 [00:00&lt;00:00, 4298.59it/s]</pre> <pre>\rSIR Model  94/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 972/1460 [00:00&lt;00:00, 4955.03it/s]</pre> <pre>\rSIR Model  94/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5019.74it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  95/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  95/115:  27%|\u2588\u2588\u258b       | 397/1460 [00:00&lt;00:00, 3969.20it/s]</pre> <pre>\rSIR Model  95/115:  59%|\u2588\u2588\u2588\u2588\u2588\u2589    | 863/1460 [00:00&lt;00:00, 4372.57it/s]</pre> <pre>\rSIR Model  95/115:  91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1326/1460 [00:00&lt;00:00, 4488.45it/s]</pre> <pre>\rSIR Model  95/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4422.94it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  96/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  96/115:  32%|\u2588\u2588\u2588\u258f      | 464/1460 [00:00&lt;00:00, 4633.50it/s]</pre> <pre>\rSIR Model  96/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1026/1460 [00:00&lt;00:00, 5209.48it/s]</pre> <pre>\rSIR Model  96/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5259.89it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  97/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  97/115:  32%|\u2588\u2588\u2588\u258f      | 465/1460 [00:00&lt;00:00, 4647.59it/s]</pre> <pre>\rSIR Model  97/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1028/1460 [00:00&lt;00:00, 5222.27it/s]</pre> <pre>\rSIR Model  97/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5196.73it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  98/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  98/115:  32%|\u2588\u2588\u2588\u258f      | 463/1460 [00:00&lt;00:00, 4623.27it/s]</pre> <pre>\rSIR Model  98/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1024/1460 [00:00&lt;00:00, 5199.97it/s]</pre> <pre>\rSIR Model  98/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5157.26it/s]</pre> <pre>\n</pre> <pre>\rSIR Model  99/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model  99/115:  30%|\u2588\u2588\u2588       | 439/1460 [00:00&lt;00:00, 4389.61it/s]</pre> <pre>\rSIR Model  99/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 975/1460 [00:00&lt;00:00, 4958.95it/s]</pre> <pre>\rSIR Model  99/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5032.53it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 100/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 100/115:  28%|\u2588\u2588\u258a       | 410/1460 [00:00&lt;00:00, 4095.32it/s]</pre> <pre>\rSIR Model 100/115:  61%|\u2588\u2588\u2588\u2588\u2588\u2588    | 887/1460 [00:00&lt;00:00, 4488.80it/s]</pre> <pre>\rSIR Model 100/115:  93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1363/1460 [00:00&lt;00:00, 4609.89it/s]</pre> <pre>\rSIR Model 100/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4537.27it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 101/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 101/115:  33%|\u2588\u2588\u2588\u258e      | 480/1460 [00:00&lt;00:00, 4795.28it/s]</pre> <pre>\rSIR Model 101/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1046/1460 [00:00&lt;00:00, 5303.54it/s]</pre> <pre>\rSIR Model 101/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5340.34it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 102/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 102/115:  32%|\u2588\u2588\u2588\u258f      | 474/1460 [00:00&lt;00:00, 4737.05it/s]</pre> <pre>\rSIR Model 102/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1035/1460 [00:00&lt;00:00, 5246.45it/s]</pre> <pre>\rSIR Model 102/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5295.25it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 103/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 103/115:  31%|\u2588\u2588\u2588\u258f      | 459/1460 [00:00&lt;00:00, 4583.82it/s]</pre> <pre>\rSIR Model 103/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 977/1460 [00:00&lt;00:00, 4930.16it/s]</pre> <pre>\rSIR Model 103/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5086.15it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 104/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 104/115:  31%|\u2588\u2588\u2588       | 446/1460 [00:00&lt;00:00, 4453.34it/s]</pre> <pre>\rSIR Model 104/115:  67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 979/1460 [00:00&lt;00:00, 4966.79it/s]</pre> <pre>\rSIR Model 104/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5067.55it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 105/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 105/115:  29%|\u2588\u2588\u2589       | 420/1460 [00:00&lt;00:00, 4193.52it/s]</pre> <pre>\rSIR Model 105/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 907/1460 [00:00&lt;00:00, 4585.89it/s]</pre> <pre>\rSIR Model 105/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1400/1460 [00:00&lt;00:00, 4738.24it/s]</pre> <pre>\rSIR Model 105/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4646.86it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 106/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 106/115:  33%|\u2588\u2588\u2588\u258e      | 483/1460 [00:00&lt;00:00, 4829.26it/s]</pre> <pre>\rSIR Model 106/115:  72%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1044/1460 [00:00&lt;00:00, 5288.14it/s]</pre> <pre>\rSIR Model 106/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5351.38it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 107/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 107/115:  32%|\u2588\u2588\u2588\u258f      | 470/1460 [00:00&lt;00:00, 4694.03it/s]</pre> <pre>\rSIR Model 107/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1031/1460 [00:00&lt;00:00, 5232.27it/s]</pre> <pre>\rSIR Model 107/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5301.23it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 108/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 108/115:  31%|\u2588\u2588\u2588       | 447/1460 [00:00&lt;00:00, 4467.25it/s]</pre> <pre>\rSIR Model 108/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1010/1460 [00:00&lt;00:00, 5149.87it/s]</pre> <pre>\rSIR Model 108/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5184.55it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 109/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 109/115:  31%|\u2588\u2588\u2588       | 453/1460 [00:00&lt;00:00, 4524.51it/s]</pre> <pre>\rSIR Model 109/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1004/1460 [00:00&lt;00:00, 5097.24it/s]</pre> <pre>\rSIR Model 109/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5133.92it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 110/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 110/115:  29%|\u2588\u2588\u258a       | 419/1460 [00:00&lt;00:00, 4186.12it/s]</pre> <pre>\rSIR Model 110/115:  62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 908/1460 [00:00&lt;00:00, 4597.29it/s]</pre> <pre>\rSIR Model 110/115:  96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1400/1460 [00:00&lt;00:00, 4741.87it/s]</pre> <pre>\rSIR Model 110/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4656.74it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 111/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 111/115:  33%|\u2588\u2588\u2588\u258e      | 476/1460 [00:00&lt;00:00, 4756.21it/s]</pre> <pre>\rSIR Model 111/115:  71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f  | 1041/1460 [00:00&lt;00:00, 5276.69it/s]</pre> <pre>\rSIR Model 111/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5330.14it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 112/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 112/115:  32%|\u2588\u2588\u2588\u258f      | 469/1460 [00:00&lt;00:00, 4682.65it/s]</pre> <pre>\rSIR Model 112/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1028/1460 [00:00&lt;00:00, 5209.68it/s]</pre> <pre>\rSIR Model 112/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5267.09it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 113/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 113/115:  32%|\u2588\u2588\u2588\u258f      | 461/1460 [00:00&lt;00:00, 4605.34it/s]</pre> <pre>\rSIR Model 113/115:  70%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1017/1460 [00:00&lt;00:00, 5163.57it/s]</pre> <pre>\rSIR Model 113/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5224.51it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 114/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 114/115:  31%|\u2588\u2588\u2588\u258f      | 458/1460 [00:00&lt;00:00, 4576.79it/s]</pre> <pre>\rSIR Model 114/115:  69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1007/1460 [00:00&lt;00:00, 5111.32it/s]</pre> <pre>\rSIR Model 114/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 5147.70it/s]</pre> <pre>\n</pre> <pre>\rSIR Model 115/115:   0%|          | 0/1460 [00:00&lt;?, ?it/s]</pre> <pre>\rSIR Model 115/115:  30%|\u2588\u2588\u2588       | 441/1460 [00:00&lt;00:00, 4409.14it/s]</pre> <pre>\rSIR Model 115/115:  63%|\u2588\u2588\u2588\u2588\u2588\u2588\u258e   | 920/1460 [00:00&lt;00:00, 4630.80it/s]</pre> <pre>\rSIR Model 115/115:  97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1422/1460 [00:00&lt;00:00, 4807.12it/s]</pre> <pre>\rSIR Model 115/115: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1460/1460 [00:00&lt;00:00, 4724.70it/s]</pre> <pre>\n</pre> In\u00a0[8]: Copied! <pre>plt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n    plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_exp\"], color=color)\n    plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_obs\"], \".\", label=\"_nolegend_\", color=color)\nplt.xlabel(\"$R_{0}$\")\nplt.ylabel(\"$I(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"I Expected and Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_exp\"], color=color)\n    plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_obs\"], \".\", label=\"_nolegend_\", color=color)\nplt.xlabel(\"$R_{0}$\")\nplt.ylabel(\"$S(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"S Expected and Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(\n        output[condition][\"R0\"] * S0,\n        (output[condition][\"I_inf_exp\"] - output[condition][\"I_inf_obs\"]),\n        \".\",\n        label=f\"Observed S0={S0}\",\n        color=color,\n    )\nplt.xlabel(\"$R_{eff}(t=0)$\")\nplt.ylabel(\"$I_{exp}(t \\\\rightarrow {\\\\infty}) - I_{obs}(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"I Expected - Observed v R0\")\n\nplt.figure()\ncolors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])\n\nfor S0 in S0s:\n    condition = output[\"S0\"] == S0\n    color = next(colors)\n\n    plt.plot(\n        output[condition][\"R0\"] * S0,\n        (output[condition][\"S_inf_exp\"] - output[condition][\"S_inf_obs\"]),\n        \".\",\n        label=f\"Observed S0={S0}\",\n        color=color,\n    )\nplt.xlabel(\"$R_{eff}(t=0)$\")\nplt.ylabel(\"$S_{exp}(t \\\\rightarrow {\\\\infty}) - S_{obs}(t \\\\rightarrow {\\\\infty})$\")\nplt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"])\nplt.title(\"S Expected - Observed v R0\")\n</pre> plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)     plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_exp\"], color=color)     plt.plot(output[condition][\"R0\"], output[condition][\"I_inf_obs\"], \".\", label=\"_nolegend_\", color=color) plt.xlabel(\"$R_{0}$\") plt.ylabel(\"$I(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"I Expected and Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_exp\"], color=color)     plt.plot(output[condition][\"R0\"], output[condition][\"S_inf_obs\"], \".\", label=\"_nolegend_\", color=color) plt.xlabel(\"$R_{0}$\") plt.ylabel(\"$S(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"S Expected and Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"]) for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(         output[condition][\"R0\"] * S0,         (output[condition][\"I_inf_exp\"] - output[condition][\"I_inf_obs\"]),         \".\",         label=f\"Observed S0={S0}\",         color=color,     ) plt.xlabel(\"$R_{eff}(t=0)$\") plt.ylabel(\"$I_{exp}(t \\\\rightarrow {\\\\infty}) - I_{obs}(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"I Expected - Observed v R0\")  plt.figure() colors = itertools.cycle([\"b\", \"g\", \"r\", \"c\", \"m\", \"y\", \"k\"])  for S0 in S0s:     condition = output[\"S0\"] == S0     color = next(colors)      plt.plot(         output[condition][\"R0\"] * S0,         (output[condition][\"S_inf_exp\"] - output[condition][\"S_inf_obs\"]),         \".\",         label=f\"Observed S0={S0}\",         color=color,     ) plt.xlabel(\"$R_{eff}(t=0)$\") plt.ylabel(\"$S_{exp}(t \\\\rightarrow {\\\\infty}) - S_{obs}(t \\\\rightarrow {\\\\infty})$\") plt.legend([\"$S(0) = 1.0$\", \"$S(0)= 0.8$\", \"$S(0) = 0.6$\", \"$S(0) = 0.4$\", \"$S(0) = 0.2$\"]) plt.title(\"S Expected - Observed v R0\") Out[8]: <pre>Text(0.5, 1.0, 'S Expected - Observed v R0')</pre> In\u00a0[9]: Copied! <pre>print(\n    \"S expected - S observed &lt; 0.05: \" + str((np.isclose(output[\"S_inf_exp\"], output[\"S_inf_obs\"], atol=0.05)).all())\n)  # Account for 1 timestep offset here\nprint(\n    \"I expected - I observed &lt; 0.05: \" + str((np.isclose(output[\"I_inf_exp\"], output[\"I_inf_obs\"], atol=0.05)).all())\n)  # Account for 1 timestep offset here\n</pre> print(     \"S expected - S observed &lt; 0.05: \" + str((np.isclose(output[\"S_inf_exp\"], output[\"S_inf_obs\"], atol=0.05)).all()) )  # Account for 1 timestep offset here print(     \"I expected - I observed &lt; 0.05: \" + str((np.isclose(output[\"I_inf_exp\"], output[\"I_inf_obs\"], atol=0.05)).all()) )  # Account for 1 timestep offset here <pre>S expected - S observed &lt; 0.05: True\nI expected - I observed &lt; 0.05: True\n</pre>"},{"location":"notebooks/04_SIR_nobirths_outbreak_size/#outbreak-size-in-the-sir-model-kermack-mckendrick-relation","title":"Outbreak size in the SIR model (Kermack-McKendrick relation)\u00b6","text":"<p>We move next to the Susceptible-Infected-Recovered model, the first of these canonical test models that actually provides a decent, coarse, representation of many vaccine-preventable diseases that we are interested in.  This test will explore the size of acute outbreaks; in this situation, the role of demography is pretty small and serves only to complicate the analysis, so we will work without demography.  The model contains three agent states and two transitions: susceptible -&gt; infected -&gt; recovered, with the recovered state assumed to be lifelong.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} \\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I \\\\  \\dot{R} = \\gamma I $$</p> <p>As before, we discretize this as: $$ \\Delta I = Bin(S_t, 1-exp^{-\\beta \\Delta t \\frac{I}{N}}) \\\\ \\Delta R = Bin(I_t, 1-exp^{-\\gamma \\Delta t}) \\\\ S_{t+1} = S_t - \\Delta I_t \\\\ I_{t+1} = I_t + \\Delta I_t -\\Delta R_t \\\\ R_{t+1} = R_t + \\Delta R_t $$</p> <p>Note: As written, the dwell time of individuals in the infectious state is strictly exponentially distributed.  Without introducing substantially more complexity (delay-differential or integro-differential equations, the Generalized Linear Chain Trick), this is a general feature of ODE systems.  In agent-based models, however, the distribution of the dwell time in the Infectious state can be chosen from an arbitrary distribution, in which case the discretization as written no longer holds.  For the purposes of comparability with analytic results, we choose to draw from an exponential distribution in the below.</p> <p>Analysis of the SIR system can be found in other sources, and closed-form analytic solutions to the system dyanmics are elusive and generally too complicated to provide much insight - more generally useful are results about the equilibrium states as  $t \\rightarrow \\infty$.  We'll focus here on one of these, the size of an outbreak introduced into a closed population, given by the implicit formula</p> <p>$$  Z =  \\begin{cases}     S_0(1-e^{-R_0[Z+I_0]}), &amp; \\text{if} \\:\\:  R_0S(0)&gt;1 \\\\     0, &amp;\\text{if} \\:\\:  R_0S(0)&lt;=1 \\end{cases} \\\\ Z = \\sum_{t=0}^\\infty I(t) = S_0 - S_\\infty \\\\ R_0 = \\frac{\\beta}{\\gamma} $$</p> <p>One can obtain an approximate analytic solution for the outbreak curve itself, shown below. However, the approximation employed in deriving this is that $R_0 R(t)$ is small, which likely to be violated during the peak of the outbreak.  And it's immediately clear upon looking at this formula that it doesn't exactly offer some intuitive interpretation for the dynamics.</p> <p>$$ \\frac{dR}{dt} = \\frac{\\gamma \\alpha^2}{2S(0)R_0^2}\\text{sech}^2\\left(\\frac{\\alpha \\gamma t}{2} - \\phi\\right) \\\\ \\phi = \\text{tanh}^{-1}\\left(\\frac{S(0)(R_0-1)}{\\alpha}\\right) \\\\ \\alpha = \\sqrt{S(0)^2(R_0-1)^2 + 2S(0)I(0)R_0^2} $$</p> <p>This notebook will focus on testing the final size prediction and for now, ignore testing the approximate formula for the whole outbreak curve.</p>"},{"location":"notebooks/04_SIR_nobirths_outbreak_size/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Then we construct a single-patch LASER model with four components: the states <code>Susceptible</code>, <code>Recovered</code>, and <code>Infectious</code>, and the <code>Transmission</code> process.  The <code>Susceptible</code> and <code>Transmission</code> components look largely the same as the SI and SIS models.  The <code>Infectious</code> component now moves people into a <code>Recovered</code> state when <code>itimer</code> expires, instead of sending them back to <code>Susceptible</code> as in the SIS model.  As there are no vital dynamics in this model, the <code>Recovered</code> state is a terminal state - these agents have no further dynamics and participate only by being part of the total population denominator in the <code>Transmission</code> component.</p>"},{"location":"notebooks/04_SIR_nobirths_outbreak_size/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.  We can check that $S_t = N_t - \\sum{\\Delta I_t}$, that $R_t = \\sum{\\Delta R_t}$, and the total population is constant and equal to $S_t + I_t + R_t$ for all timesteps.</p>"},{"location":"notebooks/04_SIR_nobirths_outbreak_size/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will loop over a set of $(R_0, S(0))$ pairs and confirm that the final outbreak size matches the expectation given in the equation above.  As this is a stochastic model, the main concern is that when $R_0S(0)$ is close to one, the outbreak may fail to take off or truncate at a slightly smaller final size.</p>"},{"location":"notebooks/04_SIR_nobirths_outbreak_size/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>Check that the expected relationships between susceptible, infected, recovered, and total population hold.</p>"},{"location":"notebooks/04_SIR_nobirths_outbreak_size/#scientific-test","title":"Scientific test\u00b6","text":"<p>We will now loop over a few values of R-zero and initial susceptibility, and compare the size of the outbreak against the expected size given by the equation in the introduction</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/","title":"Average age at infection in the SIR model","text":"In\u00a0[1]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.optimize import curve_fit\nfrom scipy.stats import expon\nfrom scipy.stats import kstest\nfrom sklearn.metrics import mean_squared_error\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.optimize import curve_fit from scipy.stats import expon from scipy.stats import kstest from sklearn.metrics import mean_squared_error  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>np.__version__='2.3.4'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> In\u00a0[2]: Copied! <pre>from functools import partial\n\nimport laser.core.distributions as dists\nfrom laser.core.demographics import AliasedDistribution\nfrom laser.core.demographics import KaplanMeierEstimator\nfrom laser.generic.models import SIR\nfrom laser.generic.newutils import ValuesMap\nfrom laser.generic.newutils import grid\n\nprint(\"done\")\n</pre> from functools import partial  import laser.core.distributions as dists from laser.core.demographics import AliasedDistribution from laser.core.demographics import KaplanMeierEstimator from laser.generic.models import SIR from laser.generic.newutils import ValuesMap from laser.generic.newutils import grid  print(\"done\") <pre>done\n</pre> In\u00a0[3]: Copied! <pre># scenario = pd.DataFrame(data=[[\"homenode\", 1e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])\npop=1e6\nscenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=-(122+(19+(59/60))/60), origin_y=47+(36+(35/60))/60)\ninitial_infected = 1\nscenario[\"S\"] = scenario.population - initial_infected\nscenario[\"I\"] = initial_infected\nscenario[\"R\"] = 0\nparameters = PropertySet(\n    # {\"seed\": 4, \"nticks\": 18250, \"verbose\": True, \"beta\": 0.1, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}\n    {\"seed\": 4, \"nticks\": 365*3, \"verbose\": True, \"beta\": 2/60, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}\n)\n\nprint(\"done\")\n</pre> # scenario = pd.DataFrame(data=[[\"homenode\", 1e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"]) pop=1e6 scenario = grid(M=1, N=1, node_size_km=10, population_fn=lambda x,y: pop, origin_x=-(122+(19+(59/60))/60), origin_y=47+(36+(35/60))/60) initial_infected = 1 scenario[\"S\"] = scenario.population - initial_infected scenario[\"I\"] = initial_infected scenario[\"R\"] = 0 parameters = PropertySet(     # {\"seed\": 4, \"nticks\": 18250, \"verbose\": True, \"beta\": 0.1, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3}     {\"seed\": 4, \"nticks\": 365*3, \"verbose\": True, \"beta\": 2/60, \"inf_mean\": 60, \"cbr\": 90, \"importation_period\": 180, \"importation_count\": 3} )  print(\"done\") <pre>done\n</pre> In\u00a0[4]: Copied! <pre>class Importation:\n    def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):\n        self.model = model\n        self.infdurdist = infdurdist\n        self.infdurmin = infdurmin\n        self.period = period\n        self.count = count\n\n        self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)\n\n        return\n    \n    def step(self, tick: int) -&gt; None:\n        if tick &gt; 0 and tick % self.period == 0:\n            i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]\n            if len(i_susceptible) &gt; 0:\n                count = min(self.count, len(i_susceptible))\n                i_infect = np.random.choice(i_susceptible, size=count, replace=False)\n                self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value\n                samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))\n                samples = np.round(samples)\n                samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)\n                self.model.people.itimer[i_infect] = samples\n                inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)\n                self.model.nodes.S[tick + 1] -= inf_by_node\n                self.model.nodes.I[tick + 1] += inf_by_node\n                self.model.nodes.imports[tick] = inf_by_node\n            # else:\n            #     print(f\"No susceptibles to infect at tick {tick}\")\n\n        return\n\nprint(\"done\")\n</pre> class Importation:     def __init__(self, model, infdurdist, infdurmin: int =1, period: int = 180, count: int = 3):         self.model = model         self.infdurdist = infdurdist         self.infdurmin = infdurmin         self.period = period         self.count = count          self.model.nodes.add_vector_property(\"imports\", model.params.nticks + 1, dtype=np.uint32, default=0)          return          def step(self, tick: int) -&gt; None:         if tick &gt; 0 and tick % self.period == 0:             i_susceptible = np.nonzero(self.model.people.state == SIR.State.SUSCEPTIBLE.value)[0]             if len(i_susceptible) &gt; 0:                 count = min(self.count, len(i_susceptible))                 i_infect = np.random.choice(i_susceptible, size=count, replace=False)                 self.model.people.state[i_infect] = SIR.State.INFECTIOUS.value                 samples = dists.sample_floats(self.infdurdist, np.zeros(count, np.float32))                 samples = np.round(samples)                 samples = np.maximum(samples, self.infdurmin).astype(self.model.people.itimer.dtype)                 self.model.people.itimer[i_infect] = samples                 inf_by_node = np.bincount(self.model.people.nodeid[i_infect], minlength=len(self.model.nodes)).astype(self.model.nodes.S.dtype)                 self.model.nodes.S[tick + 1] -= inf_by_node                 self.model.nodes.I[tick + 1] += inf_by_node                 self.model.nodes.imports[tick] = inf_by_node             # else:             #     print(f\"No susceptibles to infect at tick {tick}\")          return  print(\"done\") <pre>done\n</pre> <p>We will need a modified Transmission component which tracks the date of infection (doi) for individuals so we can calculate age at infection.</p> In\u00a0[5]: Copied! <pre>import numba as nb\nfrom laser.generic.models.SIR import State\n\nclass TransmissionWithDOI(SIR.Transmission):\n    def __init__(self, model, infdurdist, infdurmin: int =1):\n        super().__init__(model, infdurdist, infdurmin)\n        self.model.people.add_vector_property(\"doi\", model.params.nticks + 1, dtype=np.int16, default=0)\n        return\n\n    @staticmethod\n    @nb.njit(\n        nogil=True,\n        parallel=True,\n        cache=True,\n    )\n    def nb_transmission_doi(states, nodeids, ft, inf_by_node, itimers, infdurdist, infdurmin, tick, dois):\n        for i in nb.prange(len(states)):\n            if states[i] == State.SUSCEPTIBLE.value:\n                # Check for infection\n                draw = np.random.rand()\n                nid = nodeids[i]\n                if draw &lt; ft[nid]:\n                    states[i] = State.INFECTIOUS.value\n                    dois[i] = tick  # Set date of infection\n                    itimers[i] = np.maximum(np.round(infdurdist()), infdurmin)  # Set the infection timer\n                    inf_by_node[nb.get_thread_id(), nid] += 1\n\n        return\n\n    def step(self, tick: int) -&gt; None:\n        ft = self.model.nodes.forces[tick]\n\n        N = self.model.nodes.S[tick] + (I := self.model.nodes.I[tick])  # noqa: E741\n        # Shouldn't be any exposed (E), because this is an S-&gt;I model\n        # Might have R\n        if hasattr(self.model.nodes, \"R\"):\n            N += self.model.nodes.R[tick]\n\n        ft[:] = self.model.params.beta * I / N\n        transfer = ft[:, None] * self.model.network\n        ft += transfer.sum(axis=0)\n        ft -= transfer.sum(axis=1)\n        ft = -np.expm1(-ft)  # Convert to probability of infection\n\n        inf_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.uint32)\n        self.nb_transmission_doi(\n            self.model.people.state, self.model.people.nodeid, ft, inf_by_node, self.model.people.itimer, self.infdurdist, self.infdurmin,\n            tick, self.model.people.doi # DOI specific parameters\n        )\n        inf_by_node = inf_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads\n\n        # state(t+1) = state(t) + \u2206state(t)\n        self.model.nodes.S[tick + 1] -= inf_by_node\n        self.model.nodes.I[tick + 1] += inf_by_node\n        # Record today's \u2206\n        self.model.nodes.incidence[tick] = inf_by_node\n\n        return\n</pre> import numba as nb from laser.generic.models.SIR import State  class TransmissionWithDOI(SIR.Transmission):     def __init__(self, model, infdurdist, infdurmin: int =1):         super().__init__(model, infdurdist, infdurmin)         self.model.people.add_vector_property(\"doi\", model.params.nticks + 1, dtype=np.int16, default=0)         return      @staticmethod     @nb.njit(         nogil=True,         parallel=True,         cache=True,     )     def nb_transmission_doi(states, nodeids, ft, inf_by_node, itimers, infdurdist, infdurmin, tick, dois):         for i in nb.prange(len(states)):             if states[i] == State.SUSCEPTIBLE.value:                 # Check for infection                 draw = np.random.rand()                 nid = nodeids[i]                 if draw &lt; ft[nid]:                     states[i] = State.INFECTIOUS.value                     dois[i] = tick  # Set date of infection                     itimers[i] = np.maximum(np.round(infdurdist()), infdurmin)  # Set the infection timer                     inf_by_node[nb.get_thread_id(), nid] += 1          return      def step(self, tick: int) -&gt; None:         ft = self.model.nodes.forces[tick]          N = self.model.nodes.S[tick] + (I := self.model.nodes.I[tick])  # noqa: E741         # Shouldn't be any exposed (E), because this is an S-&gt;I model         # Might have R         if hasattr(self.model.nodes, \"R\"):             N += self.model.nodes.R[tick]          ft[:] = self.model.params.beta * I / N         transfer = ft[:, None] * self.model.network         ft += transfer.sum(axis=0)         ft -= transfer.sum(axis=1)         ft = -np.expm1(-ft)  # Convert to probability of infection          inf_by_node = np.zeros((nb.get_num_threads(), self.model.nodes.count), dtype=np.uint32)         self.nb_transmission_doi(             self.model.people.state, self.model.people.nodeid, ft, inf_by_node, self.model.people.itimer, self.infdurdist, self.infdurmin,             tick, self.model.people.doi # DOI specific parameters         )         inf_by_node = inf_by_node.sum(axis=0).astype(self.model.nodes.S.dtype)  # Sum over threads          # state(t+1) = state(t) + \u2206state(t)         self.model.nodes.S[tick + 1] -= inf_by_node         self.model.nodes.I[tick + 1] += inf_by_node         # Record today's \u2206         self.model.nodes.incidence[tick] = inf_by_node          return  In\u00a0[6]: Copied! <pre>birthrate_map = ValuesMap.from_scalar(0, nnodes=len(scenario), nsteps=parameters.nticks)\nmodel = SIR.Model(scenario, parameters, birthrates=birthrate_map.values)\ninfdurdist = dists.normal(loc=parameters.inf_mean, scale=2)\npyramid = AliasedDistribution(np.full(89, 1_000))\nsurvival = KaplanMeierEstimator(np.full(89, 1_000).cumsum())\nmodel.components = [\n    SIR.Susceptible(model),\n    SIR.Recovered(model),\n    SIR.Infectious(model, infdurdist),\n    Importation(model, infdurdist),\n    # SIR.Transmission(model, infdurdist),\n    TransmissionWithDOI(model, infdurdist),\n    SIR.VitalDynamics(model, birthrates=birthrate_map.values, pyramid=pyramid, survival=survival)\n]\n\nmodel.run()\nplt.plot(model.nodes.S, color=\"blue\")\nplt.plot(model.nodes.I, color=\"red\")\nplt.plot(model.nodes.R, color=\"green\")\nplt.legend([\"S\", \"I\", \"R\"])\nplt.show()\n</pre> birthrate_map = ValuesMap.from_scalar(0, nnodes=len(scenario), nsteps=parameters.nticks) model = SIR.Model(scenario, parameters, birthrates=birthrate_map.values) infdurdist = dists.normal(loc=parameters.inf_mean, scale=2) pyramid = AliasedDistribution(np.full(89, 1_000)) survival = KaplanMeierEstimator(np.full(89, 1_000).cumsum()) model.components = [     SIR.Susceptible(model),     SIR.Recovered(model),     SIR.Infectious(model, infdurdist),     Importation(model, infdurdist),     # SIR.Transmission(model, infdurdist),     TransmissionWithDOI(model, infdurdist),     SIR.VitalDynamics(model, birthrates=birthrate_map.values, pyramid=pyramid, survival=survival) ]  model.run() plt.plot(model.nodes.S, color=\"blue\") plt.plot(model.nodes.I, color=\"red\") plt.plot(model.nodes.R, color=\"green\") plt.legend([\"S\", \"I\", \"R\"]) plt.show() <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[6], line 2\n      1 birthrate_map = ValuesMap.from_scalar(0, nnodes=len(scenario), nsteps=parameters.nticks)\n----&gt; 2 model = SIR.Model(scenario, parameters, birthrates=birthrate_map.values)\n      3 infdurdist = dists.normal(loc=parameters.inf_mean, scale=2)\n      4 pyramid = AliasedDistribution(np.full(89, 1_000))\n\nAttributeError: module 'laser.generic.models.SIR' has no attribute 'Model'</pre> In\u00a0[7]: Copied! <pre>cases = np.squeeze(model.nodes.I)\nsusc = np.squeeze(model.nodes.S)\nrec = np.squeeze(model.nodes.R)\ninc = np.squeeze(model.nodes.incidence)\nbirths = np.squeeze(model.nodes.births)\npops = np.squeeze(model.nodes.S + model.nodes.I + model.nodes.R + model.nodes.births)\n\nprint(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all()))\n</pre> cases = np.squeeze(model.nodes.I) susc = np.squeeze(model.nodes.S) rec = np.squeeze(model.nodes.R) inc = np.squeeze(model.nodes.incidence) births = np.squeeze(model.nodes.births) pops = np.squeeze(model.nodes.S + model.nodes.I + model.nodes.R + model.nodes.births)  print(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all())) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 cases = np.squeeze(model.nodes.I)\n      2 susc = np.squeeze(model.nodes.S)\n      3 rec = np.squeeze(model.nodes.R)\n\nNameError: name 'model' is not defined</pre> In\u00a0[8]: Copied! <pre>mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nR0 = model.params.beta / (1 / model.params.inf_mean + mu)\nA = 1 / (R0 * mu) / 365\na = np.arange(0, 15, 100)\n\ndef fit_age_at_infection(model, cutpos=10000):\n    cut = model.population.doi &gt; cutpos\n    data = (model.population.doi[cut] - model.population.dob[cut]) / 365\n    expfit = expon.fit(data)\n    fitqual = kstest(data, expon.cdf, expfit)\n    return data, expfit, fitqual\n\ndata, expfit, fitqual = fit_age_at_infection(model)\n\nplt.hist(data, bins=a, density=True)\nplt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4)\nplt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\")\nplt.xlabel(\"Age at infection (years)\")\nplt.ylabel(\"Density\")\nplt.legend(\n    [\n        f\"Expected exponential distribution - A = {A:.2f} years\",\n        f\"Best fit age of infection, A = {expfit[1]:.2f} years\",\n        \"Ages from simulation\",\n    ]\n)\nplt.show()\nfitqual\n</pre> mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 R0 = model.params.beta / (1 / model.params.inf_mean + mu) A = 1 / (R0 * mu) / 365 a = np.arange(0, 15, 100)  def fit_age_at_infection(model, cutpos=10000):     cut = model.population.doi &gt; cutpos     data = (model.population.doi[cut] - model.population.dob[cut]) / 365     expfit = expon.fit(data)     fitqual = kstest(data, expon.cdf, expfit)     return data, expfit, fitqual  data, expfit, fitqual = fit_age_at_infection(model)  plt.hist(data, bins=a, density=True) plt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4) plt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\") plt.xlabel(\"Age at infection (years)\") plt.ylabel(\"Density\") plt.legend(     [         f\"Expected exponential distribution - A = {A:.2f} years\",         f\"Best fit age of infection, A = {expfit[1]:.2f} years\",         \"Ages from simulation\",     ] ) plt.show() fitqual <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\n      2 R0 = model.params.beta / (1 / model.params.inf_mean + mu)\n      3 A = 1 / (R0 * mu) / 365\n\nNameError: name 'model' is not defined</pre> In\u00a0[9]: Copied! <pre>A2 = 1 / ((R0 - 1) * mu) / 365\n\n\ndef Scurve(x, lam):\n    return np.exp(-x / lam)\n\n\ndef fit_susceptibility_vs_age(model, cutpos=10000):\n    cut = (model.population.susceptibility == 1) &amp; (model.population.dob &gt; cutpos)\n    bins = np.linspace(0, 50, 1200)\n    age_years = (np.max(model.population.dob) - model.population.dob) / 365\n    n1 = np.histogram(age_years, bins=bins)[0]\n    n2 = np.histogram(age_years[cut], bins=bins)[0]\n    n1[n1 == 0] = 1\n    y1 = n2 / n1\n    popt, pcov = curve_fit(Scurve, bins[:-1] + np.mean(np.diff(bins)), y1, p0=2.5)\n    mse = mean_squared_error(y1, Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))\n    return y1, bins, popt, pcov, mse\n\n\ndata, bins, popt, pcov, mse = fit_susceptibility_vs_age(model)\n\n# Plotting is a little more complicated here, want to plot at the bin centers and force y=1 at x=0\nplt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *data], \".\")\nplt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, A2))], lw=4)\nplt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))], \"k--\")\nplt.legend(\n    [\"Simulation output\", f\"Expected exponential distribution - A = {A2:.2f} years\", f\"Best fit age of infection, A = {popt[0]:.2f} years\"]\n)\nplt.xlabel(\"Age (years)\")\nplt.ylabel(\"Fraction of individuals susceptible at age\")\nplt.show()\nprint(\"RMSE = \", np.sqrt(mse))\n</pre> A2 = 1 / ((R0 - 1) * mu) / 365   def Scurve(x, lam):     return np.exp(-x / lam)   def fit_susceptibility_vs_age(model, cutpos=10000):     cut = (model.population.susceptibility == 1) &amp; (model.population.dob &gt; cutpos)     bins = np.linspace(0, 50, 1200)     age_years = (np.max(model.population.dob) - model.population.dob) / 365     n1 = np.histogram(age_years, bins=bins)[0]     n2 = np.histogram(age_years[cut], bins=bins)[0]     n1[n1 == 0] = 1     y1 = n2 / n1     popt, pcov = curve_fit(Scurve, bins[:-1] + np.mean(np.diff(bins)), y1, p0=2.5)     mse = mean_squared_error(y1, Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))     return y1, bins, popt, pcov, mse   data, bins, popt, pcov, mse = fit_susceptibility_vs_age(model)  # Plotting is a little more complicated here, want to plot at the bin centers and force y=1 at x=0 plt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *data], \".\") plt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, A2))], lw=4) plt.plot([0, *bins[:-1] + np.mean(np.diff(bins)) / 2], [1, *(Scurve(bins[:-1] + np.mean(np.diff(bins)) / 2, *popt))], \"k--\") plt.legend(     [\"Simulation output\", f\"Expected exponential distribution - A = {A2:.2f} years\", f\"Best fit age of infection, A = {popt[0]:.2f} years\"] ) plt.xlabel(\"Age (years)\") plt.ylabel(\"Fraction of individuals susceptible at age\") plt.show() print(\"RMSE = \", np.sqrt(mse)) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 A2 = 1 / ((R0 - 1) * mu) / 365\n      4 def Scurve(x, lam):\n      5     return np.exp(-x / lam)\n\nNameError: name 'R0' is not defined</pre> In\u00a0[10]: Copied! <pre># Test that population age distribution is correct\ndef fit_population_age_distribution(model):\n    age_years = (np.max(model.population.dob) - model.population.dob) / 365\n    expfit = expon.fit(age_years)\n    fitqual = kstest(age_years, expon.cdf, expfit)\n    return age_years, expfit, fitqual\n\n\nage_years, expfit, fitqual = fit_population_age_distribution(model)\nmu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nA = 1 / mu / 365\na = np.arange(0, 60, 0.1)\n\nplt.hist(age_years, bins=a, density=True)\nplt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4)\nplt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\")\nplt.xlabel(\"Age at infection (years)\")\nplt.ylabel(\"Density\")\nplt.legend(\n    [f\"Expected exponential distribution - A = {A:.2f} years\", f\"Best fit age of infection, A = {expfit[1]:.2f} years\", \"Simulation output\"]\n)\nplt.show()\nfitqual\n</pre> # Test that population age distribution is correct def fit_population_age_distribution(model):     age_years = (np.max(model.population.dob) - model.population.dob) / 365     expfit = expon.fit(age_years)     fitqual = kstest(age_years, expon.cdf, expfit)     return age_years, expfit, fitqual   age_years, expfit, fitqual = fit_population_age_distribution(model) mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 A = 1 / mu / 365 a = np.arange(0, 60, 0.1)  plt.hist(age_years, bins=a, density=True) plt.plot(a, 1 / A * np.exp(-a / A), \"-\", lw=4) plt.plot(a, expon.pdf(a, scale=expfit[1]), \"k--\") plt.xlabel(\"Age at infection (years)\") plt.ylabel(\"Density\") plt.legend(     [f\"Expected exponential distribution - A = {A:.2f} years\", f\"Best fit age of infection, A = {expfit[1]:.2f} years\", \"Simulation output\"] ) plt.show() fitqual <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 9\n      5     fitqual = kstest(age_years, expon.cdf, expfit)\n      6     return age_years, expfit, fitqual\n----&gt; 9 age_years, expfit, fitqual = fit_population_age_distribution(model)\n     10 mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\n     11 A = 1 / mu / 365\n\nNameError: name 'model' is not defined</pre> In\u00a0[11]: Copied! <pre>%%capture\n\nscenario = pd.DataFrame(data=[[\"homenode\", 3e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])\n\ncbrs = 15 + 85 * np.random.rand(25)\ninf_means = 5 + 45 * np.random.rand(25)\nR0s = 1.5 + 8.5 * np.random.rand(25)\noutput = pd.DataFrame(data={\"cbr\": cbrs, \"inf_mean\": inf_means, \"R0\": R0s})\noutput[\"Average_Iage_observed\"] = np.nan\noutput[\"Average_Iage_expected\"] = np.nan\noutput[\"Average_Sage_observed\"] = np.nan\noutput[\"Average_Sage_expected\"] = np.nan\noutput[\"Average_age_expected\"] = np.nan\noutput[\"Average_age_expected\"] = np.nan\nfor index, row in output.iterrows():\n    parameters = PropertySet(\n        {\n            \"seed\": 2,\n            \"nticks\": 73000,\n            \"verbose\": True,\n            \"beta\": row[\"R0\"] * (mu + 1 / row[\"inf_mean\"]),\n            \"inf_mean\": row[\"inf_mean\"],\n            \"cbr\": row[\"cbr\"],\n            \"importation_period\": 180,\n            \"importation_count\": 3,\n        }\n    )\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Random_Agents,\n    ]\n    set_initial_susceptibility_randomly(model, 1 / row[\"R0\"] + 0.05)\n    seed_infections_randomly(model, ninfections=1)\n    model.run()\n    mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\n    _, expfit, _ = fit_age_at_infection(model, 36500)\n\n    output.loc[index, \"Average_Iage_expected\"] = 1 / (row[\"R0\"] * mu) / 365\n    output.loc[index, \"Average_Iage_observed\"] = expfit[1]\n\n    _, _, popt, _, _ = fit_susceptibility_vs_age(model, 36500)\n    output.loc[index, \"Average_Sage_expected\"] = 1 / ((row[\"R0\"] - 1) * mu) / 365\n    output.loc[index, \"Average_Sage_observed\"] = popt[0]\n\n    _, expfit, _ = fit_population_age_distribution(model)\n    output.loc[index, \"Average_age_expected\"] = 1 / mu / 365\n    output.loc[index, \"Average_age_observed\"] = expfit[1]\n</pre> %%capture  scenario = pd.DataFrame(data=[[\"homenode\", 3e5, \"47\u00b036\u203235\u2033N 122\u00b019\u203259\u2033W\"]], columns=[\"name\", \"population\", \"location\"])  cbrs = 15 + 85 * np.random.rand(25) inf_means = 5 + 45 * np.random.rand(25) R0s = 1.5 + 8.5 * np.random.rand(25) output = pd.DataFrame(data={\"cbr\": cbrs, \"inf_mean\": inf_means, \"R0\": R0s}) output[\"Average_Iage_observed\"] = np.nan output[\"Average_Iage_expected\"] = np.nan output[\"Average_Sage_observed\"] = np.nan output[\"Average_Sage_expected\"] = np.nan output[\"Average_age_expected\"] = np.nan output[\"Average_age_expected\"] = np.nan for index, row in output.iterrows():     parameters = PropertySet(         {             \"seed\": 2,             \"nticks\": 73000,             \"verbose\": True,             \"beta\": row[\"R0\"] * (mu + 1 / row[\"inf_mean\"]),             \"inf_mean\": row[\"inf_mean\"],             \"cbr\": row[\"cbr\"],             \"importation_period\": 180,             \"importation_count\": 3,         }     )      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Random_Agents,     ]     set_initial_susceptibility_randomly(model, 1 / row[\"R0\"] + 0.05)     seed_infections_randomly(model, ninfections=1)     model.run()     mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1     _, expfit, _ = fit_age_at_infection(model, 36500)      output.loc[index, \"Average_Iage_expected\"] = 1 / (row[\"R0\"] * mu) / 365     output.loc[index, \"Average_Iage_observed\"] = expfit[1]      _, _, popt, _, _ = fit_susceptibility_vs_age(model, 36500)     output.loc[index, \"Average_Sage_expected\"] = 1 / ((row[\"R0\"] - 1) * mu) / 365     output.loc[index, \"Average_Sage_observed\"] = popt[0]      _, expfit, _ = fit_population_age_distribution(model)     output.loc[index, \"Average_age_expected\"] = 1 / mu / 365     output.loc[index, \"Average_age_observed\"] = expfit[1] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[11], line 19\n     12 output[\"Average_age_expected\"] = np.nan\n     13 for index, row in output.iterrows():\n     14     parameters = PropertySet(\n     15         {\n     16             \"seed\": 2,\n     17             \"nticks\": 73000,\n     18             \"verbose\": True,\n---&gt; 19             \"beta\": row[\"R0\"] * (mu + 1 / row[\"inf_mean\"]),\n     20             \"inf_mean\": row[\"inf_mean\"],\n     21             \"cbr\": row[\"cbr\"],\n     22             \"importation_period\": 180,\n     23             \"importation_count\": 3,\n     24         }\n     25     )\n     27     model = Model(scenario, parameters)\n     28     model.components = [\n     29         Births_ConstantPop,\n     30         Susceptibility,\n   (...)     33         Infect_Random_Agents,\n     34     ]\n\nNameError: name 'mu' is not defined</pre> In\u00a0[12]: Copied! <pre># Plotting the expected and observed values\nfig, axes = plt.subplots(3, 1, figsize=(10, 15))\n\n# Plot for Average_Iage\naxes[0].scatter(output[\"Average_Iage_expected\"], output[\"Average_Iage_observed\"], c=\"blue\")\naxes[0].plot(\n    [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],\n    [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],\n    \"r--\",\n)\naxes[0].set_xlabel(\"Average_Iage_expected\")\naxes[0].set_ylabel(\"Average_Iage_observed\")\naxes[0].set_title(\"Average_Iage: Expected vs Observed\")\n\n# Plot for Average_Sage\naxes[1].scatter(output[\"Average_Sage_expected\"], output[\"Average_Sage_observed\"], c=\"green\")\naxes[1].plot(\n    [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],\n    [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],\n    \"r--\",\n)\naxes[1].set_xlabel(\"Average_Sage_expected\")\naxes[1].set_ylabel(\"Average_Sage_observed\")\naxes[1].set_title(\"Average_Sage: Expected vs Observed\")\n\n# Plot for Average_age\naxes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\")\naxes[2].plot(\n    [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n    [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n    \"r--\",\n)\naxes[2].set_xlabel(\"Average_age_expected\")\naxes[2].set_ylabel(\"Average_age_observed\")\naxes[2].set_title(\"Average_age: Expected vs Observed\")\n\nplt.tight_layout()\nplt.show()\n\n# Testing whether the expected and observed values are within 10% of each other\nwithin_10_percent_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] &lt;= 0.1\nwithin_10_percent_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] &lt;= 0.1\nwithin_10_percent_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"] &lt;= 0.1\n# Calculate deviations\ndeviation_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"]\ndeviation_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"]\ndeviation_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"]\n\n# Print average fractional deviation\nprint(f\"Average fractional deviation for Iage: {deviation_Iage.mean()}\")\nprint(f\"Average fractional deviation for Sage: {deviation_Sage.mean()}\")\nprint(f\"Average fractional deviation for age: {deviation_age.mean()}\")\n\n# Print max deviation\nprint(f\"Max deviation for Iage: {deviation_Iage.max()}\")\nprint(f\"Max deviation for Sage: {deviation_Sage.max()}\")\nprint(f\"Max deviation for age: {deviation_age.max()}\")\n\n# Print number of sims &gt;5% and 10% away from expectation\nprint(f\"Number of sims &gt;5% away for Iage: {(deviation_Iage &gt; 0.05).sum()}\")\nprint(f\"Number of sims &gt;10% away for Iage: {(deviation_Iage &gt; 0.1).sum()}\")\nprint(f\"Number of sims &gt;5% away for Sage: {(deviation_Sage &gt; 0.05).sum()}\")\nprint(f\"Number of sims &gt;10% away for Sage: {(deviation_Sage &gt; 0.1).sum()}\")\nprint(f\"Number of sims &gt;5% away for age: {(deviation_age &gt; 0.05).sum()}\")\nprint(f\"Number of sims &gt;10% away for age: {(deviation_age &gt; 0.1).sum()}\")\n</pre> # Plotting the expected and observed values fig, axes = plt.subplots(3, 1, figsize=(10, 15))  # Plot for Average_Iage axes[0].scatter(output[\"Average_Iage_expected\"], output[\"Average_Iage_observed\"], c=\"blue\") axes[0].plot(     [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],     [output[\"Average_Iage_expected\"].min(), output[\"Average_Iage_expected\"].max()],     \"r--\", ) axes[0].set_xlabel(\"Average_Iage_expected\") axes[0].set_ylabel(\"Average_Iage_observed\") axes[0].set_title(\"Average_Iage: Expected vs Observed\")  # Plot for Average_Sage axes[1].scatter(output[\"Average_Sage_expected\"], output[\"Average_Sage_observed\"], c=\"green\") axes[1].plot(     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],     [output[\"Average_Sage_expected\"].min(), output[\"Average_Sage_expected\"].max()],     \"r--\", ) axes[1].set_xlabel(\"Average_Sage_expected\") axes[1].set_ylabel(\"Average_Sage_observed\") axes[1].set_title(\"Average_Sage: Expected vs Observed\")  # Plot for Average_age axes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\") axes[2].plot(     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],     \"r--\", ) axes[2].set_xlabel(\"Average_age_expected\") axes[2].set_ylabel(\"Average_age_observed\") axes[2].set_title(\"Average_age: Expected vs Observed\")  plt.tight_layout() plt.show()  # Testing whether the expected and observed values are within 10% of each other within_10_percent_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] &lt;= 0.1 within_10_percent_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] &lt;= 0.1 within_10_percent_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"] &lt;= 0.1 # Calculate deviations deviation_Iage = np.abs(output[\"Average_Iage_expected\"] - output[\"Average_Iage_observed\"]) / output[\"Average_Iage_expected\"] deviation_Sage = np.abs(output[\"Average_Sage_expected\"] - output[\"Average_Sage_observed\"]) / output[\"Average_Sage_expected\"] deviation_age = np.abs(output[\"Average_age_expected\"] - output[\"Average_age_observed\"]) / output[\"Average_age_expected\"]  # Print average fractional deviation print(f\"Average fractional deviation for Iage: {deviation_Iage.mean()}\") print(f\"Average fractional deviation for Sage: {deviation_Sage.mean()}\") print(f\"Average fractional deviation for age: {deviation_age.mean()}\")  # Print max deviation print(f\"Max deviation for Iage: {deviation_Iage.max()}\") print(f\"Max deviation for Sage: {deviation_Sage.max()}\") print(f\"Max deviation for age: {deviation_age.max()}\")  # Print number of sims &gt;5% and 10% away from expectation print(f\"Number of sims &gt;5% away for Iage: {(deviation_Iage &gt; 0.05).sum()}\") print(f\"Number of sims &gt;10% away for Iage: {(deviation_Iage &gt; 0.1).sum()}\") print(f\"Number of sims &gt;5% away for Sage: {(deviation_Sage &gt; 0.05).sum()}\") print(f\"Number of sims &gt;10% away for Sage: {(deviation_Sage &gt; 0.1).sum()}\") print(f\"Number of sims &gt;5% away for age: {(deviation_age &gt; 0.05).sum()}\") print(f\"Number of sims &gt;10% away for age: {(deviation_age &gt; 0.1).sum()}\") <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3811 try:\n-&gt; 3812     return self._engine.get_loc(casted_key)\n   3813 except KeyError as err:\n\nFile pandas/_libs/index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7096, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'Average_age_observed'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[12], line 27\n     24 axes[1].set_title(\"Average_Sage: Expected vs Observed\")\n     26 # Plot for Average_age\n---&gt; 27 axes[2].scatter(output[\"Average_age_expected\"], output[\"Average_age_observed\"], c=\"purple\")\n     28 axes[2].plot(\n     29     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n     30     [output[\"Average_age_expected\"].min(), output[\"Average_age_expected\"].max()],\n     31     \"r--\",\n     32 )\n     33 axes[2].set_xlabel(\"Average_age_expected\")\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/frame.py:4113, in DataFrame.__getitem__(self, key)\n   4111 if self.columns.nlevels &gt; 1:\n   4112     return self._getitem_multilevel(key)\n-&gt; 4113 indexer = self.columns.get_loc(key)\n   4114 if is_integer(indexer):\n   4115     indexer = [indexer]\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexes/base.py:3819, in Index.get_loc(self, key)\n   3814     if isinstance(casted_key, slice) or (\n   3815         isinstance(casted_key, abc.Iterable)\n   3816         and any(isinstance(x, slice) for x in casted_key)\n   3817     ):\n   3818         raise InvalidIndexError(key)\n-&gt; 3819     raise KeyError(key) from err\n   3820 except TypeError:\n   3821     # If we have a listlike key, _check_indexing_error will raise\n   3822     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3823     #  the TypeError.\n   3824     self._check_indexing_error(key)\n\nKeyError: 'Average_age_observed'</pre> In\u00a0[13]: Copied! <pre>output\n</pre> output Out[13]: cbr inf_mean R0 Average_Iage_observed Average_Iage_expected Average_Sage_observed Average_Sage_expected Average_age_expected 0 83.808382 27.460854 7.149359 NaN NaN NaN NaN NaN 1 88.766212 24.390509 4.506653 NaN NaN NaN NaN NaN 2 66.996900 38.368811 2.234557 NaN NaN NaN NaN NaN 3 45.603915 20.170471 5.495553 NaN NaN NaN NaN NaN 4 30.919197 15.345186 3.358266 NaN NaN NaN NaN NaN 5 68.817130 42.230382 7.411263 NaN NaN NaN NaN NaN 6 27.474385 15.891709 1.937503 NaN NaN NaN NaN NaN 7 57.485611 46.307278 2.523566 NaN NaN NaN NaN NaN 8 82.704818 35.190194 5.822687 NaN NaN NaN NaN NaN 9 21.841270 9.205668 7.866354 NaN NaN NaN NaN NaN 10 97.316050 34.233652 6.374090 NaN NaN NaN NaN NaN 11 55.993777 35.605686 6.234739 NaN NaN NaN NaN NaN 12 89.388549 7.160505 3.422257 NaN NaN NaN NaN NaN 13 59.118994 24.542769 2.380783 NaN NaN NaN NaN NaN 14 70.416227 32.619568 4.142008 NaN NaN NaN NaN NaN 15 49.437645 37.256097 2.075755 NaN NaN NaN NaN NaN 16 57.726516 23.990194 7.500072 NaN NaN NaN NaN NaN 17 80.124317 21.218491 6.165961 NaN NaN NaN NaN NaN 18 78.745442 37.569376 1.510189 NaN NaN NaN NaN NaN 19 69.964278 32.157184 9.803133 NaN NaN NaN NaN NaN 20 74.034566 18.901435 8.835466 NaN NaN NaN NaN NaN 21 19.115004 16.237221 4.898903 NaN NaN NaN NaN NaN 22 79.105888 9.677885 4.008289 NaN NaN NaN NaN NaN 23 76.362149 27.306297 2.082233 NaN NaN NaN NaN NaN 24 17.345098 29.200072 3.311525 NaN NaN NaN NaN NaN"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#average-age-at-infection-in-the-sir-model","title":"Average age at infection in the SIR model\u00b6","text":"<p>Continuing our investigation of the Susceptible-Infected-Recovered model, we will add demographics and investigate the behavior of the model in and around the endemic equilibrium.</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I - \\mu I\\\\  \\dot{R} = \\gamma I - \\mu R $$</p> <p>Analysis of this system can be found in other sources (ref. Keeling/Rohani).  Setting the derivatives to zero and doing a bit of algebra gets you to the endemic equilbrium</p> <p>$$ (S^*, \\: I^*, \\: R^*) = (\\frac{1}{R_0}, \\:\\: \\frac{\\mu (R_0-1)}{\\beta}, \\: \\: 1-\\frac{1}{R_0} - \\frac{\\mu (R_0-1)}{\\beta}) \\\\  \\text{where} \\:\\: R_0 = \\frac{\\beta}{\\gamma + \\mu} $$</p> <p>An individual susceptible's mean time to infection will then be the inverse of the total force of infection, $\\beta I^*$. $$ \\tau_{S \\rightarrow I} = \\frac{1}{\\mu (R_0 -1)} $$</p> <p>The equation above is often also described as the average age at infection.  However, it is key to remember that the measured age at infection will be censored by non-disease deaths occurring at a rate $\\mu$.  You can work through the impact of this, but in the simple case of constant mortality, it turns out to exactly balance out the $-1$ in the above equation, and so our observed average age at infection will be $\\frac{1}{\\mu R_0}$.  Since the hazard is constant at equilibrium, this implies an exponential distribution:</p> <p>$$P(a | S-&gt;I) \\sim \\mu R_0 e^{-\\mu R_0 a}$$</p> <p>Alternatively, we can correct for the influence of mortality by observing the fraction of children who are susceptible at age A, which necessarily conditions on survival to age A.  This will look like the cumulative distribution of an exponential distributed according to the mean time to infection above:</p> <p>$$P(R | a) \\sim 1 - e^{(-a \\mu (R_0-1))}$$</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>In the first few cells, we do all the necessary imports.  Because we are now measuring an equilibrium property of this system, we will have to burn in, with repeated infection importations to ensure that we establish an endemic equilibrium.  We also need to model a large enough population to sustain the infection (see Critical Community Size notebook).  The primary determinant of the critical community size is the duration of infection, so keeping this relatively long (2 months) prevents us from needing huge agent populations.  So, we construct a single-patch LASER model with fice components: <code>Births_ConstantPop</code>, <code>Susceptibility</code>, <code>Transmission</code>, <code>Infection</code>, and <code>Infect_Random_Agents</code>, a function that implements repeated importation for a fixed period of time.</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.  As it stands, I am not actually explicitly tracking the recovered population, but I can check that $S_t = N_t - \\sum{\\Delta_I}$.</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will sample a set of $(\\mu, \\gamma, R_0)$ pairs and confirm that both the age at infection and the fraction of susceptibles at a given age are well-described by exponential distributions and that the associated rate constant is as expected.</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#future-work","title":"Future work\u00b6","text":"<p>The addition of an exposed compartment should not change this result (other than changing the relevant transition from S-&gt;E rather than S-&gt;I) and we should test this.</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>As always, check that we haven't broken anything - S+I+R = N at all times.</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#first-scientific-test-check","title":"First scientific test check\u00b6","text":"<p>As usual, we will test this on a single simulation instance and demonstrate the analysis, before moving on to testing over a range of input values. Here, we are interested in equilibrium behavior, so I first place a cut to exclude all infections that occur before day 10000. We then plot the data, an exponential distribution with the expected value of $\\frac{1}{R_0 \\mu}$, a best-fit exponential distribution to the data, and perform a KS test.</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#second-scientific-test-check","title":"Second scientific test check\u00b6","text":"<p>As noted above, because of the censoring that mortality induces, the distributions of age at infection vs. fraction susceptible at a given age will both follow exponential behavior but with a slight difference in the mean of the distribution - for the fraction susceptible, that value will be $\\frac{1}{\\mu (R_0-1)}$.  We develop this second test below.</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#third-scientific-test","title":"Third scientific test\u00b6","text":"<p>As long as we are here, let's test that the age distribution of the population is correct.  With constant birth rate, equal to death rate, the population should have exponentially distributed ages with parameter $\\frac{1}{\\mu}$</p>"},{"location":"notebooks/05_SIR_wbirths_age_distribution/#larger-test-suite","title":"Larger test suite\u00b6","text":"<p>OK, so now we are going to replicate the above for many values of R0 and cbr, as a scientific validity test.</p> <p>TODO: As written, this takes a long time.  That's because the space of random values being sampled occasionally produces models where the average age at infection is 30 years old, or so.  Correspondingly, those models take a long time to equilibrate so that the tests don't look terrible fail.  So as of right now, these run for 200 years to sidestep this.  Should instead restrict the range of values - higher cbrs and R0s - so that the average age at infection is consistently lower and we can get away with running for like 30-50 years instead.</p>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/","title":"Intrinsic periodicity of the SIR system","text":"In\u00a0[1]: Copied! <pre>import math\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nfrom scipy.ndimage import gaussian_filter1d\nfrom scipy.signal import find_peaks\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic import Infection\nfrom laser.generic import Model\nfrom laser.generic import Susceptibility\nfrom laser.generic import Transmission\nfrom laser.generic.importation import Infect_Random_Agents\nfrom laser.generic.utils import seed_infections_randomly\nfrom laser.generic.utils import set_initial_susceptibility_randomly\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import math  import matplotlib.pyplot as plt import numpy as np import pandas as pd from laser.core.propertyset import PropertySet from scipy.ndimage import gaussian_filter1d from scipy.signal import find_peaks  import laser.core import laser.generic from laser.generic import Births_ConstantPop from laser.generic import Infection from laser.generic import Model from laser.generic import Susceptibility from laser.generic import Transmission from laser.generic.importation import Infect_Random_Agents from laser.generic.utils import seed_infections_randomly from laser.generic.utils import set_initial_susceptibility_randomly  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>np.__version__='2.3.4'\nlaser.core.__version__='0.7.0'\nlaser.generic.__version__='0.0.0'\n</pre> <p>OK, in testing here, we run into a couple of challenges, and my training in spectral analysis is a bit old at this point.  Mainly, we're interested in relatively low-frequency signals relative to our vector length - periods that can be order a few years in a sequence of a few decades, so only a few oscillations.  Not impossible but tough Second is that there are lots of other signals that will probably settle down over time, but may not.  Lastly, there seem to be some windowing effects from the length of the vector itself. So some approaches to get arounds this: Try to start relatively close to equilibrium Use time-domain autocorrelation spectrum Instead of looking for the period of maximum power, specifically look for a peak in the vicinity of the expected period.</p> In\u00a0[2]: Copied! <pre>scenario = pd.DataFrame(data=[[\"homenode\", 2e6]], columns=[\"name\", \"population\"])\nparameters = PropertySet(\n    {\"seed\": 4, \"nticks\": 36500, \"verbose\": True, \"beta\": 0.4, \"inf_mean\": 12, \"cbr\": 45, \"importation_period\": 180, \"importation_count\": 3}\n)\n</pre> scenario = pd.DataFrame(data=[[\"homenode\", 2e6]], columns=[\"name\", \"population\"]) parameters = PropertySet(     {\"seed\": 4, \"nticks\": 36500, \"verbose\": True, \"beta\": 0.4, \"inf_mean\": 12, \"cbr\": 45, \"importation_period\": 180, \"importation_count\": 3} ) In\u00a0[3]: Copied! <pre>model = Model(scenario, parameters)\nmodel.components = [\n    Infect_Random_Agents,\n    Births_ConstantPop,\n    Susceptibility,\n    Infection,\n    Transmission,\n]\n\nseed_infections_randomly(model, ninfections=1)\nmodel.run()\nplt.plot(model.patches.cases)\n</pre> model = Model(scenario, parameters) model.components = [     Infect_Random_Agents,     Births_ConstantPop,     Susceptibility,     Infection,     Transmission, ]  seed_infections_randomly(model, ninfections=1) model.run() plt.plot(model.patches.cases) <pre>2025-10-30 22:28:18.258772: Creating the generic model\u2026\n</pre> <pre>Initializing the generic model with 1 patches\u2026\n</pre> <pre>2025-10-30 22:28:18.329432: Running the generic model for 36500 ticks\u2026\n</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\n</pre> <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[3], line 11\n      2 model.components = [\n      3     Infect_Random_Agents,\n      4     Births_ConstantPop,\n   (...)      7     Transmission,\n      8 ]\n     10 seed_infections_randomly(model, ninfections=1)\n---&gt; 11 model.run()\n     12 plt.plot(model.patches.cases)\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:306, in Births_ConstantPop.__call__(self, model, tick)\n    302     model.population.dob[indices] = tick  # set to current tick\n    303 model.population.state[indices] = 0\n    305 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 306     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    307 ).astype(np.uint32)\n    309 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    310     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    311 ).astype(np.uint32)\n    313 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    314     model.population.nodeid[indices],\n    315     weights=(\n   (...)    320     minlength=model.patches.populations.shape[1],\n    321 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[4]: Copied! <pre>model.patches.cases[10000:10010]\n</pre> model.patches.cases[10000:10010] Out[4]: <pre>array([[0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0],\n       [0]], dtype=uint32)</pre> In\u00a0[5]: Copied! <pre>cases = np.squeeze(model.patches.cases)\nsusc = np.squeeze(model.patches.susceptibility)\nrec = np.squeeze(model.patches.recovered)\ninc = np.squeeze(model.patches.incidence)\nbirths = np.squeeze(model.patches.births)\npops = np.squeeze(model.patches.populations)[:-1]\n\nprint(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all()))\n</pre> cases = np.squeeze(model.patches.cases) susc = np.squeeze(model.patches.susceptibility) rec = np.squeeze(model.patches.recovered) inc = np.squeeze(model.patches.incidence) births = np.squeeze(model.patches.births) pops = np.squeeze(model.patches.populations)[:-1]  print(\"S+I+R = N:  \" + str(np.isclose(cases + susc + rec, pops).all())) <pre>S+I+R = N:  False\n</pre> In\u00a0[6]: Copied! <pre>mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1\nR0 = model.params.beta / (1 / model.params.inf_mean + mu)\nA = 1 / ((R0 - 1) * mu) / 365\nG = 1 / (mu + 1 / model.params.inf_mean) / 365\nT_exp = 2 * np.pi * np.sqrt(A * G)\n\n\ndef ID_freq_peakfinder(y0, T_exp, cutoff=18250, plot=False):\n    y = y0[cutoff:]\n    y = y - np.mean(y)\n    y = gaussian_filter1d(y, sigma=100)\n    peaks, _ = find_peaks(y, distance=T_exp * 365 / 2)\n    if plot:\n        plt.figure()\n        plt.plot(y, alpha=0.5)\n        plt.plot(peaks, y[peaks], \"x\")\n    return np.median(np.diff(peaks)) / 365\n\n\nT_obs_pf = ID_freq_peakfinder(np.squeeze(model.patches.cases), T_exp, plot=True)\n\n\ndef ID_freq_autocorr(y0, cutoff=18250):\n    # Compute the FFT\n    Y1 = np.fft.fft(y0[cutoff:] - np.mean(y0[cutoff:]))\n\n    # Compute the circular autocorrelation using the inverse FFT\n    circular_autocorr = np.fft.ifft(Y1 * np.conj(Y1)).real\n    # Plot only the positive frequency spectrum\n    peaks, _ = find_peaks(circular_autocorr, distance=300)\n    return peaks[0] / 365\n\n\nT_obs_fft = ID_freq_autocorr(np.squeeze(model.patches.cases))\n\nplt.text(0.05, 0.9, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes)\nplt.text(0.05, 0.85, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes)\nplt.text(0.05, 0.8, f\"T observed, FFT: {T_obs_fft:.2f} y\", transform=plt.gca().transAxes)\nplt.show()\n</pre> mu = (1 + model.params.cbr / 1000) ** (1 / 365) - 1 R0 = model.params.beta / (1 / model.params.inf_mean + mu) A = 1 / ((R0 - 1) * mu) / 365 G = 1 / (mu + 1 / model.params.inf_mean) / 365 T_exp = 2 * np.pi * np.sqrt(A * G)   def ID_freq_peakfinder(y0, T_exp, cutoff=18250, plot=False):     y = y0[cutoff:]     y = y - np.mean(y)     y = gaussian_filter1d(y, sigma=100)     peaks, _ = find_peaks(y, distance=T_exp * 365 / 2)     if plot:         plt.figure()         plt.plot(y, alpha=0.5)         plt.plot(peaks, y[peaks], \"x\")     return np.median(np.diff(peaks)) / 365   T_obs_pf = ID_freq_peakfinder(np.squeeze(model.patches.cases), T_exp, plot=True)   def ID_freq_autocorr(y0, cutoff=18250):     # Compute the FFT     Y1 = np.fft.fft(y0[cutoff:] - np.mean(y0[cutoff:]))      # Compute the circular autocorrelation using the inverse FFT     circular_autocorr = np.fft.ifft(Y1 * np.conj(Y1)).real     # Plot only the positive frequency spectrum     peaks, _ = find_peaks(circular_autocorr, distance=300)     return peaks[0] / 365   T_obs_fft = ID_freq_autocorr(np.squeeze(model.patches.cases))  plt.text(0.05, 0.9, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes) plt.text(0.05, 0.85, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes) plt.text(0.05, 0.8, f\"T observed, FFT: {T_obs_fft:.2f} y\", transform=plt.gca().transAxes) plt.show() <pre>/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/fromnumeric.py:3860: RuntimeWarning: Mean of empty slice.\n  return _methods._mean(a, axis=axis, dtype=dtype,\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/_methods.py:144: RuntimeWarning: invalid value encountered in scalar divide\n  ret = ret.dtype.type(ret / rcount)\n</pre> <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[6], line 34\n     30     peaks, _ = find_peaks(circular_autocorr, distance=300)\n     31     return peaks[0] / 365\n---&gt; 34 T_obs_fft = ID_freq_autocorr(np.squeeze(model.patches.cases))\n     36 plt.text(0.05, 0.9, f\"T expected: {T_exp:.2f} y\", transform=plt.gca().transAxes)\n     37 plt.text(0.05, 0.85, f\"T observed, peakfinding: {T_obs_pf:.2f} y\", transform=plt.gca().transAxes)\n\nCell In[6], line 31, in ID_freq_autocorr(y0, cutoff)\n     29 # Plot only the positive frequency spectrum\n     30 peaks, _ = find_peaks(circular_autocorr, distance=300)\n---&gt; 31 return peaks[0] / 365\n\nIndexError: index 0 is out of bounds for axis 0 with size 0</pre> In\u00a0[7]: Copied! <pre># import os\n\nnsims = 10\nnticks = 36500\ncbrs = 30 + 50 * np.random.rand(nsims)\ninf_means = 5 + 45 * np.random.rand(nsims)\nR0s = 2.5 + 7.5 * np.random.rand(nsims)\nmu = [((1 + cbr / 1000) ** (1 / 365) - 1) for cbr in cbrs]\nA = [1 / ((R0 - 1) * mu) / 365 for R0, mu in zip(R0s, mu)]\nG = [1 / (mu + 1 / inf_mean) / 365 for mu, inf_mean in zip(mu, inf_means)]\nT_exp = [2 * math.pi * np.sqrt(A * G) for A, G in zip(A, G)]\nmycases = np.zeros((nsims, nticks))\nparams_df = pd.DataFrame(\n    {\n        \"cbr\": cbrs,\n        \"inf_mean\": inf_means,\n        \"R0\": R0s,\n        \"A\": A,\n        \"G\": G,\n        \"T_exp\": T_exp,\n    }\n)\ni = 0\nfor cbr, inf_mean, R0 in zip(cbrs, inf_means, R0s):\n    mu = (1 + cbr / 1000) ** (1 / 365) - 1\n    parameters = PropertySet(\n        {\n            \"seed\": 2,\n            \"nticks\": 36500,\n            \"verbose\": True,\n            \"beta\": R0 * (mu + 1 / inf_mean),\n            \"inf_mean\": inf_mean,\n            \"cbr\": cbr,\n            \"importation_period\": 180,\n            \"importation_count\": 3,\n        }\n    )\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Random_Agents,\n    ]\n\n    set_initial_susceptibility_randomly(model, 1 / R0 + 0.02)\n    seed_infections_randomly(model, ninfections=1)\n    model.run()\n    plt.plot(model.patches.cases)\n    mycases[i] = np.squeeze(model.patches.cases)\n    i = i + 1\n\n# output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"periodicity\"))\n# os.makedirs(output_folder, exist_ok=True)\n# params_df.to_csv(os.path.join(output_folder, \"params_df.csv\"), index=False)\n# np.save(os.path.join(output_folder, \"mycases.npy\"), mycases)\n</pre> # import os  nsims = 10 nticks = 36500 cbrs = 30 + 50 * np.random.rand(nsims) inf_means = 5 + 45 * np.random.rand(nsims) R0s = 2.5 + 7.5 * np.random.rand(nsims) mu = [((1 + cbr / 1000) ** (1 / 365) - 1) for cbr in cbrs] A = [1 / ((R0 - 1) * mu) / 365 for R0, mu in zip(R0s, mu)] G = [1 / (mu + 1 / inf_mean) / 365 for mu, inf_mean in zip(mu, inf_means)] T_exp = [2 * math.pi * np.sqrt(A * G) for A, G in zip(A, G)] mycases = np.zeros((nsims, nticks)) params_df = pd.DataFrame(     {         \"cbr\": cbrs,         \"inf_mean\": inf_means,         \"R0\": R0s,         \"A\": A,         \"G\": G,         \"T_exp\": T_exp,     } ) i = 0 for cbr, inf_mean, R0 in zip(cbrs, inf_means, R0s):     mu = (1 + cbr / 1000) ** (1 / 365) - 1     parameters = PropertySet(         {             \"seed\": 2,             \"nticks\": 36500,             \"verbose\": True,             \"beta\": R0 * (mu + 1 / inf_mean),             \"inf_mean\": inf_mean,             \"cbr\": cbr,             \"importation_period\": 180,             \"importation_count\": 3,         }     )     model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Random_Agents,     ]      set_initial_susceptibility_randomly(model, 1 / R0 + 0.02)     seed_infections_randomly(model, ninfections=1)     model.run()     plt.plot(model.patches.cases)     mycases[i] = np.squeeze(model.patches.cases)     i = i + 1  # output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"periodicity\")) # os.makedirs(output_folder, exist_ok=True) # params_df.to_csv(os.path.join(output_folder, \"params_df.csv\"), index=False) # np.save(os.path.join(output_folder, \"mycases.npy\"), mycases) <pre>2025-10-30 22:28:18.908399: Creating the generic model\u2026\n</pre> <pre>Initializing the generic model with 1 patches\u2026\n</pre> <pre>2025-10-30 22:28:18.975661: Running the generic model for 36500 ticks\u2026\n</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\r  0%|          | 0/36500 [00:00&lt;?, ?it/s]</pre> <pre>\n</pre> <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[7], line 49\n     47 set_initial_susceptibility_randomly(model, 1 / R0 + 0.02)\n     48 seed_infections_randomly(model, ninfections=1)\n---&gt; 49 model.run()\n     50 plt.plot(model.patches.cases)\n     51 mycases[i] = np.squeeze(model.patches.cases)\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:306, in Births_ConstantPop.__call__(self, model, tick)\n    302     model.population.dob[indices] = tick  # set to current tick\n    303 model.population.state[indices] = 0\n    305 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 306     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    307 ).astype(np.uint32)\n    309 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    310     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    311 ).astype(np.uint32)\n    313 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    314     model.population.nodeid[indices],\n    315     weights=(\n   (...)    320     minlength=model.patches.populations.shape[1],\n    321 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[8]: Copied! <pre>params_df[\"T_obs_peakfinder\"] = np.nan\nparams_df[\"T_obs_autocorr\"] = np.nan\n\nfor i in range(mycases.shape[0]):\n    params_df.loc[i, \"T_obs_peakfinder\"] = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=False)\n    params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :]))\n</pre> params_df[\"T_obs_peakfinder\"] = np.nan params_df[\"T_obs_autocorr\"] = np.nan  for i in range(mycases.shape[0]):     params_df.loc[i, \"T_obs_peakfinder\"] = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=False)     params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :])) <pre>/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/fromnumeric.py:3860: RuntimeWarning: Mean of empty slice.\n  return _methods._mean(a, axis=axis, dtype=dtype,\n/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/_methods.py:144: RuntimeWarning: invalid value encountered in scalar divide\n  ret = ret.dtype.type(ret / rcount)\n</pre> <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[8], line 6\n      4 for i in range(mycases.shape[0]):\n      5     params_df.loc[i, \"T_obs_peakfinder\"] = ID_freq_peakfinder(np.squeeze(mycases[i, :]), params_df.loc[i, \"T_exp\"], plot=False)\n----&gt; 6     params_df.loc[i, \"T_obs_autocorr\"] = ID_freq_autocorr(np.squeeze(mycases[i, :]))\n\nCell In[6], line 31, in ID_freq_autocorr(y0, cutoff)\n     29 # Plot only the positive frequency spectrum\n     30 peaks, _ = find_peaks(circular_autocorr, distance=300)\n---&gt; 31 return peaks[0] / 365\n\nIndexError: index 0 is out of bounds for axis 0 with size 0</pre> In\u00a0[9]: Copied! <pre>params_df\n</pre> params_df Out[9]: cbr inf_mean R0 A G T_exp T_obs_peakfinder T_obs_autocorr 0 78.316126 47.646585 2.683894 7.875264 0.129266 6.339497 NaN NaN 1 39.831444 42.956050 3.782967 9.199236 0.117149 6.522672 NaN NaN 2 33.699968 38.245820 9.336544 3.618944 0.104420 3.862455 NaN NaN 3 31.004992 6.626953 4.586971 9.129974 0.018146 2.557436 NaN NaN 4 71.504780 45.480356 4.480147 4.160156 0.123540 4.504425 NaN NaN 5 65.847199 12.597417 5.757625 3.295760 0.034438 2.116774 NaN NaN 6 53.265700 25.198810 7.165544 3.125128 0.068791 2.913270 NaN NaN 7 62.940923 27.778342 5.920736 3.329067 0.075753 3.155305 NaN NaN 8 36.336657 46.437177 5.837691 5.791207 0.126650 5.381050 NaN NaN 9 56.508673 47.526219 6.532047 3.288195 0.129283 4.096661 NaN NaN In\u00a0[10]: Copied! <pre>plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder\"], \"o\")\n</pre> plt.plot(params_df[\"T_exp\"], params_df[\"T_obs_peakfinder\"], \"o\") Out[10]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f61003a38c0&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> Out[\u00a0]: <pre>[&lt;matplotlib.lines.Line2D at 0x32d8046d0&gt;,\n &lt;matplotlib.lines.Line2D at 0x30d3108d0&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d8b50&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d8ed0&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9110&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9410&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9790&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9bd0&gt;,\n &lt;matplotlib.lines.Line2D at 0x3301d9fd0&gt;,\n &lt;matplotlib.lines.Line2D at 0x30d2da4d0&gt;]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/#intrinsic-periodicity-of-the-sir-system","title":"Intrinsic periodicity of the SIR system\u00b6","text":"<p>Continuing our investigation of the Susceptible-Infected-Recovered system,</p> <p>$$ \\dot{S} = -\\frac{\\beta*S*I}{N} + \\mu N - \\mu S\\\\  \\dot{I} = \\frac{\\beta*S*I}{N} - \\gamma I - \\mu I\\\\  \\dot{R} = \\gamma I - \\mu R $$</p> <p>With non-trivial endemic equilbrium</p> <p>$$ (S^*, \\: I^*, \\: R^*) = (\\frac{1}{R_0}, \\:\\: \\frac{\\mu (R_0-1)}{\\beta}, \\: \\: 1-\\frac{1}{R_0} - \\frac{\\mu (R_0-1)}{\\beta}) \\\\  \\text{where} \\:\\: R_0 = \\frac{\\beta}{\\gamma + \\mu} $$</p> <p>General analysis of a system's stability of and approach to equilibria is beyond the scope of this notebook, and detailed discussions are available elsewhere (e.g., Keeling/Rohani Box 2.4).  In brief, one constructs the Jacobian of the system at the equilibrium points and computes its eigenvalues.  If all eigenvalues have negative real component, then the equilibrium is stable; if the dominant eigenvalues are complex conjugates, then system approaches equilibrium via damped oscillations, with damping constant equal to the real component and frequency equal to the imaginary component. This is the case for the SIR system around the non-trivial ($R_0 \\gt 1$) equilibrium, with dominant eigenvalues:</p> <p>$$ \\Lambda = -\\frac{\\mu R_0}{2} \\pm \\frac{\\sqrt{\\mu^2 R_0^2 - \\frac{4}{A G}}}{2} \\\\ \\text{where} \\:\\: A = \\frac{1}{\\mu (R_0 -1)} and G = \\frac{1}{\\mu + \\gamma}  $$</p> <p>In general, $\\mu^2 R_0^2$ is quite small, and the intrinsic periodicity of the system is $T \\approx 2 \\pi \\sqrt{A G}$.</p>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/#contruct-the-model","title":"Contruct the model\u00b6","text":"<p>The model is contructed as in notebook 05.  As again, we are looking at behavior around the endemic equilibrium, the same considerations of large-ish populations and long simulations apply here.</p>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/#sanity-check","title":"Sanity check\u00b6","text":"<p>The first test, as always, ensures that certain basic constraints are being obeyed by the model.  As it stands, I am not actually explicitly tracking the recovered population, but I can check that $S_t = N_t - \\sum{\\Delta_I}$.</p>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/#scientific-test","title":"Scientific test\u00b6","text":"<p>The scientific test will sample a set of $(\\mu, \\gamma, R_0)$ tuplets and confirm that the periodicity is</p>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/#future-work","title":"Future work\u00b6","text":"<p>The addition of an exposed compartment with rate constant $\\sigma$ should change this result, by changing the generation time $G$ to $\\frac{1}{\\mu + \\gamma} + \\frac{1}{\\mu + \\sigma}$</p>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/#sanity-checks","title":"Sanity checks\u00b6","text":"<p>As always, check that we haven't broken anything - S+I+R = N at all times</p>"},{"location":"notebooks/06_SIR_wbirths_natural_periodicity/#larger-test-suite","title":"Larger test suite\u00b6","text":"<p>OK, so now we are going to replicate the above test for many values of R0 and cbr, as a scientific validity test.</p> <p>TODO: As written, this takes a long time.  That's because the space of random values being sampled occasionally produces models with long equilibration times and long periodicities.  So as of right now, these run for 100 years to sidestep this.  Should instead restrict the range of values - higher cbrs and R0s - so that the average age at infection is consistently lower and we can get away with running for like 30-50 years instead.</p>"},{"location":"notebooks/07_SIR_CCS/","title":"Exploring the critical community size of an SIR model","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nimport matplotlib.pyplot as plt\nimport os\nfrom scipy.optimize import fsolve\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Model\nfrom laser.generic import Infection\nfrom laser.generic import Susceptibility\nfrom laser.generic import Transmission\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic.importation import Infect_Agents_In_Patch\n\nfrom laser.generic.utils import set_initial_susceptibility_in_patch\nfrom laser.generic.utils import seed_infections_in_patch\n\n%load_ext line_profiler\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd from laser.core.propertyset import PropertySet import matplotlib.pyplot as plt import os from scipy.optimize import fsolve  import laser.core import laser.generic from laser.generic import Model from laser.generic import Infection from laser.generic import Susceptibility from laser.generic import Transmission from laser.generic import Births_ConstantPop from laser.generic.importation import Infect_Agents_In_Patch  from laser.generic.utils import set_initial_susceptibility_in_patch from laser.generic.utils import seed_infections_in_patch  %load_ext line_profiler  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\") <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 20\n     17 from laser.generic.utils import set_initial_susceptibility_in_patch\n     18 from laser.generic.utils import seed_infections_in_patch\n---&gt; 20 get_ipython().run_line_magic('load_ext', 'line_profiler')\n     22 print(f\"{np.__version__=}\")\n     23 print(f\"{laser.core.__version__=}\")\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:2504, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2502     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2503 with self.builtin_trap:\n-&gt; 2504     result = fn(*args, **kwargs)\n   2506 # The code below prevents the output from being displayed\n   2507 # when using magics with decorator @output_can_be_silenced\n   2508 # when the last Python token in the expression is a ';'.\n   2509 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/magics/extension.py:33, in ExtensionMagics.load_ext(self, module_str)\n     31 if not module_str:\n     32     raise UsageError('Missing module name.')\n---&gt; 33 res = self.shell.extension_manager.load_extension(module_str)\n     35 if res == 'already loaded':\n     36     print(\"The %s extension is already loaded. To reload it, use:\" % module_str)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/extensions.py:62, in ExtensionManager.load_extension(self, module_str)\n     55 \"\"\"Load an IPython extension by its module name.\n     56 \n     57 Returns the string \"already loaded\" if the extension is already loaded,\n     58 \"no load function\" if the module doesn't have a load_ipython_extension\n     59 function, or None if it succeeded.\n     60 \"\"\"\n     61 try:\n---&gt; 62     return self._load_extension(module_str)\n     63 except ModuleNotFoundError:\n     64     if module_str in BUILTINS_EXTS:\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/extensions.py:77, in ExtensionManager._load_extension(self, module_str)\n     75 with self.shell.builtin_trap:\n     76     if module_str not in sys.modules:\n---&gt; 77         mod = import_module(module_str)\n     78     mod = sys.modules[module_str]\n     79     if self._call_load_ipython_extension(mod):\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/importlib/__init__.py:90, in import_module(name, package)\n     88             break\n     89         level += 1\n---&gt; 90 return _bootstrap._gcd_import(name[level:], package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1387, in _gcd_import(name, package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1360, in _find_and_load(name, import_)\n\nFile &lt;frozen importlib._bootstrap&gt;:1324, in _find_and_load_unlocked(name, import_)\n\nModuleNotFoundError: No module named 'line_profiler'</pre> In\u00a0[2]: Copied! <pre>%%capture\n\nnticks = 50 * 365\nnpatches = 61\npops = np.logspace(3, 6, npatches)\nscenario = pd.DataFrame({\"name\": [str(i) for i in range(npatches)], \"population\": pops})\n\n# np.random.seed(5)  # Ensure reproducibility\nnsims = 200\nR0_samples = np.random.uniform(3, 16, nsims)\ninfmean_samples = 5 + np.random.gamma(2, 10, nsims)\ncbr_samples = 10 + np.random.gamma(2, 20, nsims)\ni = 0\noutputs = np.zeros((nsims, nticks, npatches))\n# Create a folder to store the outputs\noutput_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\"))\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\nfor R0, infmean, cbr in zip(R0_samples, infmean_samples, cbr_samples):\n    parameters = PropertySet(\n        {\n            \"seed\": np.random.randint(0, 1000000),\n            \"nticks\": nticks,\n            \"verbose\": True,\n            \"beta\": R0 / infmean,\n            \"inf_mean\": infmean,\n            \"cbr\": cbr,\n            \"importation_period\": 180,\n            \"importation_end\": 20 * 365,\n        }\n    )\n\n    mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Agents_In_Patch,\n    ]\n\n    # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch\n    # Want to see how connectivity drives correlation over time.\n    for j in range(npatches):\n        set_initial_susceptibility_in_patch(model, j, 1 / R0 + 0.1 / R0 * np.random.normal())\n\n    model.run()\n    outputs[i, :, :] = model.patches.cases\n    np.save(f\"{output_folder}/CCSSIRoutputs_{i}.npy\", outputs[i, :, :])\n    i += 1\n</pre> %%capture  nticks = 50 * 365 npatches = 61 pops = np.logspace(3, 6, npatches) scenario = pd.DataFrame({\"name\": [str(i) for i in range(npatches)], \"population\": pops})  # np.random.seed(5)  # Ensure reproducibility nsims = 200 R0_samples = np.random.uniform(3, 16, nsims) infmean_samples = 5 + np.random.gamma(2, 10, nsims) cbr_samples = 10 + np.random.gamma(2, 20, nsims) i = 0 outputs = np.zeros((nsims, nticks, npatches)) # Create a folder to store the outputs output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\")) if not os.path.exists(output_folder):     os.makedirs(output_folder) for R0, infmean, cbr in zip(R0_samples, infmean_samples, cbr_samples):     parameters = PropertySet(         {             \"seed\": np.random.randint(0, 1000000),             \"nticks\": nticks,             \"verbose\": True,             \"beta\": R0 / infmean,             \"inf_mean\": infmean,             \"cbr\": cbr,             \"importation_period\": 180,             \"importation_end\": 20 * 365,         }     )      mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Agents_In_Patch,     ]      # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch     # Want to see how connectivity drives correlation over time.     for j in range(npatches):         set_initial_susceptibility_in_patch(model, j, 1 / R0 + 0.1 / R0 * np.random.normal())      model.run()     outputs[i, :, :] = model.patches.cases     np.save(f\"{output_folder}/CCSSIRoutputs_{i}.npy\", outputs[i, :, :])     i += 1 <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[2], line 47\n     44 for j in range(npatches):\n     45     set_initial_susceptibility_in_patch(model, j, 1 / R0 + 0.1 / R0 * np.random.normal())\n---&gt; 47 model.run()\n     48 outputs[i, :, :] = model.patches.cases\n     49 np.save(f\"{output_folder}/CCSSIRoutputs_{i}.npy\", outputs[i, :, :])\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:306, in Births_ConstantPop.__call__(self, model, tick)\n    302     model.population.dob[indices] = tick  # set to current tick\n    303 model.population.state[indices] = 0\n    305 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 306     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    307 ).astype(np.uint32)\n    309 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    310     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    311 ).astype(np.uint32)\n    313 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    314     model.population.nodeid[indices],\n    315     weights=(\n   (...)    320     minlength=model.patches.populations.shape[1],\n    321 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[3]: Copied! <pre>params_df = pd.DataFrame({\n    'R0': R0_samples,\n    'infmean': infmean_samples,\n    'cbr': cbr_samples\n})\n\nparams_df.to_csv(os.path.join(output_folder, 'params.csv'), index = False)\n</pre> params_df = pd.DataFrame({     'R0': R0_samples,     'infmean': infmean_samples,     'cbr': cbr_samples })  params_df.to_csv(os.path.join(output_folder, 'params.csv'), index = False) In\u00a0[4]: Copied! <pre>plt.imshow(outputs[26, 7300:, :].T / pops[:, np.newaxis], aspect=\"auto\", origin=\"lower\")\nplt.colorbar(label=\"Cases\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"Patch\")\nplt.yticks(range(0, npatches, 10), np.log10(pops[::10]))\nplt.title(\"Infection spread over time across patches\")\nplt.show()\n</pre> plt.imshow(outputs[26, 7300:, :].T / pops[:, np.newaxis], aspect=\"auto\", origin=\"lower\") plt.colorbar(label=\"Cases\") plt.xlabel(\"Time (days)\") plt.ylabel(\"Patch\") plt.yticks(range(0, npatches, 10), np.log10(pops[::10])) plt.title(\"Infection spread over time across patches\") plt.show() In\u00a0[5]: Copied! <pre>output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\"))\nparams_df = pd.read_csv(os.path.join(output_folder, \"params.csv\"))\n\noutputs = []\nnsims = 200\nnpatches = 61\npops = np.logspace(3, 6, npatches)\n\nfor i in range(nsims):\n    output_file = os.path.join(output_folder, f\"CCSSIRoutputs_{i}.npy\")\n    outputs.append(np.load(output_file))\n\noutputs = np.array(outputs)\n</pre> output_folder = os.path.abspath(os.path.join(os.getcwd(), \"..\", \"..\", \"laser-generic-outputs\", \"CCSSIRoutputs2\")) params_df = pd.read_csv(os.path.join(output_folder, \"params.csv\"))  outputs = [] nsims = 200 npatches = 61 pops = np.logspace(3, 6, npatches)  for i in range(nsims):     output_file = os.path.join(output_folder, f\"CCSSIRoutputs_{i}.npy\")     outputs.append(np.load(output_file))  outputs = np.array(outputs) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[5], line 11\n      9 for i in range(nsims):\n     10     output_file = os.path.join(output_folder, f\"CCSSIRoutputs_{i}.npy\")\n---&gt; 11     outputs.append(np.load(output_file))\n     13 outputs = np.array(outputs)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/lib/_npyio_impl.py:454, in load(file, mmap_mode, allow_pickle, fix_imports, encoding, max_header_size)\n    452     own_fid = False\n    453 else:\n--&gt; 454     fid = stack.enter_context(open(os.fspath(file), \"rb\"))\n    455     own_fid = True\n    457 # Code to distinguish from NumPy binary files and pickles.\n\nFileNotFoundError: [Errno 2] No such file or directory: '/home/runner/work/laser-generic/laser-generic/laser-generic-outputs/CCSSIRoutputs2/CCSSIRoutputs_0.npy'</pre> In\u00a0[6]: Copied! <pre>CCS1 = []\nCCS2 = []\n\nfor sim in range(nsims):\n    end_output = outputs[sim, -1, :]\n    zero_pops = pops[end_output == 0]\n    nonzero_pops = pops[end_output != 0]\n\n    if len(zero_pops) &gt; 0:\n        CCS2.append(np.max(zero_pops))\n    else:\n        CCS2.append(None)\n\n    if len(nonzero_pops) &gt; 0:\n        CCS1.append(np.min(nonzero_pops))\n    else:\n        CCS1.append(None)\n\nresults_df = pd.DataFrame({\"largest_zero_pop\": CCS2, \"smallest_nonzero_pop\": CCS1})\n\nprint(results_df)\n</pre> CCS1 = [] CCS2 = []  for sim in range(nsims):     end_output = outputs[sim, -1, :]     zero_pops = pops[end_output == 0]     nonzero_pops = pops[end_output != 0]      if len(zero_pops) &gt; 0:         CCS2.append(np.max(zero_pops))     else:         CCS2.append(None)      if len(nonzero_pops) &gt; 0:         CCS1.append(np.min(nonzero_pops))     else:         CCS1.append(None)  results_df = pd.DataFrame({\"largest_zero_pop\": CCS2, \"smallest_nonzero_pop\": CCS1})  print(results_df) <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[6], line 5\n      2 CCS2 = []\n      4 for sim in range(nsims):\n----&gt; 5     end_output = outputs[sim, -1, :]\n      6     zero_pops = pops[end_output == 0]\n      7     nonzero_pops = pops[end_output != 0]\n\nTypeError: list indices must be integers or slices, not tuple</pre> In\u00a0[7]: Copied! <pre>fig, axs = plt.subplots(3, 2, figsize=(15, 15))\n\n# Plot largest_zero_pop against R0, infmean, and cbr\naxs[0, 0].scatter(params_df[\"R0\"], results_df[\"largest_zero_pop\"])\naxs[0, 0].set_xlabel(\"R0\")\naxs[0, 0].set_ylabel(\"Largest Zero Pop\")\naxs[0, 0].set_title(\"Largest Zero Pop vs R0\")\naxs[0, 0].set_yscale(\"log\")\n\naxs[1, 0].scatter(params_df[\"infmean\"], results_df[\"largest_zero_pop\"])\naxs[1, 0].set_xlabel(\"Infectious Mean Period\")\naxs[1, 0].set_ylabel(\"Largest Zero Pop\")\naxs[1, 0].set_title(\"Largest Zero Pop vs Infectious Mean Period\")\naxs[1, 0].set_yscale(\"log\")\n\naxs[2, 0].scatter(params_df[\"cbr\"], results_df[\"largest_zero_pop\"])\naxs[2, 0].set_xlabel(\"Contact Birth Rate\")\naxs[2, 0].set_ylabel(\"Largest Zero Pop\")\naxs[2, 0].set_title(\"Largest Zero Pop vs Contact Birth Rate\")\naxs[2, 0].set_yscale(\"log\")\n\n# Plot smallest_nonzero_pop against R0, infmean, and cbr\naxs[0, 1].scatter(params_df[\"R0\"], results_df[\"smallest_nonzero_pop\"])\naxs[0, 1].set_xlabel(\"R0\")\naxs[0, 1].set_ylabel(\"Smallest Nonzero Pop\")\naxs[0, 1].set_title(\"Smallest Nonzero Pop vs R0\")\naxs[0, 1].set_yscale(\"log\")\n\naxs[1, 1].scatter(params_df[\"infmean\"], results_df[\"smallest_nonzero_pop\"])\naxs[1, 1].set_xlabel(\"Infectious Mean Period\")\naxs[1, 1].set_ylabel(\"Smallest Nonzero Pop\")\naxs[1, 1].set_title(\"Smallest Nonzero Pop vs Infectious Mean Period\")\naxs[1, 1].set_yscale(\"log\")\n\naxs[2, 1].scatter(params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"])\naxs[2, 1].set_xlabel(\"Contact Birth Rate\")\naxs[2, 1].set_ylabel(\"Smallest Nonzero Pop\")\naxs[2, 1].set_title(\"Smallest Nonzero Pop vs Contact Birth Rate\")\naxs[2, 1].set_yscale(\"log\")\n\nplt.tight_layout()\nplt.show()\n</pre> fig, axs = plt.subplots(3, 2, figsize=(15, 15))  # Plot largest_zero_pop against R0, infmean, and cbr axs[0, 0].scatter(params_df[\"R0\"], results_df[\"largest_zero_pop\"]) axs[0, 0].set_xlabel(\"R0\") axs[0, 0].set_ylabel(\"Largest Zero Pop\") axs[0, 0].set_title(\"Largest Zero Pop vs R0\") axs[0, 0].set_yscale(\"log\")  axs[1, 0].scatter(params_df[\"infmean\"], results_df[\"largest_zero_pop\"]) axs[1, 0].set_xlabel(\"Infectious Mean Period\") axs[1, 0].set_ylabel(\"Largest Zero Pop\") axs[1, 0].set_title(\"Largest Zero Pop vs Infectious Mean Period\") axs[1, 0].set_yscale(\"log\")  axs[2, 0].scatter(params_df[\"cbr\"], results_df[\"largest_zero_pop\"]) axs[2, 0].set_xlabel(\"Contact Birth Rate\") axs[2, 0].set_ylabel(\"Largest Zero Pop\") axs[2, 0].set_title(\"Largest Zero Pop vs Contact Birth Rate\") axs[2, 0].set_yscale(\"log\")  # Plot smallest_nonzero_pop against R0, infmean, and cbr axs[0, 1].scatter(params_df[\"R0\"], results_df[\"smallest_nonzero_pop\"]) axs[0, 1].set_xlabel(\"R0\") axs[0, 1].set_ylabel(\"Smallest Nonzero Pop\") axs[0, 1].set_title(\"Smallest Nonzero Pop vs R0\") axs[0, 1].set_yscale(\"log\")  axs[1, 1].scatter(params_df[\"infmean\"], results_df[\"smallest_nonzero_pop\"]) axs[1, 1].set_xlabel(\"Infectious Mean Period\") axs[1, 1].set_ylabel(\"Smallest Nonzero Pop\") axs[1, 1].set_title(\"Smallest Nonzero Pop vs Infectious Mean Period\") axs[1, 1].set_yscale(\"log\")  axs[2, 1].scatter(params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"]) axs[2, 1].set_xlabel(\"Contact Birth Rate\") axs[2, 1].set_ylabel(\"Smallest Nonzero Pop\") axs[2, 1].set_title(\"Smallest Nonzero Pop vs Contact Birth Rate\") axs[2, 1].set_yscale(\"log\")  plt.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 4\n      1 fig, axs = plt.subplots(3, 2, figsize=(15, 15))\n      3 # Plot largest_zero_pop against R0, infmean, and cbr\n----&gt; 4 axs[0, 0].scatter(params_df[\"R0\"], results_df[\"largest_zero_pop\"])\n      5 axs[0, 0].set_xlabel(\"R0\")\n      6 axs[0, 0].set_ylabel(\"Largest Zero Pop\")\n\nNameError: name 'results_df' is not defined</pre> In\u00a0[8]: Copied! <pre>from mpl_toolkits.mplot3d import Axes3D\n\nfig = plt.figure(figsize=(14, 7))\n\n# Surface plot for largest_zero_pop\nax1 = fig.add_subplot(121, projection=\"3d\")\nax1.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"largest_zero_pop\"], cmap=\"viridis\")\nax1.set_xlabel(\"Infectious Mean Period\")\nax1.set_ylabel(\"Contact Birth Rate\")\nax1.set_zlabel(\"Largest Zero Pop\")\nax1.set_zscale(\"log\")\n\nax1.set_title(\"Largest Zero Pop vs Infectious Mean Period and Contact Birth Rate\")\n\n# Surface plot for smallest_nonzero_pop\nax2 = fig.add_subplot(122, projection=\"3d\")\nax2.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"], cmap=\"viridis\")\nax2.set_xlabel(\"Infectious Mean Period\")\nax2.set_ylabel(\"Contact Birth Rate\")\nax2.set_zlabel(\"Smallest Nonzero Pop\")\nax2.set_title(\"Smallest Nonzero Pop vs Infectious Mean Period and Contact Birth Rate\")\nax2.set_zscale(\"log\")\nplt.tight_layout()\nplt.show()\n</pre> from mpl_toolkits.mplot3d import Axes3D  fig = plt.figure(figsize=(14, 7))  # Surface plot for largest_zero_pop ax1 = fig.add_subplot(121, projection=\"3d\") ax1.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"largest_zero_pop\"], cmap=\"viridis\") ax1.set_xlabel(\"Infectious Mean Period\") ax1.set_ylabel(\"Contact Birth Rate\") ax1.set_zlabel(\"Largest Zero Pop\") ax1.set_zscale(\"log\")  ax1.set_title(\"Largest Zero Pop vs Infectious Mean Period and Contact Birth Rate\")  # Surface plot for smallest_nonzero_pop ax2 = fig.add_subplot(122, projection=\"3d\") ax2.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"smallest_nonzero_pop\"], cmap=\"viridis\") ax2.set_xlabel(\"Infectious Mean Period\") ax2.set_ylabel(\"Contact Birth Rate\") ax2.set_zlabel(\"Smallest Nonzero Pop\") ax2.set_title(\"Smallest Nonzero Pop vs Infectious Mean Period and Contact Birth Rate\") ax2.set_zscale(\"log\") plt.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 7\n      5 # Surface plot for largest_zero_pop\n      6 ax1 = fig.add_subplot(121, projection=\"3d\")\n----&gt; 7 ax1.plot_trisurf(params_df[\"infmean\"], params_df[\"cbr\"], results_df[\"largest_zero_pop\"], cmap=\"viridis\")\n      8 ax1.set_xlabel(\"Infectious Mean Period\")\n      9 ax1.set_ylabel(\"Contact Birth Rate\")\n\nNameError: name 'results_df' is not defined</pre> In\u00a0[9]: Copied! <pre># from scipy.optimize import curve_fit\n\n# # Calculate alpha\n# alpha = params_df['infmean'] * params_df['cbr']\n# R0 = params_df['R0']\n\n# # Define the fitting function\n# def fitting_function(alpha, R0, constant, a, b, c):\n#     return constant * alpha**a * (R0)**b * (R0-1)**c\n\n# # Prepare the data for fitting'\n# # Drop NA values from smallest_nonzero_pop and corresponding entries from alpha and R0\n# valid_indices = ~results_df['smallest_nonzero_pop'].isna()\n# alpha_values = alpha[valid_indices].values\n# R0_values = params_df['R0'][valid_indices].values\n# smallest_nonzero_pop_values = results_df['smallest_nonzero_pop'][valid_indices].values\n\n\n# # Fit the function to the data\n# popt, pcov = curve_fit(lambda alpha, constant, a, b, c: fitting_function(alpha, R0_values, constant, a, b, c), alpha_values, smallest_nonzero_pop_values)\n\n# # Extract the optimal parameters\n# constant_opt, a_opt, b_opt, c_opt = popt\nprint(f\"Optimal parameters: constant = {constant_opt}, a = {a_opt}, b = {b_opt}\")\n# # Plot smallest_nonzero_pop against alpha\n# plt.figure()\n\n# # Plot the best fit line\n# #\n# # Create a meshgrid for alpha and R0 values\n# alpha_fit = np.linspace(min(alpha_values), max(alpha_values), 100)\n# R0_fit = np.linspace(min(R0_values), max(R0_values), 100)\n# alpha_fit, R0_fit = np.meshgrid(alpha_fit, R0_fit)\n\n# # Calculate the best fit surface\n# best_fit_surface = fitting_function(alpha_fit, R0_fit, constant_opt, a_opt, b_opt)\n\n# Plot the best fit surface\nfig = plt.figure(figsize=(14, 7))\nax = fig.add_subplot(111, projection=\"3d\")\n\n# Calculate 1/alpha\ninv_alpha_fit = 1 / alpha_fit\ninv_alpha_values = 1 / alpha_values\n\n# Plot the best fit surface\nax.plot_surface(inv_alpha_fit, R0_fit, np.log10(best_fit_surface), cmap=\"viridis\", alpha=0.7)\n\n# Scatter the real values for comparison\nax.scatter(inv_alpha_values, R0_values, np.log10(smallest_nonzero_pop_values), color=\"red\", label=\"Real Values\")\n\nax.set_xlabel(\"1/Alpha (1/(inf_mean * cbr))\")\nax.set_ylabel(\"R0\")\nax.set_zlabel(\"Log(Smallest Nonzero Pop)\")\nax.set_title(\"Best Fit Surface and Real Values\")\n\n# Add the best fit equation as a textbox\nequation_text = f\"Best fit: y = {constant_opt:.2e} * alpha^{a_opt:.2f} * (R0/(R0-1))^{b_opt:.2f}\"\n# plt.text(0.05, 0.95, equation_text, transform=plt.gca().transAxes, fontsize=12, verticalalignment='top', bbox=dict(facecolor='white', alpha=0.5))\n\nplt.tight_layout()\n# Rotate the camera for a better viewing angle\nax.view_init(elev=20, azim=255)\nplt.show()\n</pre> # from scipy.optimize import curve_fit  # # Calculate alpha # alpha = params_df['infmean'] * params_df['cbr'] # R0 = params_df['R0']  # # Define the fitting function # def fitting_function(alpha, R0, constant, a, b, c): #     return constant * alpha**a * (R0)**b * (R0-1)**c  # # Prepare the data for fitting' # # Drop NA values from smallest_nonzero_pop and corresponding entries from alpha and R0 # valid_indices = ~results_df['smallest_nonzero_pop'].isna() # alpha_values = alpha[valid_indices].values # R0_values = params_df['R0'][valid_indices].values # smallest_nonzero_pop_values = results_df['smallest_nonzero_pop'][valid_indices].values   # # Fit the function to the data # popt, pcov = curve_fit(lambda alpha, constant, a, b, c: fitting_function(alpha, R0_values, constant, a, b, c), alpha_values, smallest_nonzero_pop_values)  # # Extract the optimal parameters # constant_opt, a_opt, b_opt, c_opt = popt print(f\"Optimal parameters: constant = {constant_opt}, a = {a_opt}, b = {b_opt}\") # # Plot smallest_nonzero_pop against alpha # plt.figure()  # # Plot the best fit line # # # # Create a meshgrid for alpha and R0 values # alpha_fit = np.linspace(min(alpha_values), max(alpha_values), 100) # R0_fit = np.linspace(min(R0_values), max(R0_values), 100) # alpha_fit, R0_fit = np.meshgrid(alpha_fit, R0_fit)  # # Calculate the best fit surface # best_fit_surface = fitting_function(alpha_fit, R0_fit, constant_opt, a_opt, b_opt)  # Plot the best fit surface fig = plt.figure(figsize=(14, 7)) ax = fig.add_subplot(111, projection=\"3d\")  # Calculate 1/alpha inv_alpha_fit = 1 / alpha_fit inv_alpha_values = 1 / alpha_values  # Plot the best fit surface ax.plot_surface(inv_alpha_fit, R0_fit, np.log10(best_fit_surface), cmap=\"viridis\", alpha=0.7)  # Scatter the real values for comparison ax.scatter(inv_alpha_values, R0_values, np.log10(smallest_nonzero_pop_values), color=\"red\", label=\"Real Values\")  ax.set_xlabel(\"1/Alpha (1/(inf_mean * cbr))\") ax.set_ylabel(\"R0\") ax.set_zlabel(\"Log(Smallest Nonzero Pop)\") ax.set_title(\"Best Fit Surface and Real Values\")  # Add the best fit equation as a textbox equation_text = f\"Best fit: y = {constant_opt:.2e} * alpha^{a_opt:.2f} * (R0/(R0-1))^{b_opt:.2f}\" # plt.text(0.05, 0.95, equation_text, transform=plt.gca().transAxes, fontsize=12, verticalalignment='top', bbox=dict(facecolor='white', alpha=0.5))  plt.tight_layout() # Rotate the camera for a better viewing angle ax.view_init(elev=20, azim=255) plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 24\n      1 # from scipy.optimize import curve_fit\n      2 \n      3 # # Calculate alpha\n   (...)     22 # # Extract the optimal parameters\n     23 # constant_opt, a_opt, b_opt, c_opt = popt\n---&gt; 24 print(f\"Optimal parameters: constant = {constant_opt}, a = {a_opt}, b = {b_opt}\")\n     25 # # Plot smallest_nonzero_pop against alpha\n     26 # plt.figure()\n     27 \n   (...)     37 \n     38 # Plot the best fit surface\n     39 fig = plt.figure(figsize=(14, 7))\n\nNameError: name 'constant_opt' is not defined</pre> In\u00a0[10]: Copied! <pre>plt.figure(figsize=(10, 6))\nplt.scatter(inv_alpha_values, smallest_nonzero_pop_values)\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.xlabel(\"1/Alpha (1/(inf_mean * cbr))\")\nplt.ylabel(\"Smallest Nonzero Pop\")\nplt.title(\"Smallest Nonzero Pop vs 1/Alpha\")\nplt.grid(True, which=\"both\", ls=\"--\")\nplt.show()\n</pre> plt.figure(figsize=(10, 6)) plt.scatter(inv_alpha_values, smallest_nonzero_pop_values) plt.xscale(\"log\") plt.yscale(\"log\") plt.xlabel(\"1/Alpha (1/(inf_mean * cbr))\") plt.ylabel(\"Smallest Nonzero Pop\") plt.title(\"Smallest Nonzero Pop vs 1/Alpha\") plt.grid(True, which=\"both\", ls=\"--\") plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 2\n      1 plt.figure(figsize=(10, 6))\n----&gt; 2 plt.scatter(inv_alpha_values, smallest_nonzero_pop_values)\n      3 plt.xscale(\"log\")\n      4 plt.yscale(\"log\")\n\nNameError: name 'inv_alpha_values' is not defined</pre> <pre>&lt;Figure size 1000x600 with 0 Axes&gt;</pre> In\u00a0[11]: Copied! <pre>output_folder = \"..\\..\\laser-generic-outputs\\CCSSIRoutputs\"\n</pre> output_folder = \"..\\..\\laser-generic-outputs\\CCSSIRoutputs\" <pre>&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\.'\n&lt;&gt;:1: SyntaxWarning: invalid escape sequence '\\.'\n/tmp/ipykernel_2480/2486691589.py:1: SyntaxWarning: invalid escape sequence '\\.'\n  output_folder = \"..\\..\\laser-generic-outputs\\CCSSIRoutputs\"\n</pre> In\u00a0[33]: Copied! <pre>\n</pre> <pre>['twopatchSIRoutputs', 'CCSSIRoutputs']\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/07_SIR_CCS/#exploring-the-critical-community-size-of-an-sir-model","title":"Exploring the critical community size of an SIR model\u00b6","text":"<p>Use multiple nodes with no connection to identify the critical community size and its dependence on disease and demographic parameters</p>"},{"location":"notebooks/08_2patch_SIR_wbirths_correlation/","title":"The relationship between spatial coupling and incidence correlation in a 2-patch model","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nfrom laser.core.propertyset import PropertySet\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import fsolve\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Model\nfrom laser.generic import Infection\nfrom laser.generic import Susceptibility\nfrom laser.generic import Transmission\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic.importation import Infect_Random_Agents\n\nfrom laser.generic.utils import set_initial_susceptibility_in_patch\nfrom laser.generic.utils import seed_infections_in_patch\n\n%load_ext line_profiler\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd from laser.core.propertyset import PropertySet import matplotlib.pyplot as plt from scipy.optimize import fsolve  import laser.core import laser.generic from laser.generic import Model from laser.generic import Infection from laser.generic import Susceptibility from laser.generic import Transmission from laser.generic import Births_ConstantPop from laser.generic.importation import Infect_Random_Agents  from laser.generic.utils import set_initial_susceptibility_in_patch from laser.generic.utils import seed_infections_in_patch  %load_ext line_profiler  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 19\n     16 from laser.generic.utils import set_initial_susceptibility_in_patch\n     17 from laser.generic.utils import seed_infections_in_patch\n---&gt; 19 get_ipython().run_line_magic('load_ext', 'line_profiler')\n     21 print(f\"{np.__version__=}\")\n     22 print(f\"{laser.core.__version__=}\")\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:2504, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2502     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2503 with self.builtin_trap:\n-&gt; 2504     result = fn(*args, **kwargs)\n   2506 # The code below prevents the output from being displayed\n   2507 # when using magics with decorator @output_can_be_silenced\n   2508 # when the last Python token in the expression is a ';'.\n   2509 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/magics/extension.py:33, in ExtensionMagics.load_ext(self, module_str)\n     31 if not module_str:\n     32     raise UsageError('Missing module name.')\n---&gt; 33 res = self.shell.extension_manager.load_extension(module_str)\n     35 if res == 'already loaded':\n     36     print(\"The %s extension is already loaded. To reload it, use:\" % module_str)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/extensions.py:62, in ExtensionManager.load_extension(self, module_str)\n     55 \"\"\"Load an IPython extension by its module name.\n     56 \n     57 Returns the string \"already loaded\" if the extension is already loaded,\n     58 \"no load function\" if the module doesn't have a load_ipython_extension\n     59 function, or None if it succeeded.\n     60 \"\"\"\n     61 try:\n---&gt; 62     return self._load_extension(module_str)\n     63 except ModuleNotFoundError:\n     64     if module_str in BUILTINS_EXTS:\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/extensions.py:77, in ExtensionManager._load_extension(self, module_str)\n     75 with self.shell.builtin_trap:\n     76     if module_str not in sys.modules:\n---&gt; 77         mod = import_module(module_str)\n     78     mod = sys.modules[module_str]\n     79     if self._call_load_ipython_extension(mod):\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/importlib/__init__.py:90, in import_module(name, package)\n     88             break\n     89         level += 1\n---&gt; 90 return _bootstrap._gcd_import(name[level:], package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1387, in _gcd_import(name, package, level)\n\nFile &lt;frozen importlib._bootstrap&gt;:1360, in _find_and_load(name, import_)\n\nFile &lt;frozen importlib._bootstrap&gt;:1324, in _find_and_load_unlocked(name, import_)\n\nModuleNotFoundError: No module named 'line_profiler'</pre> In\u00a0[2]: Copied! <pre>%%capture\nimport os\n\n# Set parameters to match those of Keeling &amp; Rohani, 2002.  They have a constant importation rate of 5.5e-5*sqrt(N) per day,\n# which for this sim would be something like 40 per year.  I'm importing 6 per year, but I don't think that should be the big deal.\n# more important is setting the birth, R0, and infectious period to their numbers and then seeing the\n# connectivity-correlation relationship.\nnticks = 36500\nscenario = pd.DataFrame(data=[[\"patch1\", 1e6], [\"patch2\", 1e6]], columns=[\"name\", \"population\"])\nparameters = PropertySet(\n    {\n        \"seed\": 4,\n        \"nticks\": nticks,\n        \"verbose\": True,\n        \"beta\": 17 / 13,\n        \"inf_mean\": 13,\n        \"cbr\": 20.277294,\n        \"importation_period\": 180,\n        \"importation_count\": 3,\n        \"importation_start\": 500,\n    }\n)\n\nmu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\nR0 = parameters.beta / (mu + 1 / parameters.inf_mean)\nnsims = 100\ni = 0\noutputs = np.zeros((nsims, parameters.nticks, scenario.shape[0]))\n# Create a folder to store the outputs\noutput_folder = \"twopatchSIRoutputs\"\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\nfor connection in np.logspace(-4, -1, nsims):\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Infection,\n        Infect_Random_Agents,\n    ]\n\n    # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch\n    # Want to see how connectivity drives correlation over time.\n    model.patches.network = np.array([[0, connection], [connection, 0]])\n    set_initial_susceptibility_in_patch(model, 1, 1 / R0 + 0.02 * np.random.normal())\n    set_initial_susceptibility_in_patch(model, 0, 1 / R0 + 0.02 * np.random.normal())\n    seed_infections_in_patch(model, ipatch=0, ninfections=3)\n\n    model.run()\n    outputs[i, :, :] = model.patches.cases\n    np.save(f\"{output_folder}/twopatchSIRoutputs_{i}.npy\", outputs[i, :, :])\n    i += 1\n</pre> %%capture import os  # Set parameters to match those of Keeling &amp; Rohani, 2002.  They have a constant importation rate of 5.5e-5*sqrt(N) per day, # which for this sim would be something like 40 per year.  I'm importing 6 per year, but I don't think that should be the big deal. # more important is setting the birth, R0, and infectious period to their numbers and then seeing the # connectivity-correlation relationship. nticks = 36500 scenario = pd.DataFrame(data=[[\"patch1\", 1e6], [\"patch2\", 1e6]], columns=[\"name\", \"population\"]) parameters = PropertySet(     {         \"seed\": 4,         \"nticks\": nticks,         \"verbose\": True,         \"beta\": 17 / 13,         \"inf_mean\": 13,         \"cbr\": 20.277294,         \"importation_period\": 180,         \"importation_count\": 3,         \"importation_start\": 500,     } )  mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1 R0 = parameters.beta / (mu + 1 / parameters.inf_mean) nsims = 100 i = 0 outputs = np.zeros((nsims, parameters.nticks, scenario.shape[0])) # Create a folder to store the outputs output_folder = \"twopatchSIRoutputs\" if not os.path.exists(output_folder):     os.makedirs(output_folder) for connection in np.logspace(-4, -1, nsims):     model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Infection,         Infect_Random_Agents,     ]      # Start them slightly asynchronously - different initial susceptibilities, infection only in 1 patch     # Want to see how connectivity drives correlation over time.     model.patches.network = np.array([[0, connection], [connection, 0]])     set_initial_susceptibility_in_patch(model, 1, 1 / R0 + 0.02 * np.random.normal())     set_initial_susceptibility_in_patch(model, 0, 1 / R0 + 0.02 * np.random.normal())     seed_infections_in_patch(model, ipatch=0, ninfections=3)      model.run()     outputs[i, :, :] = model.patches.cases     np.save(f\"{output_folder}/twopatchSIRoutputs_{i}.npy\", outputs[i, :, :])     i += 1 <pre>\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[2], line 49\n     46 set_initial_susceptibility_in_patch(model, 0, 1 / R0 + 0.02 * np.random.normal())\n     47 seed_infections_in_patch(model, ipatch=0, ninfections=3)\n---&gt; 49 model.run()\n     50 outputs[i, :, :] = model.patches.cases\n     51 np.save(f\"{output_folder}/twopatchSIRoutputs_{i}.npy\", outputs[i, :, :])\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/model.py:270, in Model.run(self)\n    268 for phase in self.phases:\n    269     tstart = datetime.now(tz=None)  # noqa: DTZ005\n--&gt; 270     phase(self, tick)\n    271     tfinish = datetime.now(tz=None)  # noqa: DTZ005\n    272     delta = tfinish - tstart\n\nFile ~/work/laser-generic/laser-generic/src/laser/generic/births.py:306, in Births_ConstantPop.__call__(self, model, tick)\n    302     model.population.dob[indices] = tick  # set to current tick\n    303 model.population.state[indices] = 0\n    305 model.patches.exposed_test[tick + 1, :] -= np.bincount(\n--&gt; 306     model.population.nodeid[indices], weights=(model.population.etimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    307 ).astype(np.uint32)\n    309 model.patches.cases_test[tick + 1, :] -= np.bincount(\n    310     model.population.nodeid[indices], weights=(model.population.itimer[indices] &gt; 0), minlength=model.patches.populations.shape[1]\n    311 ).astype(np.uint32)\n    313 model.patches.recovered_test[tick + 1, :] -= np.bincount(\n    314     model.population.nodeid[indices],\n    315     weights=(\n   (...)    320     minlength=model.patches.populations.shape[1],\n    321 ).astype(np.uint32)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/laser/core/laserframe.py:146, in LaserFrame.__getattr__(self, name)\n    144     # Handle scalar and vector properties\n    145     return backing[0 : self.count] if len(backing.shape) == 1 else backing[:, 0 : self.count]\n--&gt; 146 raise AttributeError(f\"'LaserFrame' object has no attribute '{name}'\")\n\nAttributeError: 'LaserFrame' object has no attribute 'etimer'</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[5], line 3\n      1 # Extract outputs for patch 1 and patch 2\n----&gt; 3 with pd.ExcelWriter('2patch_SIR_wbirths_simulations.xlsx') as writer:\n      4     for sim in range(outputs.shape[0]):\n      5         df_sim = pd.DataFrame(outputs[sim, :, :], columns=['Patch1', 'Patch2'])\n\nFile ~/Documents/GitHub/laser-generic/.venv/lib/python3.11/site-packages/pandas/io/excel/_openpyxl.py:57, in OpenpyxlWriter.__init__(self, path, engine, date_format, datetime_format, mode, storage_options, if_sheet_exists, engine_kwargs, **kwargs)\n     44 def __init__(\n     45     self,\n     46     path: FilePath | WriteExcelBuffer | ExcelWriter,\n   (...)\n     55 ) -&gt; None:\n     56     # Use the openpyxl module as the Excel writer.\n---&gt; 57     from openpyxl.workbook import Workbook\n     59     engine_kwargs = combine_kwargs(engine_kwargs, kwargs)\n     61     super().__init__(\n     62         path,\n     63         mode=mode,\n   (...)\n     66         engine_kwargs=engine_kwargs,\n     67     )\n\nModuleNotFoundError: No module named 'openpyxl'</pre> In\u00a0[3]: Copied! <pre>correlations = []\nlast_50_years = 50 * 365  # 50 years in days\n\nfor sim in range(outputs.shape[0]):\n    patch1_data = outputs[sim, -last_50_years:, 0]\n    patch2_data = outputs[sim, -last_50_years:, 1]\n    correlation = np.corrcoef(patch1_data, patch2_data)[0, 1]\n    correlations.append(correlation)\n\ncorrelations = np.array(correlations)\nprint(correlations)\n</pre> correlations = [] last_50_years = 50 * 365  # 50 years in days  for sim in range(outputs.shape[0]):     patch1_data = outputs[sim, -last_50_years:, 0]     patch2_data = outputs[sim, -last_50_years:, 1]     correlation = np.corrcoef(patch1_data, patch2_data)[0, 1]     correlations.append(correlation)  correlations = np.array(correlations) print(correlations) <pre>[nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan\n nan nan nan nan nan nan nan nan nan nan]\n</pre> <pre>/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/lib/_function_base_impl.py:3065: RuntimeWarning: invalid value encountered in divide\n  c /= stddev[:, None]\n</pre> In\u00a0[4]: Copied! <pre>from scipy.optimize import curve_fit\n\nx = np.logspace(-4, -1, nsims)\n\n\n# Define the function to fit\ndef func(x, psi, beta):\n    return beta + x / (psi + x)\n\n\n# Fit the curve\npopt, pcov = curve_fit(func, x, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002]))\npsi_opt = popt[0]\nbeta_opt = popt[1]\nplt.plot(x, correlations, \".\")\nplt.xscale(\"log\")\n# Plot the fitted curve\nplt.plot(x, func(x, psi_opt, beta_opt), label=f\"Fitted curve: y = {beta_opt:.4f} + x / ({psi_opt:.4f} + x)\")\nplt.legend()\n</pre> from scipy.optimize import curve_fit  x = np.logspace(-4, -1, nsims)   # Define the function to fit def func(x, psi, beta):     return beta + x / (psi + x)   # Fit the curve popt, pcov = curve_fit(func, x, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002])) psi_opt = popt[0] beta_opt = popt[1] plt.plot(x, correlations, \".\") plt.xscale(\"log\") # Plot the fitted curve plt.plot(x, func(x, psi_opt, beta_opt), label=f\"Fitted curve: y = {beta_opt:.4f} + x / ({psi_opt:.4f} + x)\") plt.legend() <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[4], line 12\n      8     return beta + x / (psi + x)\n     11 # Fit the curve\n---&gt; 12 popt, pcov = curve_fit(func, x, correlations, p0=[0.01, 0], bounds=([1e-6, -0.00002], [1, 0.00002]))\n     13 psi_opt = popt[0]\n     14 beta_opt = popt[1]\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/scipy/optimize/_minpack_py.py:936, in curve_fit(f, xdata, ydata, p0, sigma, absolute_sigma, check_finite, bounds, method, jac, full_output, nan_policy, **kwargs)\n    934 # optimization may produce garbage for float32 inputs, cast them to float64\n    935 if check_finite:\n--&gt; 936     ydata = np.asarray_chkfinite(ydata, float)\n    937 else:\n    938     ydata = np.asarray(ydata, float)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/lib/_function_base_impl.py:665, in asarray_chkfinite(a, dtype, order)\n    663 a = asarray(a, dtype=dtype, order=order)\n    664 if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():\n--&gt; 665     raise ValueError(\n    666         \"array must not contain infs or NaNs\")\n    667 return a\n\nValueError: array must not contain infs or NaNs</pre>"},{"location":"notebooks/08_2patch_SIR_wbirths_correlation/#the-relationship-between-spatial-coupling-and-incidence-correlation-in-a-2-patch-model","title":"The relationship between spatial coupling and incidence correlation in a 2-patch model\u00b6","text":"<p>Ref: Keeling &amp; Rohani, Estimating spatial coupling in epidemiological systems: a mechanistic approach, Ecol. Letters (2002) 5:20-29</p>"},{"location":"notebooks/10_EW_periodicity/","title":"10 EW periodicity","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport os\nimport sys\nfrom laser.core.propertyset import PropertySet\nfrom laser.core.migration import gravity\nfrom laser.core.migration import row_normalizer\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import fsolve\n\nimport laser.core\nimport laser.generic\nfrom laser.generic import Model\nfrom laser.generic import Infection\nfrom laser.generic import Susceptibility\nfrom laser.generic import Exposure\nfrom laser.generic import Transmission\nfrom laser.generic import Births_ConstantPop\nfrom laser.generic import Births_ConstantPop_VariableBirthRate\nfrom laser.generic import Infect_Random_Agents\nfrom laser.generic.utils import set_initial_susceptibility_in_patch\nfrom laser.generic.utils import seed_infections_in_patch\nimport pickle\n\n\ndata_dir = os.path.join('..', \"data\")\nsys.path.append(data_dir)\n\nfrom EnglandWalesmeasles import data as engwal\ndistances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd import os import sys from laser.core.propertyset import PropertySet from laser.core.migration import gravity from laser.core.migration import row_normalizer import matplotlib.pyplot as plt from scipy.optimize import fsolve  import laser.core import laser.generic from laser.generic import Model from laser.generic import Infection from laser.generic import Susceptibility from laser.generic import Exposure from laser.generic import Transmission from laser.generic import Births_ConstantPop from laser.generic import Births_ConstantPop_VariableBirthRate from laser.generic import Infect_Random_Agents from laser.generic.utils import set_initial_susceptibility_in_patch from laser.generic.utils import seed_infections_in_patch import pickle   data_dir = os.path.join('..', \"data\") sys.path.append(data_dir)  from EnglandWalesmeasles import data as engwal distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 29\n     26 data_dir = os.path.join('..', \"data\")\n     27 sys.path.append(data_dir)\n---&gt; 29 from EnglandWalesmeasles import data as engwal\n     30 distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n     32 print(f\"{np.__version__=}\")\n\nModuleNotFoundError: No module named 'EnglandWalesmeasles'</pre> In\u00a0[2]: Copied! <pre>average_pop = np.array([np.mean(place.population) for place in engwal.places.values()])\naverage_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()])\naverage_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop)\naverage_pop\naverage_cbr\n</pre> average_pop = np.array([np.mean(place.population) for place in engwal.places.values()]) average_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()]) average_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop) average_pop average_cbr <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 average_pop = np.array([np.mean(place.population) for place in engwal.places.values()])\n      2 average_birthrate = np.array([np.mean(place.births/place.population) for place in engwal.places.values()])\n      3 average_cbr = 1000*np.sum(average_pop*average_birthrate)/np.sum(average_pop)\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[3]: Copied! <pre># Compute the average birthrate across all places for each year\nyears = len(next(iter(engwal.places.values())).births)\nbirths_matrix = np.array([place.births for place in engwal.places.values()])\npop_matrix = np.array([place.population for place in engwal.places.values()])\naverage_birthrate_per_year = np.sum(births_matrix, axis=0) / np.sum(pop_matrix, axis=0)\naverage_birthrate_per_year\nvarcbrs = {'rates': average_birthrate_per_year*1000, 'timesteps': np.arange(20*365, 41*365, 365)}\n</pre> # Compute the average birthrate across all places for each year years = len(next(iter(engwal.places.values())).births) births_matrix = np.array([place.births for place in engwal.places.values()]) pop_matrix = np.array([place.population for place in engwal.places.values()]) average_birthrate_per_year = np.sum(births_matrix, axis=0) / np.sum(pop_matrix, axis=0) average_birthrate_per_year varcbrs = {'rates': average_birthrate_per_year*1000, 'timesteps': np.arange(20*365, 41*365, 365)} <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 2\n      1 # Compute the average birthrate across all places for each year\n----&gt; 2 years = len(next(iter(engwal.places.values())).births)\n      3 births_matrix = np.array([place.births for place in engwal.places.values()])\n      4 pop_matrix = np.array([place.population for place in engwal.places.values()])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[4]: Copied! <pre>varcbrs\n</pre> varcbrs <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 varcbrs\n\nNameError: name 'varcbrs' is not defined</pre> In\u00a0[5]: Copied! <pre>#For starters, we will work with a constant population and constant crude birth rate over the network.  \n#This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now.\ndata = [{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\nscenario = pd.DataFrame(data)\nparameters = PropertySet(\n    {\"seed\": 4, \"nticks\": 20*365,\n    \"exp_shape\": 40, \"exp_scale\": 0.25,\n    \"verbose\": True, \"beta\": 1.2, \"inf_mean\": 10, \"inf_sigma\": 2, \"cbr\": average_cbr,\n    \"seasonality_factor\": 0.2, \"seasonality_phase\": 182,\n    \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 8*365}\n)\n\nmodel = Model(scenario, parameters)\nmodel.components = [\n    Births_ConstantPop,\n    Susceptibility,\n    Transmission,\n    Exposure,\n    Infection,\n    Infect_Random_Agents,\n]\n\nmodel.patches.network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-8, 0, 1, 2), 0.2)\n\nmu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\nR0 = parameters.beta / (mu + 1 / parameters.inf_mean)\nfor i in range(len(model.patches)):\n    set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.02 * np.random.normal())\n\nseed_infections_in_patch(model, ipatch=0, ninfections=3)\n#model.run()\n</pre> #For starters, we will work with a constant population and constant crude birth rate over the network.   #This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now. data = [{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()]  scenario = pd.DataFrame(data) parameters = PropertySet(     {\"seed\": 4, \"nticks\": 20*365,     \"exp_shape\": 40, \"exp_scale\": 0.25,     \"verbose\": True, \"beta\": 1.2, \"inf_mean\": 10, \"inf_sigma\": 2, \"cbr\": average_cbr,     \"seasonality_factor\": 0.2, \"seasonality_phase\": 182,     \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 8*365} )  model = Model(scenario, parameters) model.components = [     Births_ConstantPop,     Susceptibility,     Transmission,     Exposure,     Infection,     Infect_Random_Agents, ]  model.patches.network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-8, 0, 1, 2), 0.2)  mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1 R0 = parameters.beta / (mu + 1 / parameters.inf_mean) for i in range(len(model.patches)):     set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.02 * np.random.normal())  seed_infections_in_patch(model, ipatch=0, ninfections=3) #model.run() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 6\n      1 #For starters, we will work with a constant population and constant crude birth rate over the network.  \n      2 #This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now.\n      3 data = [{\"name\": placename,\n      4          \"population\": place.population[0],\n      5          \"latitude\": place.latitude,\n----&gt; 6          \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n      8 scenario = pd.DataFrame(data)\n      9 parameters = PropertySet(\n     10     {\"seed\": 4, \"nticks\": 20*365,\n     11     \"exp_shape\": 40, \"exp_scale\": 0.25,\n   (...)     14     \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 8*365}\n     15 )\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[6]: Copied! <pre>plt.plot(np.log10(model.patches.populations[0,:]), np.sum(model.patches.cases_test[3650:,:] == 0, axis=0)/((model.patches.cases_test.shape[0]-3650)), '.')\nplt.xlabel('Population')\nplt.ylabel('Sum of Entries (Cases == 0)')\nplt.title('Population vs Sum of Entries where Cases == 0')\nplt.show()\n</pre> plt.plot(np.log10(model.patches.populations[0,:]), np.sum(model.patches.cases_test[3650:,:] == 0, axis=0)/((model.patches.cases_test.shape[0]-3650)), '.') plt.xlabel('Population') plt.ylabel('Sum of Entries (Cases == 0)') plt.title('Population vs Sum of Entries where Cases == 0') plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 plt.plot(np.log10(model.patches.populations[0,:]), np.sum(model.patches.cases_test[3650:,:] == 0, axis=0)/((model.patches.cases_test.shape[0]-3650)), '.')\n      2 plt.xlabel('Population')\n      3 plt.ylabel('Sum of Entries (Cases == 0)')\n\nNameError: name 'model' is not defined</pre> In\u00a0[7]: Copied! <pre># Test equality for cases\n#cases_equal = np.array_equal(model.patches.cases, model.patches.cases_test[:-1, :])\n\n# Test equality for susceptibility\n#susceptibility_equal = np.array_equal(model.patches.susceptibility, model.patches.susceptibility_test[:-1, :])\n\n# Test equality for recovered\n#recovered_equal = np.array_equal(model.patches.recovered, model.patches.recovered_test[:-1, :])\n\n# Test equality for exposed\n#exposed_equal = np.array_equal(model.patches.exposed, model.patches.exposed_test[:-1, :])\n\n#cases_equal, susceptibility_equal, recovered_equal, exposed_equal\n</pre> # Test equality for cases #cases_equal = np.array_equal(model.patches.cases, model.patches.cases_test[:-1, :])  # Test equality for susceptibility #susceptibility_equal = np.array_equal(model.patches.susceptibility, model.patches.susceptibility_test[:-1, :])  # Test equality for recovered #recovered_equal = np.array_equal(model.patches.recovered, model.patches.recovered_test[:-1, :])  # Test equality for exposed #exposed_equal = np.array_equal(model.patches.exposed, model.patches.exposed_test[:-1, :])  #cases_equal, susceptibility_equal, recovered_equal, exposed_equal In\u00a0[8]: Copied! <pre>%%capture\ndata = [{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\nscenario = pd.DataFrame(data)\nlog_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n-0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\n\n#Round 2\nks = 10**(np.random.uniform(-3, -1.5, 100))\nbs = np.random.uniform(0.3, 0.8, 100)\ncs = np.random.uniform(1.0, 2.0, 100)\nbetas = np.random.uniform(0.3, 1.8, 100)\nparams_df = pd.DataFrame({\n    \"k\": ks,\n    \"b\": bs,\n    \"c\": cs\n})\nparams_df.to_csv(os.path.join('..', 'outputs3', 'params.csv'), index=False)\nfor ind in range(len(ks)):\n    k = ks[ind]\n    b = bs[ind]\n    c = cs[ind]\n    parameters = PropertySet(\n        {\"seed\": 4, \"nticks\": 40*365,\n        \"exp_shape\": 40, \"exp_scale\": 0.25,\n        \"verbose\": True, \"beta\": 3.4, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,\n        \"biweekly_beta_scalar\": np.exp(0.6*(log_betas - np.mean(log_betas))),\n        \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365\n        }\n    )\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Exposure,\n        Infection,\n        Infect_Random_Agents,\n    ]\n\n    model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, b, c)\n    rowsums = np.sum(model.patches.network, axis=1)\n    model.patches.network = model.patches.network / rowsums[:, np.newaxis] * k\n    model.patches.network = row_normalizer(model.patches.network, 0.2)\n\n    mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1\n    R0 = parameters.beta / (mu + 1 / parameters.inf_mean)\n    for i in range(len(model.patches)):\n        set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.2/R0 * np.random.normal())\n\n    seed_infections_in_patch(model, ipatch=507, ninfections=3)\n    model.run()\n    output_path = os.path.join('..', 'outputs3', f\"EWoutputs_gravity_{int(ind)}.pkl\")\n    for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:\n        if hasattr(model.patches, attr):\n            delattr(model.patches, attr)\n    with open(output_path, \"wb\") as file:\n        pickle.dump(model.patches, file)\n</pre> %%capture data = [{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()] scenario = pd.DataFrame(data) log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074, -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])   #Round 2 ks = 10**(np.random.uniform(-3, -1.5, 100)) bs = np.random.uniform(0.3, 0.8, 100) cs = np.random.uniform(1.0, 2.0, 100) betas = np.random.uniform(0.3, 1.8, 100) params_df = pd.DataFrame({     \"k\": ks,     \"b\": bs,     \"c\": cs }) params_df.to_csv(os.path.join('..', 'outputs3', 'params.csv'), index=False) for ind in range(len(ks)):     k = ks[ind]     b = bs[ind]     c = cs[ind]     parameters = PropertySet(         {\"seed\": 4, \"nticks\": 40*365,         \"exp_shape\": 40, \"exp_scale\": 0.25,         \"verbose\": True, \"beta\": 3.4, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,         \"biweekly_beta_scalar\": np.exp(0.6*(log_betas - np.mean(log_betas))),         \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365         }     )      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Exposure,         Infection,         Infect_Random_Agents,     ]      model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, b, c)     rowsums = np.sum(model.patches.network, axis=1)     model.patches.network = model.patches.network / rowsums[:, np.newaxis] * k     model.patches.network = row_normalizer(model.patches.network, 0.2)      mu = (1 + parameters.cbr / 1000) ** (1 / 365) - 1     R0 = parameters.beta / (mu + 1 / parameters.inf_mean)     for i in range(len(model.patches)):         set_initial_susceptibility_in_patch(model, i, 1 / R0 + 0.2/R0 * np.random.normal())      seed_infections_in_patch(model, ipatch=507, ninfections=3)     model.run()     output_path = os.path.join('..', 'outputs3', f\"EWoutputs_gravity_{int(ind)}.pkl\")     for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:         if hasattr(model.patches, attr):             delattr(model.patches, attr)     with open(output_path, \"wb\") as file:         pickle.dump(model.patches, file)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 4\n      1 data = [{\"name\": placename,\n      2          \"population\": place.population[0],\n      3          \"latitude\": place.latitude,\n----&gt; 4          \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n      5 scenario = pd.DataFrame(data)\n      6 log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n      7 -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> Out[\u00a0]: <pre>array([1.00000000e-09, 1.37382380e-09, 1.88739182e-09, 2.59294380e-09,\n       3.56224789e-09, 4.89390092e-09, 6.72335754e-09, 9.23670857e-09,\n       1.26896100e-08, 1.74332882e-08, 2.39502662e-08, 3.29034456e-08,\n       4.52035366e-08, 6.21016942e-08, 8.53167852e-08, 1.17210230e-07,\n       1.61026203e-07, 2.21221629e-07, 3.03919538e-07, 4.17531894e-07,\n       5.73615251e-07, 7.88046282e-07, 1.08263673e-06, 1.48735211e-06,\n       2.04335972e-06, 2.80721620e-06, 3.85662042e-06, 5.29831691e-06,\n       7.27895384e-06, 1.00000000e-05])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[9]: Copied! <pre>plt.plot(x.cases_test[:, 507], label=\"Susceptibility\")\nplt.xlim(12500, 13000)\n</pre> plt.plot(x.cases_test[:, 507], label=\"Susceptibility\") plt.xlim(12500, 13000) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 plt.plot(x.cases_test[:, 507], label=\"Susceptibility\")\n      2 plt.xlim(12500, 13000)\n\nNameError: name 'x' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> Out[\u00a0]: <pre>30182538</pre> In\u00a0[10]: Copied! <pre>data = [{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\nscenario = pd.DataFrame(data)\nnetwork = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.2).T\n</pre> data = [{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()]  scenario = pd.DataFrame(data) network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.2).T  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 4\n      1 data = [{\"name\": placename,\n      2          \"population\": place.population[0],\n      3          \"latitude\": place.latitude,\n----&gt; 4          \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n      6 scenario = pd.DataFrame(data)\n      7 network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.2).T\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[11]: Copied! <pre>plt.figure(figsize=(10, 8))\nplt.imshow(np.log10(network), cmap='viridis', aspect='auto')\nplt.colorbar(label='Connection Strength')\nplt.title('Network Matrix Visualization')\nplt.xlabel('Node Index')\nplt.ylabel('Node Index')\nplt.show()\n</pre> plt.figure(figsize=(10, 8)) plt.imshow(np.log10(network), cmap='viridis', aspect='auto') plt.colorbar(label='Connection Strength') plt.title('Network Matrix Visualization') plt.xlabel('Node Index') plt.ylabel('Node Index') plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[11], line 2\n      1 plt.figure(figsize=(10, 8))\n----&gt; 2 plt.imshow(np.log10(network), cmap='viridis', aspect='auto')\n      3 plt.colorbar(label='Connection Strength')\n      4 plt.title('Network Matrix Visualization')\n\nNameError: name 'network' is not defined</pre> <pre>&lt;Figure size 1000x800 with 0 Axes&gt;</pre> In\u00a0[12]: Copied! <pre>transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\n</pre> transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\n\nNameError: name 'x' is not defined</pre> In\u00a0[13]: Copied! <pre>np.unravel_index(np.argmax(transfer), transfer.shape)\n</pre> np.unravel_index(np.argmax(transfer), transfer.shape) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 np.unravel_index(np.argmax(transfer), transfer.shape)\n\nNameError: name 'transfer' is not defined</pre> In\u00a0[14]: Copied! <pre>network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.999).T\ntransfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\nany((x.cases_test[10000, :]-transfer.sum(axis=0))&lt;0)\n</pre> network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.999).T transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network any((x.cases_test[10000, :]-transfer.sum(axis=0))&lt;0) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 network = row_normalizer(gravity(np.array(scenario.population), distances, 1e-4, 0, 1, 2).T, 0.999).T\n      2 transfer = (x.cases_test[10000, :].copy().astype(np.float32))*network\n      3 any((x.cases_test[10000, :]-transfer.sum(axis=0))&lt;0)\n\nNameError: name 'scenario' is not defined</pre> In\u00a0[15]: Copied! <pre>pops = np.array([10., 100., 1000.])\ndistances = np.array([[0., 1., 2.], [1, 0, 5], [2, 5, 0]])\nnetwork = gravity(pops, distances, 1, 0, 1, 1)\n</pre> pops = np.array([10., 100., 1000.]) distances = np.array([[0., 1., 2.], [1, 0, 5], [2, 5, 0]]) network = gravity(pops, distances, 1, 0, 1, 1) In\u00a0[16]: Copied! <pre>network\n</pre> network Out[16]: <pre>array([[  0., 100., 500.],\n       [ 10.,   0., 200.],\n       [  5.,  20.,   0.]])</pre> In\u00a0[17]: Copied! <pre>row_normalizer(network, 0.5)\n</pre> row_normalizer(network, 0.5) Out[17]: <pre>array([[0.        , 0.08333334, 0.41666666],\n       [0.02380952, 0.        , 0.47619048],\n       [0.1       , 0.4       , 0.        ]], dtype=float32)</pre> In\u00a0[18]: Copied! <pre>cases = np.array([1., 2, 3])\n</pre> cases = np.array([1., 2, 3]) In\u00a0[19]: Copied! <pre>transfer = cases*network\n</pre> transfer = cases*network In\u00a0[20]: Copied! <pre>transfer\n</pre> transfer Out[20]: <pre>array([[   0.,  200., 1500.],\n       [  10.,    0.,  600.],\n       [   5.,   40.,    0.]])</pre> In\u00a0[21]: Copied! <pre>transfer[0,1]\n</pre> transfer[0,1] Out[21]: <pre>np.float64(200.0)</pre> In\u00a0[22]: Copied! <pre>cases[0]*network[0,1]\n</pre> cases[0]*network[0,1] Out[22]: <pre>np.float64(100.0)</pre> In\u00a0[23]: Copied! <pre>cases.shape\n</pre> cases.shape Out[23]: <pre>(3,)</pre> In\u00a0[24]: Copied! <pre>model.patches.cases_test[25, :].shape\n</pre> model.patches.cases_test[25, :].shape <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[24], line 1\n----&gt; 1 model.patches.cases_test[25, :].shape\n\nNameError: name 'model' is not defined</pre> In\u00a0[25]: Copied! <pre>np.sqrt(3)\n</pre> np.sqrt(3) Out[25]: <pre>np.float64(1.7320508075688772)</pre> In\u00a0[26]: Copied! <pre>3**(0.5)\n</pre> 3**(0.5) Out[26]: <pre>1.7320508075688772</pre> In\u00a0[27]: Copied! <pre>model.patches.\n</pre> model.patches. <pre>\n  Cell In[27], line 1\n    model.patches.\n                  ^\nSyntaxError: invalid syntax\n</pre> In\u00a0[28]: Copied! <pre>.017*3e7\n</pre> .017*3e7 Out[28]: <pre>510000.00000000006</pre> In\u00a0[29]: Copied! <pre>#For starters, we will work with a constant population and constant crude birth rate over the network.  \n#This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now.\n#test_outs = []\nmyparams = []\n#for i in range(6, 11):\n#    for j in range(5):\nj=0\nfor i in range (20):\n    beta = 3.4\n    scalar = 0.6\n    myparams.append((beta, scalar))\n    data = [{\"name\": placename,\n            \"population\": place.population[0],\n            \"latitude\": place.latitude,\n            \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\n    log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n    -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\n    scenario = pd.DataFrame(data)\n    parameters = PropertySet(\n        {\"seed\": i, \"nticks\": 40*365,\n        \"exp_shape\": 40, \"exp_scale\": 0.25,\n        \"verbose\": True, \"beta\": beta, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,\n        \"biweekly_beta_scalar\": np.exp( scalar*(log_betas - np.mean(log_betas)) ),\n        \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}\n    )\n\n    model = Model(scenario, parameters)\n    model.components = [\n        Births_ConstantPop,\n        Susceptibility,\n        Transmission,\n        Exposure,\n        Infection,\n        Infect_Random_Agents,\n    ]\n    model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)\n    rowsums = np.sum(model.patches.network, axis=1)\n    model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3\n    model.patches.network = row_normalizer(model.patches.network, 0.2)\n\n    mu = (1 + parameters.cbr/ 1000) ** (1 / 365) - 1\n    R0 = parameters.beta / (mu + 1 / parameters.inf_mean)\n    for p in range(len(model.patches)):\n        set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())\n\n    seed_infections_in_patch(model, ipatch=507, ninfections=3)\n    model.run()\n    #test_outs.append(model.patches.cases_test)\n    #myparams.append((0.5+i/5, 0.5+0.25*j))\n\n    output_path = os.path.join('..', 'periodicity_outs', f\"EWoutputs3_betas_{i}_{j}.pkl\")\n    for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:\n        if hasattr(model.patches, attr):\n            delattr(model.patches, attr)\n    with open(output_path, \"wb\") as file:\n        pickle.dump(model.patches, file)\n</pre> #For starters, we will work with a constant population and constant crude birth rate over the network.   #This may prevent seeing some of the periodicity switch behavior, but we are focused on explicitly spatial stuff for now. #test_outs = [] myparams = [] #for i in range(6, 11): #    for j in range(5): j=0 for i in range (20):     beta = 3.4     scalar = 0.6     myparams.append((beta, scalar))     data = [{\"name\": placename,             \"population\": place.population[0],             \"latitude\": place.latitude,             \"longitude\": place.longitude} for placename, place in engwal.places.items()]      log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,     -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])      scenario = pd.DataFrame(data)     parameters = PropertySet(         {\"seed\": i, \"nticks\": 40*365,         \"exp_shape\": 40, \"exp_scale\": 0.25,         \"verbose\": True, \"beta\": beta, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": 20,         \"biweekly_beta_scalar\": np.exp( scalar*(log_betas - np.mean(log_betas)) ),         \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}     )      model = Model(scenario, parameters)     model.components = [         Births_ConstantPop,         Susceptibility,         Transmission,         Exposure,         Infection,         Infect_Random_Agents,     ]     model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)     rowsums = np.sum(model.patches.network, axis=1)     model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3     model.patches.network = row_normalizer(model.patches.network, 0.2)      mu = (1 + parameters.cbr/ 1000) ** (1 / 365) - 1     R0 = parameters.beta / (mu + 1 / parameters.inf_mean)     for p in range(len(model.patches)):         set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())      seed_infections_in_patch(model, ipatch=507, ninfections=3)     model.run()     #test_outs.append(model.patches.cases_test)     #myparams.append((0.5+i/5, 0.5+0.25*j))      output_path = os.path.join('..', 'periodicity_outs', f\"EWoutputs3_betas_{i}_{j}.pkl\")     for attr in ['cases', 'susceptibility', 'exposed', 'recovered']:         if hasattr(model.patches, attr):             delattr(model.patches, attr)     with open(output_path, \"wb\") as file:         pickle.dump(model.patches, file)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[29], line 15\n     10 scalar = 0.6\n     11 myparams.append((beta, scalar))\n     12 data = [{\"name\": placename,\n     13         \"population\": place.population[0],\n     14         \"latitude\": place.latitude,\n---&gt; 15         \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n     17 log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n     18 -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n     20 scenario = pd.DataFrame(data)\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[30]: Copied! <pre>import glob\n\nfiles = glob.glob(os.path.join('..', 'periodicity_outs', 'EWoutputs3_betas_*_*.pkl'))\n\n# Prepare a 9x5 grid of axes\nfig, axes = plt.subplots(5, 4, figsize=(18, 24), sharex=True, sharey=True)\n\nfor file in files:\n    basename = os.path.basename(file)\n    parts = basename.replace('.pkl', '').split('_')\n    i = int(parts[-2])\n    j = int(parts[-1])\n    with open(file, \"rb\") as f:\n        x = pickle.load(f)\n    # Only plot years 20:40 (indices 7300:14600)\n    t = 1./365 * np.arange(x.cases_test.shape[0])\n    mask = (t &gt;= 0) &amp; (t &lt;= 40)\n    axes[i % 5, i//5].plot(t[mask], np.sum(x.cases_test, axis=1)[mask])\n    axes[i % 5, i//5].set_title(f\"beta={3.1+0.1*i:.2f}, scalar={0.5+0.1*j:.2f}\", fontsize=9)\n    if i == 5:\n        axes[i%5, i//5].set_xlabel(\"Years\")\n    if j == 0:\n        axes[i%5, i//5].set_ylabel(\"Total Cases\")\n\nplt.tight_layout()\nplt.show()\n</pre> import glob  files = glob.glob(os.path.join('..', 'periodicity_outs', 'EWoutputs3_betas_*_*.pkl'))  # Prepare a 9x5 grid of axes fig, axes = plt.subplots(5, 4, figsize=(18, 24), sharex=True, sharey=True)  for file in files:     basename = os.path.basename(file)     parts = basename.replace('.pkl', '').split('_')     i = int(parts[-2])     j = int(parts[-1])     with open(file, \"rb\") as f:         x = pickle.load(f)     # Only plot years 20:40 (indices 7300:14600)     t = 1./365 * np.arange(x.cases_test.shape[0])     mask = (t &gt;= 0) &amp; (t &lt;= 40)     axes[i % 5, i//5].plot(t[mask], np.sum(x.cases_test, axis=1)[mask])     axes[i % 5, i//5].set_title(f\"beta={3.1+0.1*i:.2f}, scalar={0.5+0.1*j:.2f}\", fontsize=9)     if i == 5:         axes[i%5, i//5].set_xlabel(\"Years\")     if j == 0:         axes[i%5, i//5].set_ylabel(\"Total Cases\")  plt.tight_layout() plt.show()  In\u00a0[31]: Copied! <pre>test_outs = []\nmyparams = []\nfor i in range(9):\n    for j in range(5):\n        data = [{\"name\": placename,\n                \"population\": place.population[0],\n                \"latitude\": place.latitude,\n                \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n\n        log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n        -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n\n        scenario = pd.DataFrame([data[507]])\n        parameters = PropertySet(\n            {\"seed\": 4, \"nticks\": 40*365,\n            \"exp_shape\": 40, \"exp_scale\": 0.25,\n            \"verbose\": True, \"beta\": 0.5+0.25*i, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": varcbrs,\n            \"biweekly_beta_scalar\": np.exp( (0.5 + 0.25*j)*(log_betas - np.mean(log_betas)) ),\n            \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}\n        )\n\n        model = Model(scenario, parameters)\n        model.components = [\n            Births_ConstantPop_VariableBirthRate,\n            Susceptibility,\n            Transmission,\n            Exposure,\n            Infection,\n            Infect_Random_Agents,\n        ]\n        # model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)\n        # rowsums = np.sum(model.patches.network, axis=1)\n        # model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3\n        # model.patches.network = row_normalizer(model.patches.network, 0.2)\n\n        mu = (1 + parameters.cbr['rates'][0] / 1000) ** (1 / 365) - 1\n        R0 = parameters.beta / (mu + 1 / parameters.inf_mean)\n        for p in range(len(model.patches)):\n            set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())\n\n        seed_infections_in_patch(model, ipatch=507, ninfections=3)\n        model.run()\n        test_outs.append(model.patches.incidence)\n</pre> test_outs = [] myparams = [] for i in range(9):     for j in range(5):         data = [{\"name\": placename,                 \"population\": place.population[0],                 \"latitude\": place.latitude,                 \"longitude\": place.longitude} for placename, place in engwal.places.items()]          log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,         -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])          scenario = pd.DataFrame([data[507]])         parameters = PropertySet(             {\"seed\": 4, \"nticks\": 40*365,             \"exp_shape\": 40, \"exp_scale\": 0.25,             \"verbose\": True, \"beta\": 0.5+0.25*i, \"inf_mean\": 8, \"inf_sigma\": 2, \"cbr\": varcbrs,             \"biweekly_beta_scalar\": np.exp( (0.5 + 0.25*j)*(log_betas - np.mean(log_betas)) ),             \"importation_period\": 30, \"importation_count\": 3, \"importation_start\": 1, \"importation_end\": 10*365}         )          model = Model(scenario, parameters)         model.components = [             Births_ConstantPop_VariableBirthRate,             Susceptibility,             Transmission,             Exposure,             Infection,             Infect_Random_Agents,         ]         # model.patches.network = gravity(np.array(scenario.population), distances, 1, 0, 0.6, 1.2)         # rowsums = np.sum(model.patches.network, axis=1)         # model.patches.network = model.patches.network / rowsums[:, np.newaxis] * 6e-3         # model.patches.network = row_normalizer(model.patches.network, 0.2)          mu = (1 + parameters.cbr['rates'][0] / 1000) ** (1 / 365) - 1         R0 = parameters.beta / (mu + 1 / parameters.inf_mean)         for p in range(len(model.patches)):             set_initial_susceptibility_in_patch(model, p, 1 / R0 + 0.2/R0 * np.random.normal())          seed_infections_in_patch(model, ipatch=507, ninfections=3)         model.run()         test_outs.append(model.patches.incidence) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[31], line 8\n      3 for i in range(9):\n      4     for j in range(5):\n      5         data = [{\"name\": placename,\n      6                 \"population\": place.population[0],\n      7                 \"latitude\": place.latitude,\n----&gt; 8                 \"longitude\": place.longitude} for placename, place in engwal.places.items()]\n     10         log_betas = np.array([0.155, 0.571, 0.46, 0.34, 0.30, 0.34, 0.24, 0.15, 0.31, 0.40, 0.323, 0.238, 0.202, 0.203, 0.074,\n     11         -0.095, -0.218, -0.031, 0.433, 0.531, 0.479, 0.397, 0.444, 0.411, 0.291, 0.509])\n     13         scenario = pd.DataFrame([data[507]])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[32]: Copied! <pre>plt.plot(1./365*np.arange(len(test_outs[0])), test_outs[45])\n</pre> plt.plot(1./365*np.arange(len(test_outs[0])), test_outs[45]) <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[32], line 1\n----&gt; 1 plt.plot(1./365*np.arange(len(test_outs[0])), test_outs[45])\n\nIndexError: list index out of range</pre> In\u00a0[33]: Copied! <pre>betas = []\nscalars = []\nfor i in range(9):\n    for j in range(5):\n        betas.append(0.5+0.25*i)\n        scalars.append(0.5+0.25*j)\n</pre> betas = [] scalars = [] for i in range(9):     for j in range(5):         betas.append(0.5+0.25*i)         scalars.append(0.5+0.25*j) In\u00a0[34]: Copied! <pre>betas[35], scalars[35]\n</pre> betas[35], scalars[35] Out[34]: <pre>(2.25, 0.5)</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/EW_analysis/","title":"EW analysis","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport os\nimport sys\nfrom laser.core.propertyset import PropertySet\nimport matplotlib.pyplot as plt\n\nimport pickle\n\n\ndata_dir = os.path.join('..', \"data\")\nsys.path.append(data_dir)\n\nfrom EnglandWalesmeasles import data as engwal\ndistances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n\nimport laser.core\nimport laser.generic\n\nprint(f\"{np.__version__=}\")\nprint(f\"{laser.core.__version__=}\")\nprint(f\"{laser.generic.__version__=}\")\n</pre> import numpy as np import pandas as pd import os import sys from laser.core.propertyset import PropertySet import matplotlib.pyplot as plt  import pickle   data_dir = os.path.join('..', \"data\") sys.path.append(data_dir)  from EnglandWalesmeasles import data as engwal distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))  import laser.core import laser.generic  print(f\"{np.__version__=}\") print(f\"{laser.core.__version__=}\") print(f\"{laser.generic.__version__=}\")  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 14\n     11 data_dir = os.path.join('..', \"data\")\n     12 sys.path.append(data_dir)\n---&gt; 14 from EnglandWalesmeasles import data as engwal\n     15 distances = np.load(os.path.join(\"..\", \"data\", \"EnglandWalesdistances.npy\"))\n     17 import laser.core\n\nModuleNotFoundError: No module named 'EnglandWalesmeasles'</pre> In\u00a0[2]: Copied! <pre>EWdata = pd.DataFrame([{\"name\": placename,\n         \"population\": place.population[0],\n         \"latitude\": place.latitude,\n         \"longitude\": place.longitude} for placename, place in engwal.places.items()])\n</pre> EWdata = pd.DataFrame([{\"name\": placename,          \"population\": place.population[0],          \"latitude\": place.latitude,          \"longitude\": place.longitude} for placename, place in engwal.places.items()]) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 4\n      1 EWdata = pd.DataFrame([{\"name\": placename,\n      2          \"population\": place.population[0],\n      3          \"latitude\": place.latitude,\n----&gt; 4          \"longitude\": place.longitude} for placename, place in engwal.places.items()])\n\nNameError: name 'engwal' is not defined</pre> In\u00a0[3]: Copied! <pre>EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)]\n</pre> EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)]\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[4]: Copied! <pre>EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases)\nEWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births)\nEWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))\n</pre> EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases) EWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births) EWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 EWdata[\"cases\"] = EWdata[\"name\"].apply(lambda name: engwal.places[name].cases)\n      2 EWdata['births' ] = EWdata[\"name\"].apply(lambda name: engwal.places[name].births)\n      3 EWdata[\"prop_zero\"] = EWdata[\"cases\"].apply(lambda x: np.mean(np.array(x) == 0))\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[5]: Copied! <pre>EWdata.loc[507]['births']/EWdata.loc[507]['population']\n</pre> EWdata.loc[507]['births']/EWdata.loc[507]['population'] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 EWdata.loc[507]['births']/EWdata.loc[507]['population']\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[6]: Copied! <pre>plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o')\n</pre> plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o') <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 plt.plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o')\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[7]: Copied! <pre>import re\n\noutput_dir = os.path.join('..', 'outputs3')\nparams = pd.read_csv(os.path.join(output_dir, \"params.csv\"))\n\nresults = []\n\nfor fname in range(100):\n   \n    with open(os.path.join(output_dir, 'EWoutputs_gravity_'+str(fname)+'.pkl'), \"rb\") as f:\n        x = pickle.load(f)\n    # x.cases_test: shape (days, 954)\n    cases_test = np.array(x.cases_test)\n    incidence = np.array(x.incidence)\n    populations = np.array(x.populations[0 ,:])\n    # Aggregate daily to weekly: sum every 7 days along axis 0\n    num_weeks = cases_test.shape[0] // 7\n    weekly_cases = cases_test[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)\n    weekly_incidence = incidence[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)\n    # Create a DataFrame for this parameter set, matching EWdata's structure\n    df = pd.DataFrame({\n        \"name\": EWdata[\"name\"],\n        \"population\": populations,\n        \"cases\": list(weekly_cases.T),  # each entry is a list of weekly cases for that place\n        \"incidence\": list(weekly_incidence.T)  # each entry is a list of weekly cases for that place\n    })\n    df[\"k\"] = params.iloc[fname][\"k\"]\n    df[\"b\"] = params.iloc[fname][\"b\"]\n    df[\"c\"] = params.iloc[fname][\"c\"]\n    #df.set_index([\"k\", \"a\", \"c\", \"name\"], inplace=True)\n    results.append(df)\n</pre> import re  output_dir = os.path.join('..', 'outputs3') params = pd.read_csv(os.path.join(output_dir, \"params.csv\"))  results = []  for fname in range(100):         with open(os.path.join(output_dir, 'EWoutputs_gravity_'+str(fname)+'.pkl'), \"rb\") as f:         x = pickle.load(f)     # x.cases_test: shape (days, 954)     cases_test = np.array(x.cases_test)     incidence = np.array(x.incidence)     populations = np.array(x.populations[0 ,:])     # Aggregate daily to weekly: sum every 7 days along axis 0     num_weeks = cases_test.shape[0] // 7     weekly_cases = cases_test[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)     weekly_incidence = incidence[:num_weeks*7].reshape(num_weeks, 7, 954).sum(axis=1)     # Create a DataFrame for this parameter set, matching EWdata's structure     df = pd.DataFrame({         \"name\": EWdata[\"name\"],         \"population\": populations,         \"cases\": list(weekly_cases.T),  # each entry is a list of weekly cases for that place         \"incidence\": list(weekly_incidence.T)  # each entry is a list of weekly cases for that place     })     df[\"k\"] = params.iloc[fname][\"k\"]     df[\"b\"] = params.iloc[fname][\"b\"]     df[\"c\"] = params.iloc[fname][\"c\"]     #df.set_index([\"k\", \"a\", \"c\", \"name\"], inplace=True)     results.append(df) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[7], line 4\n      1 import re\n      3 output_dir = os.path.join('..', 'outputs3')\n----&gt; 4 params = pd.read_csv(os.path.join(output_dir, \"params.csv\"))\n      6 results = []\n      8 for fname in range(100):\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:620, in _read(filepath_or_buffer, kwds)\n    617 _validate_names(kwds.get(\"names\", None))\n    619 # Create the parser.\n--&gt; 620 parser = TextFileReader(filepath_or_buffer, **kwds)\n    622 if chunksize or iterator:\n    623     return parser\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1620, in TextFileReader.__init__(self, f, engine, **kwds)\n   1617     self.options[\"has_index_names\"] = kwds[\"has_index_names\"]\n   1619 self.handles: IOHandles | None = None\n-&gt; 1620 self._engine = self._make_engine(f, self.engine)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/io/parsers/readers.py:1880, in TextFileReader._make_engine(self, f, engine)\n   1878     if \"b\" not in mode:\n   1879         mode += \"b\"\n-&gt; 1880 self.handles = get_handle(\n   1881     f,\n   1882     mode,\n   1883     encoding=self.options.get(\"encoding\", None),\n   1884     compression=self.options.get(\"compression\", None),\n   1885     memory_map=self.options.get(\"memory_map\", False),\n   1886     is_text=is_text,\n   1887     errors=self.options.get(\"encoding_errors\", \"strict\"),\n   1888     storage_options=self.options.get(\"storage_options\", None),\n   1889 )\n   1890 assert self.handles is not None\n   1891 f = self.handles.handle\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/io/common.py:873, in get_handle(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\n    868 elif isinstance(handle, str):\n    869     # Check whether the filename is to be opened in binary mode.\n    870     # Binary mode does not support 'encoding' and 'newline'.\n    871     if ioargs.encoding and \"b\" not in ioargs.mode:\n    872         # Encoding\n--&gt; 873         handle = open(\n    874             handle,\n    875             ioargs.mode,\n    876             encoding=ioargs.encoding,\n    877             errors=errors,\n    878             newline=\"\",\n    879         )\n    880     else:\n    881         # Binary mode\n    882         handle = open(handle, ioargs.mode)\n\nFileNotFoundError: [Errno 2] No such file or directory: '../outputs3/params.csv'</pre> In\u00a0[8]: Copied! <pre>for df_result in results:\n    df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))\n    df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 ))\n</pre> for df_result in results:     df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))     df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 )) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 for df_result in results:\n      2     df_result[\"prop_zero\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) ==0 ))\n      3     df_result[\"prop_low\"] = df_result[\"incidence\"].apply(lambda x: np.mean(np.array(x[1040:]) &lt;=2 ))\n\nNameError: name 'results' is not defined</pre> In\u00a0[9]: Copied! <pre>from scipy.optimize import curve_fit\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 1. Define fitting functions for mean and variance\ndef logistic(x, x0, k):\n    # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases\n    return 1 / (1 + np.exp(k * (x - x0)))\n\ndef fit_mean_var(x, y):\n    # Fit a logistic to the mean\n    # Initial guess: midpoint at median(x), width=1\n    p0 = [np.median(x), 1.0]\n    bounds = ([-np.inf, 0.01], [np.inf, 10.0])\n    popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)\n    return popt_mean\n\n# 3. Define similarity metric (sum of squared differences of mean and variance fits)\ndef similarity_metric(mean_data, mean_sim):\n    # Evaluate both curves on a common grid\n    x_grid = np.linspace(2.5, 6.5, 200)\n    data_curve = logistic(x_grid, *mean_data)\n    sim_curve = logistic(x_grid, *mean_sim)\n    # Similarity: sum of squared differences between the curves\n    mean_diff = np.sum((sim_curve - data_curve) ** 2)\n    return mean_diff\n\nparams = []\nsim_metrics = []\n\nfor i, df_result in enumerate(results):\n    # Plot observed and simulated data\n    logpop_obs = np.log10(EWdata['population'])\n    prop_zero_obs = EWdata['prop_zero']\n    logpop_sim = np.log10(df_result['population'])\n    prop_zero_sim = df_result['prop_zero']\n\n    # Fit to observed\n    popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)\n    popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)\n    # Similarity metric\n    sim = similarity_metric(popt_obs, popt_sim)\n    k = df_result['k'].iloc[0]\n    a = df_result['b'].iloc[0]\n    c = df_result['c'].iloc[0]\n    params.append((k, a, c))\n    sim_metrics.append(sim)\n</pre> from scipy.optimize import curve_fit from mpl_toolkits.mplot3d import Axes3D  # 1. Define fitting functions for mean and variance def logistic(x, x0, k):     # Logistic function bounded between 0 and 1, transitions from 1 to 0 as x increases     return 1 / (1 + np.exp(k * (x - x0)))  def fit_mean_var(x, y):     # Fit a logistic to the mean     # Initial guess: midpoint at median(x), width=1     p0 = [np.median(x), 1.0]     bounds = ([-np.inf, 0.01], [np.inf, 10.0])     popt_mean, _ = curve_fit(logistic, x, y, p0=p0, bounds=bounds, maxfev=10000)     return popt_mean  # 3. Define similarity metric (sum of squared differences of mean and variance fits) def similarity_metric(mean_data, mean_sim):     # Evaluate both curves on a common grid     x_grid = np.linspace(2.5, 6.5, 200)     data_curve = logistic(x_grid, *mean_data)     sim_curve = logistic(x_grid, *mean_sim)     # Similarity: sum of squared differences between the curves     mean_diff = np.sum((sim_curve - data_curve) ** 2)     return mean_diff  params = [] sim_metrics = []  for i, df_result in enumerate(results):     # Plot observed and simulated data     logpop_obs = np.log10(EWdata['population'])     prop_zero_obs = EWdata['prop_zero']     logpop_sim = np.log10(df_result['population'])     prop_zero_sim = df_result['prop_zero']      # Fit to observed     popt_obs = fit_mean_var(logpop_obs, prop_zero_obs)     popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)     # Similarity metric     sim = similarity_metric(popt_obs, popt_sim)     k = df_result['k'].iloc[0]     a = df_result['b'].iloc[0]     c = df_result['c'].iloc[0]     params.append((k, a, c))     sim_metrics.append(sim)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 30\n     27 params = []\n     28 sim_metrics = []\n---&gt; 30 for i, df_result in enumerate(results):\n     31     # Plot observed and simulated data\n     32     logpop_obs = np.log10(EWdata['population'])\n     33     prop_zero_obs = EWdata['prop_zero']\n\nNameError: name 'results' is not defined</pre> In\u00a0[10]: Copied! <pre># Create a DataFrame with k, b, c, and similarity score, then sort by similarity\nparams_df = pd.DataFrame(params, columns=['k', 'b', 'c'])\nparams_df['similarity'] = sim_metrics\nranked_params = params_df.sort_values('similarity').reset_index(drop=True)\nranked_params[0:20]\n</pre> # Create a DataFrame with k, b, c, and similarity score, then sort by similarity params_df = pd.DataFrame(params, columns=['k', 'b', 'c']) params_df['similarity'] = sim_metrics ranked_params = params_df.sort_values('similarity').reset_index(drop=True) ranked_params[0:20] Out[10]: k b c similarity In\u00a0[11]: Copied! <pre>params_df\n</pre> params_df Out[11]: k b c similarity In\u00a0[12]: Copied! <pre>fig, axes = plt.subplots(6, 2, figsize=(14, 18))\naxes = axes.flatten()\n\nfor idx in range(12):\n    # Get the parameter set with the idx-th lowest similarity\n    k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]\n    sim_score = ranked_params.loc[idx, 'similarity']\n    # Find the corresponding result DataFrame\n    for df in results:\n        if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):\n            df_best = df\n            break\n\n    logpop_sim = np.log10(df_best['population'])\n    prop_zero_sim = df_best['prop_zero']\n\n    # Fit logistic to simulation\n    popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)\n    # Fit logistic to observed (reuse from above)\n    popt_obs = fit_mean_var(np.log10(EWdata['population']), EWdata['prop_zero'])\n\n    xfit = np.linspace(2.8, 6.4, 200)\n    axes[idx].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)\n    axes[idx].plot(logpop_sim, prop_zero_sim, 'o', label='Simulated', alpha=0.6)\n    axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')\n    axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')\n    axes[idx].set_title(f\"k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")\n    axes[idx].set_xlabel(\"log10(Population)\")\n    axes[idx].set_ylabel(\"Proportion zero\")\n    axes[idx].legend()\n\nplt.tight_layout()\nplt.show()\n</pre>   fig, axes = plt.subplots(6, 2, figsize=(14, 18)) axes = axes.flatten()  for idx in range(12):     # Get the parameter set with the idx-th lowest similarity     k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]     sim_score = ranked_params.loc[idx, 'similarity']     # Find the corresponding result DataFrame     for df in results:         if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):             df_best = df             break      logpop_sim = np.log10(df_best['population'])     prop_zero_sim = df_best['prop_zero']      # Fit logistic to simulation     popt_sim = fit_mean_var(logpop_sim, prop_zero_sim)     # Fit logistic to observed (reuse from above)     popt_obs = fit_mean_var(np.log10(EWdata['population']), EWdata['prop_zero'])      xfit = np.linspace(2.8, 6.4, 200)     axes[idx].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)     axes[idx].plot(logpop_sim, prop_zero_sim, 'o', label='Simulated', alpha=0.6)     axes[idx].plot(xfit, logistic(xfit, *popt_obs), '-', label='Obs fit', color='C0')     axes[idx].plot(xfit, logistic(xfit, *popt_sim), '-', label='Sim fit', color='C1')     axes[idx].set_title(f\"k={k_best:.1e}, b={b_best:.2f}, c={c_best:.2f}, similarity={sim_score:.3f}\")     axes[idx].set_xlabel(\"log10(Population)\")     axes[idx].set_ylabel(\"Proportion zero\")     axes[idx].legend()  plt.tight_layout() plt.show() <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexes/range.py:413, in RangeIndex.get_loc(self, key)\n    412 try:\n--&gt; 413     return self._range.index(new_key)\n    414 except ValueError as err:\n\nValueError: 0 is not in range\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[12], line 6\n      2 axes = axes.flatten()\n      4 for idx in range(12):\n      5     # Get the parameter set with the idx-th lowest similarity\n----&gt; 6     k_best, b_best, c_best = ranked_params.loc[idx, ['k', 'b', 'c']]\n      7     sim_score = ranked_params.loc[idx, 'similarity']\n      8     # Find the corresponding result DataFrame\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1185, in _LocationIndexer.__getitem__(self, key)\n   1183     if self._is_scalar_access(key):\n   1184         return self.obj._get_value(*key, takeable=self._takeable)\n-&gt; 1185     return self._getitem_tuple(key)\n   1186 else:\n   1187     # we by definition only have the 0th axis\n   1188     axis = self.axis or 0\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1369, in _LocIndexer._getitem_tuple(self, tup)\n   1367 with suppress(IndexingError):\n   1368     tup = self._expand_ellipsis(tup)\n-&gt; 1369     return self._getitem_lowerdim(tup)\n   1371 # no multi-index, so validate all of the indexers\n   1372 tup = self._validate_tuple_indexer(tup)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1066, in _LocationIndexer._getitem_lowerdim(self, tup)\n   1062 for i, key in enumerate(tup):\n   1063     if is_label_like(key):\n   1064         # We don't need to check for tuples here because those are\n   1065         #  caught by the _is_nested_tuple_indexer check above.\n-&gt; 1066         section = self._getitem_axis(key, axis=i)\n   1068         # We should never have a scalar section here, because\n   1069         #  _getitem_lowerdim is only called after a check for\n   1070         #  is_scalar_access, which that would be.\n   1071         if section.ndim == self.ndim:\n   1072             # we're in the middle of slicing through a MultiIndex\n   1073             # revise the key wrt to `section` by inserting an _NS\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1432, in _LocIndexer._getitem_axis(self, key, axis)\n   1430 # fall thru to straight lookup\n   1431 self._validate_key(key, axis)\n-&gt; 1432 return self._get_label(key, axis=axis)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexing.py:1382, in _LocIndexer._get_label(self, label, axis)\n   1380 def _get_label(self, label, axis: AxisInt):\n   1381     # GH#5567 this will fail if the label is not present in the axis.\n-&gt; 1382     return self.obj.xs(label, axis=axis)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/generic.py:4323, in NDFrame.xs(self, key, axis, level, drop_level)\n   4321             new_index = index[loc]\n   4322 else:\n-&gt; 4323     loc = index.get_loc(key)\n   4325     if isinstance(loc, np.ndarray):\n   4326         if loc.dtype == np.bool_:\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/pandas/core/indexes/range.py:415, in RangeIndex.get_loc(self, key)\n    413         return self._range.index(new_key)\n    414     except ValueError as err:\n--&gt; 415         raise KeyError(key) from err\n    416 if isinstance(key, Hashable):\n    417     raise KeyError(key)\n\nKeyError: 0</pre> In\u00a0[13]: Copied! <pre># Find the top 10 best simulations (lowest similarity)\ntop10 = ranked_params.iloc[:10]\n\n# Collect the corresponding result DataFrames\ndf_top10 = []\nfor idx, row in top10.iterrows():\n    k_best, b_best, c_best = row[['k', 'b', 'c']]\n    for df in results:\n        if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):\n            df_top10.append(df)\n            break\n\n# Stack prop_zero and population for averaging\npopulations = np.stack([np.log10(df['population'].values) for df in df_top10])\nprop_zeros = np.stack([df['prop_zero'].values for df in df_top10])\n\n# Compute mean and std across the top 10\nlogpop_sim_mean = populations.mean(axis=0)\nprop_zero_sim_mean = prop_zeros.mean(axis=0)\nprop_zero_sim_std = prop_zeros.std(axis=0)\n\nlogpop_obs = np.log10(EWdata['population'])\nprop_zero_obs = EWdata['prop_zero']\n#logpop_sim = np.log10(df_best['population'])\n#prop_zero_sim = df_best['prop_zero']\n\nplt.figure(figsize=(9, 6), dpi=200)\n# Use colorblind-friendly colors (e.g., from Color Universal Design palette)\n# Blue: #0072B2, Orange: #E69F00\nplt.scatter(logpop_obs, prop_zero_obs, s=40, color='#0072B2', label='Observed', alpha=0.8, edgecolor='k', linewidth=0.7)\nplt.scatter(logpop_sim_mean, prop_zero_sim_mean, s=40, color='#E69F00', label='Simulated', alpha=0.8, marker='s', edgecolor='k', linewidth=0.7)\n\nplt.xlabel(\"City population\", fontsize=18)\nplt.ylabel(\"Proportion of weeks \\n with no reported cases\", fontsize=18)\nplt.title(\"England + Wales 954 city dataset \\n Measles fadeout and reinvasion dynamics, 1944-1964\", fontsize=20)\nplt.legend(fontsize=16)\n# Set custom x-ticks and labels for log10 scale\nxticks = [3, 4, 5, 6]\nxticklabels = [r\"$10^{%g}$\" % x for x in xticks]\nplt.xticks(xticks, xticklabels, fontsize=15)\nplt.xticks(fontsize=15)\nplt.yticks(fontsize=15)\nplt.tight_layout()\nplt.show()\n</pre> # Find the top 10 best simulations (lowest similarity) top10 = ranked_params.iloc[:10]  # Collect the corresponding result DataFrames df_top10 = [] for idx, row in top10.iterrows():     k_best, b_best, c_best = row[['k', 'b', 'c']]     for df in results:         if np.isclose(df['k'].iloc[0], k_best) and np.isclose(df['b'].iloc[0], b_best) and np.isclose(df['c'].iloc[0], c_best):             df_top10.append(df)             break  # Stack prop_zero and population for averaging populations = np.stack([np.log10(df['population'].values) for df in df_top10]) prop_zeros = np.stack([df['prop_zero'].values for df in df_top10])  # Compute mean and std across the top 10 logpop_sim_mean = populations.mean(axis=0) prop_zero_sim_mean = prop_zeros.mean(axis=0) prop_zero_sim_std = prop_zeros.std(axis=0)  logpop_obs = np.log10(EWdata['population']) prop_zero_obs = EWdata['prop_zero'] #logpop_sim = np.log10(df_best['population']) #prop_zero_sim = df_best['prop_zero']  plt.figure(figsize=(9, 6), dpi=200) # Use colorblind-friendly colors (e.g., from Color Universal Design palette) # Blue: #0072B2, Orange: #E69F00 plt.scatter(logpop_obs, prop_zero_obs, s=40, color='#0072B2', label='Observed', alpha=0.8, edgecolor='k', linewidth=0.7) plt.scatter(logpop_sim_mean, prop_zero_sim_mean, s=40, color='#E69F00', label='Simulated', alpha=0.8, marker='s', edgecolor='k', linewidth=0.7)  plt.xlabel(\"City population\", fontsize=18) plt.ylabel(\"Proportion of weeks \\n with no reported cases\", fontsize=18) plt.title(\"England + Wales 954 city dataset \\n Measles fadeout and reinvasion dynamics, 1944-1964\", fontsize=20) plt.legend(fontsize=16) # Set custom x-ticks and labels for log10 scale xticks = [3, 4, 5, 6] xticklabels = [r\"$10^{%g}$\" % x for x in xticks] plt.xticks(xticks, xticklabels, fontsize=15) plt.xticks(fontsize=15) plt.yticks(fontsize=15) plt.tight_layout() plt.show()  <pre>\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[13], line 14\n     11             break\n     13 # Stack prop_zero and population for averaging\n---&gt; 14 populations = np.stack([np.log10(df['population'].values) for df in df_top10])\n     15 prop_zeros = np.stack([df['prop_zero'].values for df in df_top10])\n     17 # Compute mean and std across the top 10\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/shape_base.py:456, in stack(arrays, axis, out, dtype, casting)\n    454 arrays = [asanyarray(arr) for arr in arrays]\n    455 if not arrays:\n--&gt; 456     raise ValueError('need at least one array to stack')\n    458 shapes = {arr.shape for arr in arrays}\n    459 if len(shapes) != 1:\n\nValueError: need at least one array to stack</pre> In\u00a0[14]: Copied! <pre>import geopandas as gpd\n\n# Plot spatial distribution of cities with marker size proportional to log(population)\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8, 10))\n\n# Scatter plot: marker size proportional to log(population)\nsizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed\nsc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)\n\nax.set_xlabel('Longitude')\nax.set_ylabel('Latitude')\nax.set_title('Cities in England &amp; Wales\\nMarker size ~ log10(population)')\n\n# # Optional: Add England &amp; Wales borders using geopandas if available\n# try:\n#     # Plot England &amp; Wales borders from local shapefile\n#     shapefile_path = os.path.join('..', 'ne_110m_admin_0_map_units', 'ne_110m_admin_0_map_units.shp')\n#     borders = gpd.read_file(shapefile_path)\n#     # Filter for United Kingdom, then further for England and Wales if possible\n#     uk = borders[borders['SOVEREIGNT'] == 'United Kingdom']\n#     # If there are subregions, filter for England and Wales\n#     if 'NAME' in uk.columns:\n#         england_wales = uk[uk['NAME'].isin(['England', 'Wales'])]\n#         if not england_wales.empty:\n#             england_wales.boundary.plot(ax=ax, color='k', linewidth=1)\n#         else:\n#             uk.boundary.plot(ax=ax, color='k', linewidth=1)\n#     else:\n#         uk.boundary.plot(ax=ax, color='k', linewidth=1)\n# except ImportError:\n#     print(\"geopandas not installed, skipping borders.\")\n# except Exception as e:\n#     print(f\"Could not plot borders: {e}\")\n</pre> import geopandas as gpd  # Plot spatial distribution of cities with marker size proportional to log(population) import matplotlib.pyplot as plt  fig, ax = plt.subplots(figsize=(8, 10))  # Scatter plot: marker size proportional to log(population) sizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed sc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)  ax.set_xlabel('Longitude') ax.set_ylabel('Latitude') ax.set_title('Cities in England &amp; Wales\\nMarker size ~ log10(population)')  # # Optional: Add England &amp; Wales borders using geopandas if available # try: #     # Plot England &amp; Wales borders from local shapefile #     shapefile_path = os.path.join('..', 'ne_110m_admin_0_map_units', 'ne_110m_admin_0_map_units.shp') #     borders = gpd.read_file(shapefile_path) #     # Filter for United Kingdom, then further for England and Wales if possible #     uk = borders[borders['SOVEREIGNT'] == 'United Kingdom'] #     # If there are subregions, filter for England and Wales #     if 'NAME' in uk.columns: #         england_wales = uk[uk['NAME'].isin(['England', 'Wales'])] #         if not england_wales.empty: #             england_wales.boundary.plot(ax=ax, color='k', linewidth=1) #         else: #             uk.boundary.plot(ax=ax, color='k', linewidth=1) #     else: #         uk.boundary.plot(ax=ax, color='k', linewidth=1) # except ImportError: #     print(\"geopandas not installed, skipping borders.\") # except Exception as e: #     print(f\"Could not plot borders: {e}\")   <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 9\n      6 fig, ax = plt.subplots(figsize=(8, 10))\n      8 # Scatter plot: marker size proportional to log(population)\n----&gt; 9 sizes =   0.5*np.sqrt(EWdata['population'])  # adjust scaling as needed\n     10 sc = ax.scatter(EWdata['longitude'], EWdata['latitude'], s=sizes, alpha=0.8, c='C0', edgecolor='k', linewidth=1.0)\n     12 ax.set_xlabel('Longitude')\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[15]: Copied! <pre>np.max(sizes)\n</pre> np.max(sizes) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[15], line 1\n----&gt; 1 np.max(sizes)\n\nNameError: name 'sizes' is not defined</pre> In\u00a0[16]: Copied! <pre>borders\n</pre> borders <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 borders\n\nNameError: name 'borders' is not defined</pre> In\u00a0[17]: Copied! <pre>#wavelet phase analysis\nimport pywt\n\ndef pad_data(x):\n    \"\"\"\n    Pad data to the next power of 2\n    \"\"\"\n    nx = len(x) # number of samples\n    nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2\n    x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2\n    offset = (nx2-nx)//2 # offset\n    x2[offset:(offset+nx)] = x # copy\n    return x2\n\ndef log_transform(x, debug=1):\n    \"\"\"\n    Log transform for case data\n    \"\"\" \n    # add one and take log\n    x = np.log(x+1)\n    # set mean=0 and std=1\n    m = np.mean(x)\n    s = np.std(x)\n    x = (x - m)/s\n    return x\n\n\ndef calc_Ws(cases):\n    # transform case data\n    log_cases = pad_data(log_transform(cases))\n\n    # setup and execute wavelet transform\n    # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet\n    wavelet = pywt.ContinuousWavelet('cmor2-1')\n\n    dt = 1 # 2 weeks\n    widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))\n    [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)\n\n    # Number of time steps in padded time series\n    nt = len(cases)\n    # trim matrix\n    offset = (cwt.shape[1] - nt) // 2\n    cwt = cwt[:, offset:offset + nt]\n\n    return cwt, frequencies\n</pre> #wavelet phase analysis import pywt  def pad_data(x):     \"\"\"     Pad data to the next power of 2     \"\"\"     nx = len(x) # number of samples     nx2 = (2**np.ceil(np.log(nx)/np.log(2))).astype(int) # next power of 2     x2 = np.zeros(nx2, dtype=x.dtype) # pad to next power of 2     offset = (nx2-nx)//2 # offset     x2[offset:(offset+nx)] = x # copy     return x2  def log_transform(x, debug=1):     \"\"\"     Log transform for case data     \"\"\"      # add one and take log     x = np.log(x+1)     # set mean=0 and std=1     m = np.mean(x)     s = np.std(x)     x = (x - m)/s     return x   def calc_Ws(cases):     # transform case data     log_cases = pad_data(log_transform(cases))      # setup and execute wavelet transform     # https://pywavelets.readthedocs.io/en/latest/ref/cwt.html#morlet-wavelet     wavelet = pywt.ContinuousWavelet('cmor2-1')      dt = 1 # 2 weeks     widths = np.logspace(np.log10(1), np.log10(7*52), int(7*52))     [cwt, frequencies] = pywt.cwt(log_cases, widths, wavelet, dt)      # Number of time steps in padded time series     nt = len(cases)     # trim matrix     offset = (cwt.shape[1] - nt) // 2     cwt = cwt[:, offset:offset + nt]      return cwt, frequencies  <pre>\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[17], line 2\n      1 #wavelet phase analysis\n----&gt; 2 import pywt\n      4 def pad_data(x):\n      5     \"\"\"\n      6     Pad data to the next power of 2\n      7     \"\"\"\n\nModuleNotFoundError: No module named 'pywt'</pre> In\u00a0[18]: Copied! <pre># Get the cases for London from EWdata\nlondon_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\nlondon_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\nref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten()))\ndistances_from_london = distances[london_idx, :]\n\nx = np.zeros(len(EWdata))\ny = np.zeros(len(EWdata))\ny2 = np.zeros(len(EWdata))\nfor i, row in EWdata.iterrows():\n    if distances_from_london[i] &gt; 30:\n        continue\n    cwt, frequencies = calc_Ws(row[\"cases\"].flatten())\n    diff = ref_cwt*np.conj(cwt)\n    ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))\n    diff1 = diff[ind[0], :]\n    x[i] = distances_from_london[i]\n    y[i] = np.angle(np.mean(diff1))\n    ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))\n    diff2 = diff[ind2[0], :]\n    y2[i] = np.angle(np.mean(diff2))\n\nplt.plot(x, y, 'o')\nplt.xlabel(\"Distance from London\")\nplt.ylabel(\"Phase difference\")\nplt.title(\"Phase difference of London wavelet transform\")\nplt.show()\n</pre> # Get the cases for London from EWdata london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0] london_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0] ref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten())) distances_from_london = distances[london_idx, :]  x = np.zeros(len(EWdata)) y = np.zeros(len(EWdata)) y2 = np.zeros(len(EWdata)) for i, row in EWdata.iterrows():     if distances_from_london[i] &gt; 30:         continue     cwt, frequencies = calc_Ws(row[\"cases\"].flatten())     diff = ref_cwt*np.conj(cwt)     ind = np.where(np.logical_and(frequencies &lt; 1/(1.5 * 52), frequencies &gt; 1 / (3 * 52)))     diff1 = diff[ind[0], :]     x[i] = distances_from_london[i]     y[i] = np.angle(np.mean(diff1))     ind2 = np.where(np.logical_and(frequencies &lt; 1/(0.75 * 52), frequencies &gt; 1 / (1.25 * 52)))     diff2 = diff[ind2[0], :]     y2[i] = np.angle(np.mean(diff2))  plt.plot(x, y, 'o') plt.xlabel(\"Distance from London\") plt.ylabel(\"Phase difference\") plt.title(\"Phase difference of London wavelet transform\") plt.show()  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 2\n      1 # Get the cases for London from EWdata\n----&gt; 2 london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\n      3 london_cases = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\n      4 ref_cwt, frequencies = calc_Ws(np.array(london_cases.flatten()))\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[19]: Copied! <pre>plt.plot(x, -y*180/np.pi, 'o')\nplt.xlim(5, 30)\nplt.ylim(-90, 0)\nplt.xlabel(\"Distance from London\")\nplt.ylabel(\"Phase difference\")\nplt.title(\"Phase difference of London wavelet transform\")\nplt.show()\n</pre> plt.plot(x, -y*180/np.pi, 'o') plt.xlim(5, 30) plt.ylim(-90, 0) plt.xlabel(\"Distance from London\") plt.ylabel(\"Phase difference\") plt.title(\"Phase difference of London wavelet transform\") plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[19], line 1\n----&gt; 1 plt.plot(x, -y*180/np.pi, 'o')\n      2 plt.xlim(5, 30)\n      3 plt.ylim(-90, 0)\n\nNameError: name 'x' is not defined</pre> In\u00a0[20]: Copied! <pre>len(results)\n</pre> len(results)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 len(results)\n\nNameError: name 'results' is not defined</pre> In\u00a0[21]: Copied! <pre># Get the cases for London from EWdata\n# For each simulation in results, compute phase difference arrays y_sim and y2_sim\nphase_diff_results = []\n\nlondon_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\ndistances_from_london = distances[london_idx, :]\n\nfor sim_idx, df_sim in enumerate(results):\n    # Get London cases for this simulation\n    london_cases_sim = df_sim[df_sim[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]\n    ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())\n    x_sim = np.zeros(len(df_sim))\n    y_sim = np.zeros(len(df_sim))\n    y2_sim = np.zeros(len(df_sim))\n    for i, row in df_sim.iterrows():\n        if distances_from_london[i] &gt; 30:\n            continue\n        cwt_sim, frequencies_sim = calc_Ws(np.array(row[\"cases\"][520:]).flatten())\n        diff_sim = ref_cwt_sim * np.conj(cwt_sim)\n        ind = np.where(np.logical_and(frequencies_sim &lt; 1/(1.5 * 52), frequencies_sim &gt; 1 / (3 * 52)))\n        diff1_sim = diff_sim[ind[0], :]\n        x_sim[i] = distances_from_london[i]\n        y_sim[i] = np.angle(np.mean(diff1_sim))\n        ind2 = np.where(np.logical_and(frequencies_sim &lt; 1/(0.75 * 52), frequencies_sim &gt; 1 / (1.25 * 52)))\n        diff2_sim = diff_sim[ind2[0], :]\n        y2_sim[i] = np.angle(np.mean(diff2_sim))\n    phase_diff_results.append({\n        \"sim_idx\": sim_idx,\n        \"x\": x_sim,\n        \"y\": y_sim,\n        \"y2\": y2_sim\n    })\n</pre> # Get the cases for London from EWdata # For each simulation in results, compute phase difference arrays y_sim and y2_sim phase_diff_results = []  london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0] distances_from_london = distances[london_idx, :]  for sim_idx, df_sim in enumerate(results):     # Get London cases for this simulation     london_cases_sim = df_sim[df_sim[\"name\"].str.contains(\"London\", case=False)][\"cases\"].iloc[0]     ref_cwt_sim, frequencies_sim = calc_Ws(np.array(london_cases_sim[520:]).flatten())     x_sim = np.zeros(len(df_sim))     y_sim = np.zeros(len(df_sim))     y2_sim = np.zeros(len(df_sim))     for i, row in df_sim.iterrows():         if distances_from_london[i] &gt; 30:             continue         cwt_sim, frequencies_sim = calc_Ws(np.array(row[\"cases\"][520:]).flatten())         diff_sim = ref_cwt_sim * np.conj(cwt_sim)         ind = np.where(np.logical_and(frequencies_sim &lt; 1/(1.5 * 52), frequencies_sim &gt; 1 / (3 * 52)))         diff1_sim = diff_sim[ind[0], :]         x_sim[i] = distances_from_london[i]         y_sim[i] = np.angle(np.mean(diff1_sim))         ind2 = np.where(np.logical_and(frequencies_sim &lt; 1/(0.75 * 52), frequencies_sim &gt; 1 / (1.25 * 52)))         diff2_sim = diff_sim[ind2[0], :]         y2_sim[i] = np.angle(np.mean(diff2_sim))     phase_diff_results.append({         \"sim_idx\": sim_idx,         \"x\": x_sim,         \"y\": y_sim,         \"y2\": y2_sim     }) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[21], line 5\n      1 # Get the cases for London from EWdata\n      2 # For each simulation in results, compute phase difference arrays y_sim and y2_sim\n      3 phase_diff_results = []\n----&gt; 5 london_idx = EWdata[EWdata[\"name\"].str.contains(\"London\", case=False)].index[0]\n      6 distances_from_london = distances[london_idx, :]\n      8 for sim_idx, df_sim in enumerate(results):\n      9     # Get London cases for this simulation\n\nNameError: name 'EWdata' is not defined</pre> In\u00a0[22]: Copied! <pre>with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:\n    pickle.dump(phase_diff_results, f)\n</pre> with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:     pickle.dump(phase_diff_results, f) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[22], line 1\n----&gt; 1 with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"wb\") as f:\n      2     pickle.dump(phase_diff_results, f)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:343, in _modified_open(file, *args, **kwargs)\n    336 if file in {0, 1, 2}:\n    337     raise ValueError(\n    338         f\"IPython won't let you open fd={file} by default \"\n    339         \"as it is likely to crash IPython. If you know what you are doing, \"\n    340         \"you can use builtins' open.\"\n    341     )\n--&gt; 343 return io_open(file, *args, **kwargs)\n\nFileNotFoundError: [Errno 2] No such file or directory: '../outputs3/phase_diff_results2.pkl'</pre> In\u00a0[23]: Copied! <pre>with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:\n    phase_diff_results = pickle.load(f)\n</pre> with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:     phase_diff_results = pickle.load(f) <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 with open(os.path.join(output_dir, \"phase_diff_results2.pkl\"), \"rb\") as f:\n      2     phase_diff_results = pickle.load(f)\n\nFile /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/IPython/core/interactiveshell.py:343, in _modified_open(file, *args, **kwargs)\n    336 if file in {0, 1, 2}:\n    337     raise ValueError(\n    338         f\"IPython won't let you open fd={file} by default \"\n    339         \"as it is likely to crash IPython. If you know what you are doing, \"\n    340         \"you can use builtins' open.\"\n    341     )\n--&gt; 343 return io_open(file, *args, **kwargs)\n\nFileNotFoundError: [Errno 2] No such file or directory: '../outputs3/phase_diff_results2.pkl'</pre> In\u00a0[24]: Copied! <pre>params_df\n</pre> params_df Out[24]: k b c similarity In\u00a0[25]: Copied! <pre>for ind in range(100):\n    fig, axs = plt.subplots(1, 2, figsize=(12, 5))\n\n    # Left plot: Phase difference\n    axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')\n    axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')\n    axs[0].set_xlim(5, 30)\n    axs[0].set_ylim(-90, 90)\n    axs[0].set_xlabel(\"Distance from London\")\n    axs[0].set_ylabel(\"Phase difference\")\n    axs[0].set_title(\"Phase difference of London wavelet transform\")\n    axs[0].legend()\n\n    # Right plot: Proportion zero vs log10(population)\n    axs[1].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)\n    axs[1].plot(np.log10(results[10]['population']), results[ind][\"prop_low\"], '.', label='Simulated')\n    axs[1].set_xlabel(\"log10(Population)\")\n    axs[1].set_ylabel(\"Proportion zero\")\n    axs[1].set_title(\"Proportion zero vs log10(Population)\")\n    axs[1].legend()\n\n    plt.tight_layout()\n    plt.show()\n</pre> for ind in range(100):     fig, axs = plt.subplots(1, 2, figsize=(12, 5))      # Left plot: Phase difference     axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')     axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')     axs[0].set_xlim(5, 30)     axs[0].set_ylim(-90, 90)     axs[0].set_xlabel(\"Distance from London\")     axs[0].set_ylabel(\"Phase difference\")     axs[0].set_title(\"Phase difference of London wavelet transform\")     axs[0].legend()      # Right plot: Proportion zero vs log10(population)     axs[1].plot(np.log10(EWdata['population']), EWdata['prop_zero'], 'o', label='Observed', alpha=0.6)     axs[1].plot(np.log10(results[10]['population']), results[ind][\"prop_low\"], '.', label='Simulated')     axs[1].set_xlabel(\"log10(Population)\")     axs[1].set_ylabel(\"Proportion zero\")     axs[1].set_title(\"Proportion zero vs log10(Population)\")     axs[1].legend()      plt.tight_layout()     plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[25], line 5\n      2 fig, axs = plt.subplots(1, 2, figsize=(12, 5))\n      4 # Left plot: Phase difference\n----&gt; 5 axs[0].plot(x, -y*180/np.pi, 'o', label='Observed')\n      6 axs[0].plot(phase_diff_results[14][\"x\"], -phase_diff_results[ind][\"y\"]*180/np.pi, 'o', label='Simulated')\n      7 axs[0].set_xlim(5, 30)\n\nNameError: name 'x' is not defined</pre> In\u00a0[26]: Copied! <pre>from scipy.spatial.distance import euclidean\n\n# 1. Compute similarity between observed and each simulation's phase difference curve\n# We'll use the y (phase difference) vs x (distance) arrays\n\n# Only consider cities within 5-30 km (as in previous plots)\nmask = (x &gt;= 5) &amp; (x &lt;= 30)\nx_obs = x[mask]\ny_obs = y[mask]\n\nsim_scores = []\nfor sim in phase_diff_results:\n    x_sim = sim[\"x\"]\n    y_sim = sim[\"y\"]\n    # Interpolate simulation phase difference to observed x values for fair comparison\n    mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)\n    if np.sum(mask_sim) &lt; 5:  # skip if not enough points\n        sim_scores.append(np.inf)\n        continue\n    # Interpolate simulation y to observed x points\n    try:\n        y_sim_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])\n        score = np.sum((y_obs - y_sim_interp) ** 2)\n    except Exception:\n        score = np.inf\n    sim_scores.append(score)\n\n# 2. Get indices of the 10 best simulations (lowest scores)\ntop10_idx = np.argsort(sim_scores)[:10]\n\n# 3. Plot\nplt.figure(figsize=(8, 6), dpi=300)\nplt.plot(x_obs, -y_obs*180/np.pi, 'o', color='#0072B2', label='Observed', linewidth=2, markersize=6)\n\n# Color palette for simulations\nimport matplotlib.cm as cm\ncolors = cm.viridis(np.linspace(0, 1, 10))\n# Average the top 10 simulations' phase difference curves (interpolated to observed x points)\ny_sims_interp = []\nfor idx in top10_idx:\n    sim = phase_diff_results[idx]\n    x_sim = sim[\"x\"]\n    y_sim = sim[\"y\"]\n    mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)\n    if np.sum(mask_sim) &lt; 5:\n        continue\n    y_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])\n    y_sims_interp.append(y_interp)\ny_sims_interp = np.array(y_sims_interp)\ny_sim_mean = np.mean(y_sims_interp, axis=0)\ny_sim_std = np.std(y_sims_interp, axis=0)\n\n#plt.plot(x_obs, -y_sim_mean*180/np.pi, 'o', color='#E69F00', linewidth=2.5, label='Simulated (mean)')\nplt.errorbar(x_obs, -y_sim_mean*180/np.pi, yerr=y_sim_std*180/np.pi, marker='s', fmt='none', ecolor='#E69F00', capsize=3, label='Simulated (\u00b11 std)')\n\nplt.xlim(5, 30)\nplt.ylim(-90, 20)\nplt.xlabel(\"Distance from London (km)\", fontsize=14)\nplt.ylabel(\"Phase difference (degrees)\", fontsize=14)\nplt.title(\"Top 10 Simulations: Phase difference vs. Distance\", fontsize=16)\nplt.legend(fontsize=10, loc='lower left', ncol=2, frameon=True)\nplt.tight_layout()\nplt.grid(True, linestyle='--', alpha=0.3)\nplt.show()\n</pre> from scipy.spatial.distance import euclidean  # 1. Compute similarity between observed and each simulation's phase difference curve # We'll use the y (phase difference) vs x (distance) arrays  # Only consider cities within 5-30 km (as in previous plots) mask = (x &gt;= 5) &amp; (x &lt;= 30) x_obs = x[mask] y_obs = y[mask]  sim_scores = [] for sim in phase_diff_results:     x_sim = sim[\"x\"]     y_sim = sim[\"y\"]     # Interpolate simulation phase difference to observed x values for fair comparison     mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)     if np.sum(mask_sim) &lt; 5:  # skip if not enough points         sim_scores.append(np.inf)         continue     # Interpolate simulation y to observed x points     try:         y_sim_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])         score = np.sum((y_obs - y_sim_interp) ** 2)     except Exception:         score = np.inf     sim_scores.append(score)  # 2. Get indices of the 10 best simulations (lowest scores) top10_idx = np.argsort(sim_scores)[:10]  # 3. Plot plt.figure(figsize=(8, 6), dpi=300) plt.plot(x_obs, -y_obs*180/np.pi, 'o', color='#0072B2', label='Observed', linewidth=2, markersize=6)  # Color palette for simulations import matplotlib.cm as cm colors = cm.viridis(np.linspace(0, 1, 10)) # Average the top 10 simulations' phase difference curves (interpolated to observed x points) y_sims_interp = [] for idx in top10_idx:     sim = phase_diff_results[idx]     x_sim = sim[\"x\"]     y_sim = sim[\"y\"]     mask_sim = (x_sim &gt;= 5) &amp; (x_sim &lt;= 30)     if np.sum(mask_sim) &lt; 5:         continue     y_interp = np.interp(x_obs, x_sim[mask_sim], y_sim[mask_sim])     y_sims_interp.append(y_interp) y_sims_interp = np.array(y_sims_interp) y_sim_mean = np.mean(y_sims_interp, axis=0) y_sim_std = np.std(y_sims_interp, axis=0)  #plt.plot(x_obs, -y_sim_mean*180/np.pi, 'o', color='#E69F00', linewidth=2.5, label='Simulated (mean)') plt.errorbar(x_obs, -y_sim_mean*180/np.pi, yerr=y_sim_std*180/np.pi, marker='s', fmt='none', ecolor='#E69F00', capsize=3, label='Simulated (\u00b11 std)')  plt.xlim(5, 30) plt.ylim(-90, 20) plt.xlabel(\"Distance from London (km)\", fontsize=14) plt.ylabel(\"Phase difference (degrees)\", fontsize=14) plt.title(\"Top 10 Simulations: Phase difference vs. Distance\", fontsize=16) plt.legend(fontsize=10, loc='lower left', ncol=2, frameon=True) plt.tight_layout() plt.grid(True, linestyle='--', alpha=0.3) plt.show() <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[26], line 7\n      1 from scipy.spatial.distance import euclidean\n      3 # 1. Compute similarity between observed and each simulation's phase difference curve\n      4 # We'll use the y (phase difference) vs x (distance) arrays\n      5 \n      6 # Only consider cities within 5-30 km (as in previous plots)\n----&gt; 7 mask = (x &gt;= 5) &amp; (x &lt;= 30)\n      8 x_obs = x[mask]\n      9 y_obs = y[mask]\n\nNameError: name 'x' is not defined</pre> In\u00a0[27]: Copied! <pre># Compute the total cases across all towns for each simulation in results\ntotal_cases_per_sim = []\n\nfor df in results:\n    # Each row's \"cases\" is a list/array of weekly cases for that town\n    # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)\n    cases_matrix = np.stack(df[\"incidence\"].values)\n    # Sum across towns (axis=0) to get total cases per week\n    total_cases = cases_matrix.sum(axis=0)\n    total_cases_per_sim.append(total_cases)\n</pre> # Compute the total cases across all towns for each simulation in results total_cases_per_sim = []  for df in results:     # Each row's \"cases\" is a list/array of weekly cases for that town     # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)     cases_matrix = np.stack(df[\"incidence\"].values)     # Sum across towns (axis=0) to get total cases per week     total_cases = cases_matrix.sum(axis=0)     total_cases_per_sim.append(total_cases) <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[27], line 4\n      1 # Compute the total cases across all towns for each simulation in results\n      2 total_cases_per_sim = []\n----&gt; 4 for df in results:\n      5     # Each row's \"cases\" is a list/array of weekly cases for that town\n      6     # Stack all towns' cases into a 2D array: shape (num_towns, num_weeks)\n      7     cases_matrix = np.stack(df[\"incidence\"].values)\n      8     # Sum across towns (axis=0) to get total cases per week\n\nNameError: name 'results' is not defined</pre> In\u00a0[28]: Copied! <pre>plt.plot(total_cases_per_sim[39], label='Sim 1')\n</pre> plt.plot(total_cases_per_sim[39], label='Sim 1') <pre>\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 plt.plot(total_cases_per_sim[39], label='Sim 1')\n\nIndexError: list index out of range</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/distributions/","title":"Numba Compatible Distributions","text":"In\u00a0[1]: Copied! <pre>import numba as nb\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\nimport laser.core.distributions as distributions\n</pre> import numba as nb import numpy as np from matplotlib import pyplot as plt  import laser.core.distributions as distributions  In\u00a0[2]: Copied! <pre>def plot_histogram(data: list[tuple[np.ndarray, str, str]], bins: int = 101) -&gt; None:\n\n    for d, label, color in data:\n        plt.hist(d, bins=bins, density=True, alpha=0.6, color=color, label=label)\n    plt.xlabel('Value')\n    plt.ylabel('Density')\n    plt.title('Histogram')\n    plt.grid(True)\n    plt.legend()\n    plt.tight_layout()\n    plt.show()\n</pre> def plot_histogram(data: list[tuple[np.ndarray, str, str]], bins: int = 101) -&gt; None:      for d, label, color in data:         plt.hist(d, bins=bins, density=True, alpha=0.6, color=color, label=label)     plt.xlabel('Value')     plt.ylabel('Density')     plt.title('Histogram')     plt.grid(True)     plt.legend()     plt.tight_layout()     plt.show()  In\u00a0[3]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor alpha, beta, color in [(0.5, 0.5, \"red\"), (5.0, 1.0, \"blue\"), (1.0, 3.0, \"green\"), (2.0, 2.0, \"purple\"), (2.0, 5.0, \"orange\")]:\n\n    dist = distributions.beta(a=alpha, b=beta)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples, f'Beta({alpha}, {beta})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for alpha, beta, color in [(0.5, 0.5, \"red\"), (5.0, 1.0, \"blue\"), (1.0, 3.0, \"green\"), (2.0, 2.0, \"purple\"), (2.0, 5.0, \"orange\")]:      dist = distributions.beta(a=alpha, b=beta)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples, f'Beta({alpha}, {beta})', color))  plot_histogram(traces)  In\u00a0[4]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor p, n, color in [(0.5, 20, \"blue\"), (0.7, 20, \"green\"), (0.5, 40, \"red\")]:\n\n    dist = distributions.binomial(n=n, p=p)\n    distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))\n\n    traces.append((samples, f'Binomial({n}, {p})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for p, n, color in [(0.5, 20, \"blue\"), (0.7, 20, \"green\"), (0.5, 40, \"red\")]:      dist = distributions.binomial(n=n, p=p)     distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))      traces.append((samples, f'Binomial({n}, {p})', color))  plot_histogram(traces)  In\u00a0[5]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor lamda, color in [(0.5, \"red\"), (1.0, \"green\"), (1.5, \"lightblue\")]:\n\n    dist = distributions.exponential(scale=1/lamda)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt; 8], f'Exponential(1/{lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for lamda, color in [(0.5, \"red\"), (1.0, \"green\"), (1.5, \"lightblue\")]:      dist = distributions.exponential(scale=1/lamda)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt; 8], f'Exponential(1/{lamda})', color))  plot_histogram(traces)  In\u00a0[6]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor alpha, theta, color in [(1.0, 2.0, \"red\"), (2.0, 2.0, \"orange\"), (3.0, 2.0, \"yellow\"), (5.0, 1.0, \"green\"), (9.0, 0.5, \"black\"), (7.5, 1.0, \"blue\"), (0.5, 1.0, \"purple\")]:\n\n    dist = distributions.gamma(shape=alpha, scale=theta)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt; 0.25) &amp; (samples &lt;= 15)], f'Gamma({alpha}, {theta})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for alpha, theta, color in [(1.0, 2.0, \"red\"), (2.0, 2.0, \"orange\"), (3.0, 2.0, \"yellow\"), (5.0, 1.0, \"green\"), (9.0, 0.5, \"black\"), (7.5, 1.0, \"blue\"), (0.5, 1.0, \"purple\")]:      dist = distributions.gamma(shape=alpha, scale=theta)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt; 0.25) &amp; (samples &lt;= 15)], f'Gamma({alpha}, {theta})', color))  plot_histogram(traces)  In\u00a0[7]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, s, color in [(5, 2, \"blue\"), (9, 3, \"green\"), (9, 4, \"red\"), (6, 2, \"lightblue\"), (2, 1, \"purple\")]:\n\n    dist = distributions.logistic(loc=mu, scale=s)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 25)], f'Logistic({mu}, {s})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, s, color in [(5, 2, \"blue\"), (9, 3, \"green\"), (9, 4, \"red\"), (6, 2, \"lightblue\"), (2, 1, \"purple\")]:      dist = distributions.logistic(loc=mu, scale=s)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 25)], f'Logistic({mu}, {s})', color))  plot_histogram(traces)  In\u00a0[8]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, sigma, color in [(0, 1, \"blue\"), (0, 0.5, \"green\"), (0, 0.25, \"red\")]:\n\n    dist = distributions.lognormal(mean=mu, sigma=sigma)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt;= 3], f'Lognormal({mu}, {sigma})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, sigma, color in [(0, 1, \"blue\"), (0, 0.5, \"green\"), (0, 0.25, \"red\")]:      dist = distributions.lognormal(mean=mu, sigma=sigma)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt;= 3], f'Lognormal({mu}, {sigma})', color))  plot_histogram(traces)  In\u00a0[9]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor mu, sigmasq, color in [(0, 0.2, \"blue\"), (0, 1.0, \"red\"), (0, 5.0, \"orange\"), (-2, 0.5, \"green\")]:\n\n    dist = distributions.normal(loc=mu, scale=np.sqrt(sigmasq))\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 5)], f'Normal({mu}, {np.sqrt(sigmasq)})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for mu, sigmasq, color in [(0, 0.2, \"blue\"), (0, 1.0, \"red\"), (0, 5.0, \"orange\"), (-2, 0.5, \"green\")]:      dist = distributions.normal(loc=mu, scale=np.sqrt(sigmasq))     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[(samples &gt;= -5) &amp; (samples &lt;= 5)], f'Normal({mu}, {np.sqrt(sigmasq)})', color))  plot_histogram(traces)  In\u00a0[10]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor lamda, color in [(1, \"orange\"), (4, \"purple\"), (10, \"lightblue\")]:\n\n    dist = distributions.poisson(lam=lamda)\n    distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))\n\n    traces.append((samples[samples &lt;= 20], f'Poisson({lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for lamda, color in [(1, \"orange\"), (4, \"purple\"), (10, \"lightblue\")]:      dist = distributions.poisson(lam=lamda)     distributions.sample_ints(dist, samples := np.zeros(NSAMPLES, dtype=np.int32))      traces.append((samples[samples &lt;= 20], f'Poisson({lamda})', color))  plot_histogram(traces)  In\u00a0[11]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor low, high, color in [(0.0, 1.0, \"red\"), (0.25, 1.25, \"orange\"), (0.0, 2.0, \"green\"), (-1.0, 1.0,\"blue\"), (2.71828, 3.14159, \"indigo\"), (1.30, 4.20, \"violet\")]:\n\n    dist = distributions.uniform(low=low, high=high)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples, f'Uniform({low}, {high})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for low, high, color in [(0.0, 1.0, \"red\"), (0.25, 1.25, \"orange\"), (0.0, 2.0, \"green\"), (-1.0, 1.0,\"blue\"), (2.71828, 3.14159, \"indigo\"), (1.30, 4.20, \"violet\")]:      dist = distributions.uniform(low=low, high=high)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples, f'Uniform({low}, {high})', color))  plot_histogram(traces)  In\u00a0[12]: Copied! <pre>NSAMPLES = np.int32(100_000)\n\ntraces = []\nfor k, lamda, color in [(0.5, 1.0, \"blue\"), (1.0, 1.0, \"red\"), (1.5, 1.0, \"purple\"), (5.0, 1.0, \"green\")]:\n\n    dist = distributions.weibull(a=k, lam=lamda)\n    distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))\n\n    traces.append((samples[samples &lt;= 2.5], f'Weibull({k}, {lamda})', color))\n\nplot_histogram(traces)\n</pre> NSAMPLES = np.int32(100_000)  traces = [] for k, lamda, color in [(0.5, 1.0, \"blue\"), (1.0, 1.0, \"red\"), (1.5, 1.0, \"purple\"), (5.0, 1.0, \"green\")]:      dist = distributions.weibull(a=k, lam=lamda)     distributions.sample_floats(dist, samples := np.zeros(NSAMPLES, dtype=np.float32))      traces.append((samples[samples &lt;= 2.5], f'Weibull({k}, {lamda})', color))  plot_histogram(traces)"},{"location":"notebooks/distributions/#numba-compatible-distributions","title":"Numba Compatible Distributions\u00b6","text":"<p>Test each of the Numba compatible distributions.</p>"},{"location":"notebooks/distributions/#beta","title":"Beta\u00b6","text":""},{"location":"notebooks/distributions/#binomial","title":"Binomial\u00b6","text":""},{"location":"notebooks/distributions/#exponential","title":"Exponential\u00b6","text":""},{"location":"notebooks/distributions/#gamma","title":"Gamma\u00b6","text":""},{"location":"notebooks/distributions/#logistic","title":"Logistic\u00b6","text":""},{"location":"notebooks/distributions/#lognormal","title":"LogNormal\u00b6","text":""},{"location":"notebooks/distributions/#multinomial","title":"Multinomial\u00b6","text":""},{"location":"notebooks/distributions/#negativebinomial","title":"NegativeBinomial\u00b6","text":""},{"location":"notebooks/distributions/#normal","title":"Normal\u00b6","text":""},{"location":"notebooks/distributions/#poisson","title":"Poisson\u00b6","text":""},{"location":"notebooks/distributions/#uniform","title":"Uniform\u00b6","text":""},{"location":"notebooks/distributions/#weibull","title":"Weibull\u00b6","text":""}]}